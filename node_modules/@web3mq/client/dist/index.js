(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('js-sha3'), require('@noble/ed25519'), require('axios'), require('starknet'), require('js-sha256')) :
  typeof define === 'function' && define.amd ? define(['exports', 'js-sha3', '@noble/ed25519', 'axios', 'starknet', 'js-sha256'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["@web3mq/client"] = {}, global["js-sha3"], global.ed, global.axios, global.starknet, global["js-sha256"]));
})(this, (function (exports, jsSha3, ed, axios, starknet, jssha256) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var ed__default = /*#__PURE__*/_interopDefaultLegacy(ed);
  var axios__default = /*#__PURE__*/_interopDefaultLegacy(axios);
  var jssha256__default = /*#__PURE__*/_interopDefaultLegacy(jssha256);

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }

    return target;
  }

  function _regeneratorRuntime() {
    /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

    _regeneratorRuntime = function () {
      return exports;
    };

    var exports = {},
        Op = Object.prototype,
        hasOwn = Op.hasOwnProperty,
        $Symbol = "function" == typeof Symbol ? Symbol : {},
        iteratorSymbol = $Symbol.iterator || "@@iterator",
        asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
        toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function define(obj, key, value) {
      return Object.defineProperty(obj, key, {
        value: value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }), obj[key];
    }

    try {
      define({}, "");
    } catch (err) {
      define = function (obj, key, value) {
        return obj[key] = value;
      };
    }

    function wrap(innerFn, outerFn, self, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
          generator = Object.create(protoGenerator.prototype),
          context = new Context(tryLocsList || []);
      return generator._invoke = function (innerFn, self, context) {
        var state = "suspendedStart";
        return function (method, arg) {
          if ("executing" === state) throw new Error("Generator is already running");

          if ("completed" === state) {
            if ("throw" === method) throw arg;
            return doneResult();
          }

          for (context.method = method, context.arg = arg;;) {
            var delegate = context.delegate;

            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);

              if (delegateResult) {
                if (delegateResult === ContinueSentinel) continue;
                return delegateResult;
              }
            }

            if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
              if ("suspendedStart" === state) throw state = "completed", context.arg;
              context.dispatchException(context.arg);
            } else "return" === context.method && context.abrupt("return", context.arg);
            state = "executing";
            var record = tryCatch(innerFn, self, context);

            if ("normal" === record.type) {
              if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
              return {
                value: record.arg,
                done: context.done
              };
            }

            "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
          }
        };
      }(innerFn, self, context), generator;
    }

    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }

    exports.wrap = wrap;
    var ContinueSentinel = {};

    function Generator() {}

    function GeneratorFunction() {}

    function GeneratorFunctionPrototype() {}

    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function () {
      return this;
    });
    var getProto = Object.getPrototypeOf,
        NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }

    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);

        if ("throw" !== record.type) {
          var result = record.arg,
              value = result.value;
          return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          }) : PromiseImpl.resolve(value).then(function (unwrapped) {
            result.value = unwrapped, resolve(result);
          }, function (error) {
            return invoke("throw", error, resolve, reject);
          });
        }

        reject(record.arg);
      }

      var previousPromise;

      this._invoke = function (method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      };
    }

    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];

      if (undefined === method) {
        if (context.delegate = null, "throw" === context.method) {
          if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
          context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);
      if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
      var info = record.arg;
      return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
    }

    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };
      1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal", delete record.arg, entry.completion = record;
    }

    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
    }

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) return iteratorMethod.call(iterable);
        if ("function" == typeof iterable.next) return iterable;

        if (!isNaN(iterable.length)) {
          var i = -1,
              next = function next() {
            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;

            return next.value = undefined, next.done = !0, next;
          };

          return next.next = next;
        }
      }

      return {
        next: doneResult
      };
    }

    function doneResult() {
      return {
        value: undefined,
        done: !0
      };
    }

    return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
      var ctor = "function" == typeof genFun && genFun.constructor;
      return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports.mark = function (genFun) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports.awrap = function (arg) {
      return {
        __await: arg
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
      return this;
    }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      void 0 === PromiseImpl && (PromiseImpl = Promise);
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
      return this;
    }), define(Gp, "toString", function () {
      return "[object Generator]";
    }), exports.keys = function (object) {
      var keys = [];

      for (var key in object) keys.push(key);

      return keys.reverse(), function next() {
        for (; keys.length;) {
          var key = keys.pop();
          if (key in object) return next.value = key, next.done = !1, next;
        }

        return next.done = !0, next;
      };
    }, exports.values = values, Context.prototype = {
      constructor: Context,
      reset: function (skipTempReset) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
      },
      stop: function () {
        this.done = !0;
        var rootRecord = this.tryEntries[0].completion;
        if ("throw" === rootRecord.type) throw rootRecord.arg;
        return this.rval;
      },
      dispatchException: function (exception) {
        if (this.done) throw exception;
        var context = this;

        function handle(loc, caught) {
          return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i],
              record = entry.completion;
          if ("root" === entry.tryLoc) return handle("end");

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc"),
                hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            } else {
              if (!hasFinally) throw new Error("try statement without catch or finally");
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            }
          }
        }
      },
      abrupt: function (type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
        var record = finallyEntry ? finallyEntry.completion : {};
        return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
      },
      complete: function (record, afterLoc) {
        if ("throw" === record.type) throw record.arg;
        return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
      },
      finish: function (finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
        }
      },
      catch: function (tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;

            if ("throw" === record.type) {
              var thrown = record.arg;
              resetTryEntry(entry);
            }

            return thrown;
          }
        }

        throw new Error("illegal catch attempt");
      },
      delegateYield: function (iterable, resultName, nextLoc) {
        return this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
      }
    }, exports;
  }

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var request;
  var Request = /*#__PURE__*/_createClass(function Request(httpUrl) {
    var tempPubkey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var didKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

    _classCallCheck(this, Request);

    request = axios__default["default"].create({
      baseURL: httpUrl,
      headers: {
        'Content-Type': 'application/json;charset=UTF-8',
        'web3mq-request-pubkey': tempPubkey,
        didkey: didKey
      },
      timeout: 10000 // withCredentials: true,

    });
    request.interceptors.request.use(function (config) {
      return config;
    }, function (error) {
      throw new Error(error);
    });
    request.interceptors.response.use(function (response) {
      var data = response.data;

      if (data.code !== 0) {
        throw new Error(data.msg);
      }

      return data;
    }, function (error) {
      var _error$response = error.response,
          status = _error$response.status,
          data = _error$response.data;

      if (status !== 200) {
        throw new Error(data.message);
      }
    });
  });

  var testNet = [{
    members: [{
      name: 'to',
      offset: 0,
      type: 'felt'
    }, {
      name: 'selector',
      offset: 1,
      type: 'felt'
    }, {
      name: 'data_offset',
      offset: 2,
      type: 'felt'
    }, {
      name: 'data_len',
      offset: 3,
      type: 'felt'
    }],
    name: 'CallArray',
    size: 4,
    type: 'struct'
  }, {
    data: [{
      name: 'new_signer',
      type: 'felt'
    }],
    keys: [],
    name: 'signer_changed',
    type: 'event'
  }, {
    data: [{
      name: 'new_guardian',
      type: 'felt'
    }],
    keys: [],
    name: 'guardian_changed',
    type: 'event'
  }, {
    data: [{
      name: 'new_guardian',
      type: 'felt'
    }],
    keys: [],
    name: 'guardian_backup_changed',
    type: 'event'
  }, {
    data: [{
      name: 'active_at',
      type: 'felt'
    }],
    keys: [],
    name: 'escape_guardian_triggered',
    type: 'event'
  }, {
    data: [{
      name: 'active_at',
      type: 'felt'
    }],
    keys: [],
    name: 'escape_signer_triggered',
    type: 'event'
  }, {
    data: [],
    keys: [],
    name: 'escape_canceled',
    type: 'event'
  }, {
    data: [{
      name: 'new_guardian',
      type: 'felt'
    }],
    keys: [],
    name: 'guardian_escaped',
    type: 'event'
  }, {
    data: [{
      name: 'new_signer',
      type: 'felt'
    }],
    keys: [],
    name: 'signer_escaped',
    type: 'event'
  }, {
    data: [{
      name: 'new_implementation',
      type: 'felt'
    }],
    keys: [],
    name: 'account_upgraded',
    type: 'event'
  }, {
    data: [{
      name: 'account',
      type: 'felt'
    }, {
      name: 'key',
      type: 'felt'
    }, {
      name: 'guardian',
      type: 'felt'
    }],
    keys: [],
    name: 'account_created',
    type: 'event'
  }, {
    data: [{
      name: 'hash',
      type: 'felt'
    }, {
      name: 'response_len',
      type: 'felt'
    }, {
      name: 'response',
      type: 'felt*'
    }],
    keys: [],
    name: 'transaction_executed',
    type: 'event'
  }, {
    inputs: [{
      name: 'call_array_len',
      type: 'felt'
    }, {
      name: 'call_array',
      type: 'CallArray*'
    }, {
      name: 'calldata_len',
      type: 'felt'
    }, {
      name: 'calldata',
      type: 'felt*'
    }],
    name: '__validate__',
    outputs: [],
    type: 'function'
  }, {
    inputs: [{
      name: 'call_array_len',
      type: 'felt'
    }, {
      name: 'call_array',
      type: 'CallArray*'
    }, {
      name: 'calldata_len',
      type: 'felt'
    }, {
      name: 'calldata',
      type: 'felt*'
    }],
    name: '__execute__',
    outputs: [{
      name: 'retdata_size',
      type: 'felt'
    }, {
      name: 'retdata',
      type: 'felt*'
    }],
    type: 'function'
  }, {
    inputs: [{
      name: 'class_hash',
      type: 'felt'
    }],
    name: '__validate_declare__',
    outputs: [],
    type: 'function'
  }, {
    inputs: [{
      name: 'selector',
      type: 'felt'
    }, {
      name: 'calldata_size',
      type: 'felt'
    }, {
      name: 'calldata',
      type: 'felt*'
    }],
    name: '__validate_deploy__',
    outputs: [],
    type: 'function'
  }, {
    inputs: [{
      name: 'hash',
      type: 'felt'
    }, {
      name: 'sig_len',
      type: 'felt'
    }, {
      name: 'sig',
      type: 'felt*'
    }],
    name: 'isValidSignature',
    outputs: [{
      name: 'isValid',
      type: 'felt'
    }],
    stateMutability: 'view',
    type: 'function'
  }, {
    inputs: [{
      name: 'interfaceId',
      type: 'felt'
    }],
    name: 'supportsInterface',
    outputs: [{
      name: 'success',
      type: 'felt'
    }],
    stateMutability: 'view',
    type: 'function'
  }, {
    inputs: [{
      name: 'signer',
      type: 'felt'
    }, {
      name: 'guardian',
      type: 'felt'
    }],
    name: 'initialize',
    outputs: [],
    type: 'function'
  }, {
    inputs: [{
      name: 'implementation',
      type: 'felt'
    }, {
      name: 'calldata_len',
      type: 'felt'
    }, {
      name: 'calldata',
      type: 'felt*'
    }],
    name: 'upgrade',
    outputs: [{
      name: 'retdata_len',
      type: 'felt'
    }, {
      name: 'retdata',
      type: 'felt*'
    }],
    type: 'function'
  }, {
    inputs: [{
      name: 'call_array_len',
      type: 'felt'
    }, {
      name: 'call_array',
      type: 'CallArray*'
    }, {
      name: 'calldata_len',
      type: 'felt'
    }, {
      name: 'calldata',
      type: 'felt*'
    }],
    name: 'execute_after_upgrade',
    outputs: [{
      name: 'retdata_len',
      type: 'felt'
    }, {
      name: 'retdata',
      type: 'felt*'
    }],
    type: 'function'
  }, {
    inputs: [{
      name: 'newSigner',
      type: 'felt'
    }],
    name: 'changeSigner',
    outputs: [],
    type: 'function'
  }, {
    inputs: [{
      name: 'newGuardian',
      type: 'felt'
    }],
    name: 'changeGuardian',
    outputs: [],
    type: 'function'
  }, {
    inputs: [{
      name: 'newGuardian',
      type: 'felt'
    }],
    name: 'changeGuardianBackup',
    outputs: [],
    type: 'function'
  }, {
    inputs: [],
    name: 'triggerEscapeGuardian',
    outputs: [],
    type: 'function'
  }, {
    inputs: [],
    name: 'triggerEscapeSigner',
    outputs: [],
    type: 'function'
  }, {
    inputs: [],
    name: 'cancelEscape',
    outputs: [],
    type: 'function'
  }, {
    inputs: [{
      name: 'newGuardian',
      type: 'felt'
    }],
    name: 'escapeGuardian',
    outputs: [],
    type: 'function'
  }, {
    inputs: [{
      name: 'newSigner',
      type: 'felt'
    }],
    name: 'escapeSigner',
    outputs: [],
    type: 'function'
  }, {
    inputs: [],
    name: 'getSigner',
    outputs: [{
      name: 'signer',
      type: 'felt'
    }],
    stateMutability: 'view',
    type: 'function'
  }, {
    inputs: [],
    name: 'getGuardian',
    outputs: [{
      name: 'guardian',
      type: 'felt'
    }],
    stateMutability: 'view',
    type: 'function'
  }, {
    inputs: [],
    name: 'getGuardianBackup',
    outputs: [{
      name: 'guardianBackup',
      type: 'felt'
    }],
    stateMutability: 'view',
    type: 'function'
  }, {
    inputs: [],
    name: 'getEscape',
    outputs: [{
      name: 'activeAt',
      type: 'felt'
    }, {
      name: 'type',
      type: 'felt'
    }],
    stateMutability: 'view',
    type: 'function'
  }, {
    inputs: [],
    name: 'getVersion',
    outputs: [{
      name: 'version',
      type: 'felt'
    }],
    stateMutability: 'view',
    type: 'function'
  }, {
    inputs: [],
    name: 'getName',
    outputs: [{
      name: 'name',
      type: 'felt'
    }],
    stateMutability: 'view',
    type: 'function'
  }, {
    inputs: [{
      name: 'hash',
      type: 'felt'
    }, {
      name: 'sig_len',
      type: 'felt'
    }, {
      name: 'sig',
      type: 'felt*'
    }],
    name: 'is_valid_signature',
    outputs: [{
      name: 'is_valid',
      type: 'felt'
    }],
    stateMutability: 'view',
    type: 'function'
  }];

  function E() {
  }
  function Ne(t) {
    return t();
  }
  function he() {
    return /* @__PURE__ */ Object.create(null);
  }
  function L(t) {
    t.forEach(Ne);
  }
  function Se(t) {
    return typeof t == "function";
  }
  function Oe(t, e) {
    return t != t ? e == e : t !== e || t && typeof t == "object" || typeof t == "function";
  }
  let Z;
  function le(t, e) {
    return Z || (Z = document.createElement("a")), Z.href = e, t === Z.href;
  }
  function _e(t) {
    return Object.keys(t).length === 0;
  }
  function ee(t) {
    return t == null ? "" : t;
  }
  function k(t, e) {
    t.appendChild(e);
  }
  function Le(t, e, r) {
    const s = Te(t);
    if (!s.getElementById(e)) {
      const i = I("style");
      i.id = e, i.textContent = r, Fe(s, i);
    }
  }
  function Te(t) {
    if (!t)
      return document;
    const e = t.getRootNode ? t.getRootNode() : t.ownerDocument;
    return e && e.host ? e : t.ownerDocument;
  }
  function Fe(t, e) {
    k(t.head || t, e);
  }
  function V(t, e, r) {
    t.insertBefore(e, r || null);
  }
  function B(t) {
    t.parentNode.removeChild(t);
  }
  function fe(t, e) {
    for (let r = 0; r < t.length; r += 1)
      t[r] && t[r].d(e);
  }
  function I(t) {
    return document.createElement(t);
  }
  function K(t) {
    return document.createTextNode(t);
  }
  function F() {
    return K(" ");
  }
  function D(t, e, r, s) {
    return t.addEventListener(e, r, s), () => t.removeEventListener(e, r, s);
  }
  function m(t, e, r) {
    r == null ? t.removeAttribute(e) : t.getAttribute(e) !== r && t.setAttribute(e, r);
  }
  function Ee(t) {
    return Array.from(t.childNodes);
  }
  function Be(t, e) {
    e = "" + e, t.wholeText !== e && (t.data = e);
  }
  let R;
  function Y(t) {
    R = t;
  }
  function Pe() {
    if (!R)
      throw new Error("Function called outside component initialization");
    return R;
  }
  function We(t) {
    Pe().$$.on_mount.push(t);
  }
  const W = [], be = [], J = [], me = [], Qe = Promise.resolve();
  let de = !1;
  function Ye() {
    de || (de = !0, Qe.then(Ie));
  }
  function ge(t) {
    J.push(t);
  }
  const te = /* @__PURE__ */ new Set();
  let H = 0;
  function Ie() {
    const t = R;
    do {
      for (; H < W.length; ) {
        const e = W[H];
        H++, Y(e), Ue(e.$$);
      }
      for (Y(null), W.length = 0, H = 0; be.length; )
        be.pop()();
      for (let e = 0; e < J.length; e += 1) {
        const r = J[e];
        te.has(r) || (te.add(r), r());
      }
      J.length = 0;
    } while (W.length);
    for (; me.length; )
      me.pop()();
    de = !1, te.clear(), Y(t);
  }
  function Ue(t) {
    if (t.fragment !== null) {
      t.update(), L(t.before_update);
      const e = t.dirty;
      t.dirty = [-1], t.fragment && t.fragment.p(t.ctx, e), t.after_update.forEach(ge);
    }
  }
  const Re = /* @__PURE__ */ new Set();
  function Ve(t, e) {
    t && t.i && (Re.delete(t), t.i(e));
  }
  function Ge(t, e, r, s) {
    const { fragment: i, on_mount: o, on_destroy: a, after_update: d } = t.$$;
    i && i.m(e, r), s || ge(() => {
      const c = o.map(Ne).filter(Se);
      a ? a.push(...c) : L(c), t.$$.on_mount = [];
    }), d.forEach(ge);
  }
  function Ze(t, e) {
    const r = t.$$;
    r.fragment !== null && (L(r.on_destroy), r.fragment && r.fragment.d(e), r.on_destroy = r.fragment = null, r.ctx = []);
  }
  function He(t, e) {
    t.$$.dirty[0] === -1 && (W.push(t), Ye(), t.$$.dirty.fill(0)), t.$$.dirty[e / 31 | 0] |= 1 << e % 31;
  }
  function Xe(t, e, r, s, i, o, a, d = [-1]) {
    const c = R;
    Y(t);
    const l = t.$$ = {
      fragment: null,
      ctx: null,
      props: o,
      update: E,
      not_equal: i,
      bound: he(),
      on_mount: [],
      on_destroy: [],
      on_disconnect: [],
      before_update: [],
      after_update: [],
      context: new Map(e.context || (c ? c.$$.context : [])),
      callbacks: he(),
      dirty: d,
      skip_bound: !1,
      root: e.target || c.$$.root
    };
    a && a(l.root);
    let h = !1;
    if (l.ctx = r ? r(t, e.props || {}, (g, u, ...j) => {
      const v = j.length ? j[0] : u;
      return l.ctx && i(l.ctx[g], l.ctx[g] = v) && (!l.skip_bound && l.bound[g] && l.bound[g](v), h && He(t, g)), u;
    }) : [], l.update(), h = !0, L(l.before_update), l.fragment = s ? s(l.ctx) : !1, e.target) {
      if (e.hydrate) {
        const g = Ee(e.target);
        l.fragment && l.fragment.l(g), g.forEach(B);
      } else
        l.fragment && l.fragment.c();
      e.intro && Ve(t.$$.fragment), Ge(t, e.target, e.anchor, e.customElement), Ie();
    }
    Y(c);
  }
  class Je {
    $destroy() {
      Ze(this, 1), this.$destroy = E;
    }
    $on(e, r) {
      const s = this.$$.callbacks[e] || (this.$$.callbacks[e] = []);
      return s.push(r), () => {
        const i = s.indexOf(r);
        i !== -1 && s.splice(i, 1);
      };
    }
    $set(e) {
      this.$$set && !_e(e) && (this.$$.skip_bound = !0, this.$$set(e), this.$$.skip_bound = !1);
    }
  }
  function qe(t) {
    Le(t, "svelte-1gnjz2", `.sr-only.svelte-1gnjz2.svelte-1gnjz2{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.fixed.svelte-1gnjz2.svelte-1gnjz2{position:fixed}.inset-0.svelte-1gnjz2.svelte-1gnjz2{top:0px;right:0px;bottom:0px;left:0px}.z-40.svelte-1gnjz2.svelte-1gnjz2{z-index:40}.z-50.svelte-1gnjz2.svelte-1gnjz2{z-index:50}.mx-6.svelte-1gnjz2.svelte-1gnjz2{margin-left:1.5rem;margin-right:1.5rem}.mb-4.svelte-1gnjz2.svelte-1gnjz2{margin-bottom:1rem}.flex.svelte-1gnjz2.svelte-1gnjz2{display:flex}.h-8.svelte-1gnjz2.svelte-1gnjz2{height:2rem}.w-full.svelte-1gnjz2.svelte-1gnjz2{width:100%}.w-8.svelte-1gnjz2.svelte-1gnjz2{width:2rem}.max-w-\\[500px\\].svelte-1gnjz2.svelte-1gnjz2{max-width:500px}@-webkit-keyframes svelte-1gnjz2-spin{to{transform:rotate(360deg)}}@keyframes svelte-1gnjz2-spin{to{transform:rotate(360deg)}}.animate-spin.svelte-1gnjz2.svelte-1gnjz2{-webkit-animation:svelte-1gnjz2-spin 1s linear infinite;animation:svelte-1gnjz2-spin 1s linear infinite}.cursor-pointer.svelte-1gnjz2.svelte-1gnjz2{cursor:pointer}.flex-col.svelte-1gnjz2.svelte-1gnjz2{flex-direction:column}.items-center.svelte-1gnjz2.svelte-1gnjz2{align-items:center}.justify-center.svelte-1gnjz2.svelte-1gnjz2{justify-content:center}.justify-between.svelte-1gnjz2.svelte-1gnjz2{justify-content:space-between}.gap-3.svelte-1gnjz2.svelte-1gnjz2{gap:0.75rem}.rounded-md.svelte-1gnjz2.svelte-1gnjz2{border-radius:0.375rem}.rounded-full.svelte-1gnjz2.svelte-1gnjz2{border-radius:9999px}.bg-black\\/25.svelte-1gnjz2.svelte-1gnjz2{background-color:rgb(0 0 0 / 0.25)}.bg-slate-50.svelte-1gnjz2.svelte-1gnjz2{--tw-bg-opacity:1;background-color:rgb(248 250 252 / var(--tw-bg-opacity))}.bg-slate-100.svelte-1gnjz2.svelte-1gnjz2{--tw-bg-opacity:1;background-color:rgb(241 245 249 / var(--tw-bg-opacity))}.fill-neutral-600.svelte-1gnjz2.svelte-1gnjz2{fill:#525252}.p-4.svelte-1gnjz2.svelte-1gnjz2{padding:1rem}.p-3.svelte-1gnjz2.svelte-1gnjz2{padding:0.75rem}.text-center.svelte-1gnjz2.svelte-1gnjz2{text-align:center}.text-xl.svelte-1gnjz2.svelte-1gnjz2{font-size:1.25rem;line-height:1.75rem}.text-neutral-300.svelte-1gnjz2.svelte-1gnjz2{--tw-text-opacity:1;color:rgb(212 212 212 / var(--tw-text-opacity))}.antialiased.svelte-1gnjz2.svelte-1gnjz2{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.shadow.svelte-1gnjz2.svelte-1gnjz2{--tw-shadow:0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.shadow-sm.svelte-1gnjz2.svelte-1gnjz2{--tw-shadow:0 1px 2px 0 rgb(0 0 0 / 0.05);--tw-shadow-colored:0 1px 2px 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.filter.svelte-1gnjz2.svelte-1gnjz2{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.backdrop-blur-sm.svelte-1gnjz2.svelte-1gnjz2{--tw-backdrop-blur:blur(4px);-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}.transition-colors.svelte-1gnjz2.svelte-1gnjz2{transition-property:color, background-color, border-color, fill, stroke, -webkit-text-decoration-color;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, -webkit-text-decoration-color;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}.svelte-1gnjz2.svelte-1gnjz2,.svelte-1gnjz2.svelte-1gnjz2::before,.svelte-1gnjz2.svelte-1gnjz2::after{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}.svelte-1gnjz2.svelte-1gnjz2::before,.svelte-1gnjz2.svelte-1gnjz2::after{--tw-content:''}h1.svelte-1gnjz2.svelte-1gnjz2{font-size:inherit;font-weight:inherit}a.svelte-1gnjz2.svelte-1gnjz2{color:inherit;text-decoration:inherit}.svelte-1gnjz2.svelte-1gnjz2:-moz-focusring{outline:auto}.svelte-1gnjz2.svelte-1gnjz2:-moz-ui-invalid{box-shadow:none}.svelte-1gnjz2.svelte-1gnjz2::-webkit-inner-spin-button,.svelte-1gnjz2.svelte-1gnjz2::-webkit-outer-spin-button{height:auto}.svelte-1gnjz2.svelte-1gnjz2::-webkit-search-decoration{-webkit-appearance:none}.svelte-1gnjz2.svelte-1gnjz2::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}h1.svelte-1gnjz2.svelte-1gnjz2{margin:0}ul.svelte-1gnjz2.svelte-1gnjz2{list-style:none;margin:0;padding:0}[role="button"].svelte-1gnjz2.svelte-1gnjz2{cursor:pointer}.svelte-1gnjz2.svelte-1gnjz2:disabled{cursor:default}img.svelte-1gnjz2.svelte-1gnjz2,svg.svelte-1gnjz2.svelte-1gnjz2{display:block;vertical-align:middle}img.svelte-1gnjz2.svelte-1gnjz2{max-width:100%;height:auto}.svelte-1gnjz2.svelte-1gnjz2,.svelte-1gnjz2.svelte-1gnjz2::before,.svelte-1gnjz2.svelte-1gnjz2::after{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x:  ;--tw-pan-y:  ;--tw-pinch-zoom:  ;--tw-scroll-snap-strictness:proximity;--tw-ordinal:  ;--tw-slashed-zero:  ;--tw-numeric-figure:  ;--tw-numeric-spacing:  ;--tw-numeric-fraction:  ;--tw-ring-inset:  ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur:  ;--tw-brightness:  ;--tw-contrast:  ;--tw-grayscale:  ;--tw-hue-rotate:  ;--tw-invert:  ;--tw-saturate:  ;--tw-sepia:  ;--tw-drop-shadow:  ;--tw-backdrop-blur:  ;--tw-backdrop-brightness:  ;--tw-backdrop-contrast:  ;--tw-backdrop-grayscale:  ;--tw-backdrop-hue-rotate:  ;--tw-backdrop-invert:  ;--tw-backdrop-opacity:  ;--tw-backdrop-saturate:  ;--tw-backdrop-sepia:  }.svelte-1gnjz2.svelte-1gnjz2::-webkit-backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x:  ;--tw-pan-y:  ;--tw-pinch-zoom:  ;--tw-scroll-snap-strictness:proximity;--tw-ordinal:  ;--tw-slashed-zero:  ;--tw-numeric-figure:  ;--tw-numeric-spacing:  ;--tw-numeric-fraction:  ;--tw-ring-inset:  ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur:  ;--tw-brightness:  ;--tw-contrast:  ;--tw-grayscale:  ;--tw-hue-rotate:  ;--tw-invert:  ;--tw-saturate:  ;--tw-sepia:  ;--tw-drop-shadow:  ;--tw-backdrop-blur:  ;--tw-backdrop-brightness:  ;--tw-backdrop-contrast:  ;--tw-backdrop-grayscale:  ;--tw-backdrop-hue-rotate:  ;--tw-backdrop-invert:  ;--tw-backdrop-opacity:  ;--tw-backdrop-saturate:  ;--tw-backdrop-sepia:  }.svelte-1gnjz2.svelte-1gnjz2::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x:  ;--tw-pan-y:  ;--tw-pinch-zoom:  ;--tw-scroll-snap-strictness:proximity;--tw-ordinal:  ;--tw-slashed-zero:  ;--tw-numeric-figure:  ;--tw-numeric-spacing:  ;--tw-numeric-fraction:  ;--tw-ring-inset:  ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur:  ;--tw-brightness:  ;--tw-contrast:  ;--tw-grayscale:  ;--tw-hue-rotate:  ;--tw-invert:  ;--tw-saturate:  ;--tw-sepia:  ;--tw-drop-shadow:  ;--tw-backdrop-blur:  ;--tw-backdrop-brightness:  ;--tw-backdrop-contrast:  ;--tw-backdrop-grayscale:  ;--tw-backdrop-hue-rotate:  ;--tw-backdrop-invert:  ;--tw-backdrop-opacity:  ;--tw-backdrop-saturate:  ;--tw-backdrop-sepia:  }.svelte-1gnjz2.svelte-1gnjz2{font-family:Nunito, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto,
      Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue,
      sans-serif;-webkit-font-smoothing:antialiased}.hover\\:bg-slate-200.svelte-1gnjz2.svelte-1gnjz2:hover{--tw-bg-opacity:1;background-color:rgb(226 232 240 / var(--tw-bg-opacity))}.dark.svelte-1gnjz2 .dark\\:border-neutral-600.svelte-1gnjz2{--tw-border-opacity:1;border-color:rgb(82 82 82 / var(--tw-border-opacity))}.dark.svelte-1gnjz2 .dark\\:bg-neutral-900.svelte-1gnjz2{--tw-bg-opacity:1;background-color:rgb(23 23 23 / var(--tw-bg-opacity))}.dark.svelte-1gnjz2 .dark\\:bg-neutral-800.svelte-1gnjz2{--tw-bg-opacity:1;background-color:rgb(38 38 38 / var(--tw-bg-opacity))}.dark.svelte-1gnjz2 .dark\\:fill-neutral-300.svelte-1gnjz2{fill:#d4d4d4}.dark.svelte-1gnjz2 .dark\\:text-white.svelte-1gnjz2{--tw-text-opacity:1;color:rgb(255 255 255 / var(--tw-text-opacity))}.dark.svelte-1gnjz2 .dark\\:text-neutral-600.svelte-1gnjz2{--tw-text-opacity:1;color:rgb(82 82 82 / var(--tw-text-opacity))}.dark.svelte-1gnjz2 .dark\\:hover\\:bg-neutral-700.svelte-1gnjz2:hover{--tw-bg-opacity:1;background-color:rgb(64 64 64 / var(--tw-bg-opacity))}`);
  }
  function pe(t, e, r) {
    const s = t.slice();
    return s[20] = e[r], s;
  }
  function Me(t, e, r) {
    const s = t.slice();
    return s[23] = e[r], s;
  }
  function Ke(t) {
    let e, r;
    return {
      c() {
        e = I("img"), m(e, "alt", t[23].name), le(e.src, r = t[23].icon) || m(e, "src", r), m(e, "class", "w-8 h-8 rounded-full svelte-1gnjz2");
      },
      m(s, i) {
        V(s, e, i);
      },
      p: E,
      d(s) {
        s && B(e);
      }
    };
  }
  function $e(t) {
    let e;
    return {
      c() {
        e = I("div"), e.innerHTML = `<svg aria-hidden="true" class="w-8 h-8 text-neutral-300 animate-spin dark:text-neutral-600 fill-neutral-600 dark:fill-neutral-300 svelte-1gnjz2" viewBox="0 0 100 101" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z" fill="currentColor" class="svelte-1gnjz2"></path><path d="M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z" fill="currentFill" class="svelte-1gnjz2"></path></svg> 
              <span class="sr-only svelte-1gnjz2">Loading...</span>`, m(e, "role", "status"), m(e, "class", "svelte-1gnjz2");
      },
      m(r, s) {
        V(r, e, s);
      },
      p: E,
      d(r) {
        r && B(e);
      }
    };
  }
  function ve(t) {
    let e, r = t[23].name + "", s, i, o, a;
    function d(u, j) {
      return u[1] === u[23].id ? $e : Ke;
    }
    let c = d(t), l = c(t);
    function h() {
      return t[12](t[23]);
    }
    function g(...u) {
      return t[13](t[23], ...u);
    }
    return {
      c() {
        e = I("li"), s = K(r), i = F(), l.c(), m(e, "class", "flex justify-between items-center p-3 bg-slate-100 rounded-md cursor-pointer shadow-sm hover:bg-slate-200 transition-colors dark:bg-neutral-800 dark:hover:bg-neutral-700 dark:border-neutral-600 dark:text-white svelte-1gnjz2");
      },
      m(u, j) {
        V(u, e, j), k(e, s), k(e, i), l.m(e, null), o || (a = [
          D(e, "click", h),
          D(e, "keyup", g)
        ], o = !0);
      },
      p(u, j) {
        t = u, c === (c = d(t)) && l ? l.p(t, j) : (l.d(1), l = c(t), l && (l.c(), l.m(e, null)));
      },
      d(u) {
        u && B(e), l.d(), o = !1, L(a);
      }
    };
  }
  function je(t) {
    let e, r, s, i = t[20].name + "", o, a, d, c, l, h, g, u, j, v;
    return {
      c() {
        e = I("a"), r = I("li"), s = K("Install "), o = K(i), a = F(), d = I("img"), h = F(), m(d, "alt", c = t[20].name), le(d.src, l = t[20].icon) || m(d, "src", l), m(d, "class", "w-8 h-8 rounded-full svelte-1gnjz2"), m(r, "class", "flex justify-between items-center p-3 bg-slate-100 rounded-md shadow-sm cursor-pointer hover:bg-slate-200 transition-colors dark:bg-neutral-800 dark:hover:bg-neutral-700 dark:border-neutral-600 dark:text-white svelte-1gnjz2"), m(e, "alt", g = t[20].name + " download link"), m(e, "href", u = t[20].download), m(e, "target", "_blank"), m(e, "rel", "noopener noreferrer"), m(e, "class", "svelte-1gnjz2");
      },
      m(y, M) {
        V(y, e, M), k(e, r), k(r, s), k(r, o), k(r, a), k(r, d), k(e, h), j || (v = [
          D(r, "click", t[14]),
          D(r, "keyup", t[15])
        ], j = !0);
      },
      p(y, M) {
        M & 1 && i !== (i = y[20].name + "") && Be(o, i), M & 1 && c !== (c = y[20].name) && m(d, "alt", c), M & 1 && !le(d.src, l = y[20].icon) && m(d, "src", l), M & 1 && g !== (g = y[20].name + " download link") && m(e, "alt", g), M & 1 && u !== (u = y[20].download) && m(e, "href", u);
      },
      d(y) {
        y && B(e), j = !1, L(v);
      }
    };
  }
  function et(t) {
    let e, r, s, i, o, a, d, c, l, h, g, u, j = t[4], v = [];
    for (let f = 0; f < j.length; f += 1)
      v[f] = ve(Me(t, j, f));
    let y = t[0], M = [];
    for (let f = 0; f < y.length; f += 1)
      M[f] = je(pe(t, y, f));
    return {
      c() {
        e = I("div"), r = I("main"), s = I("header"), i = I("h1"), i.textContent = "Connect a wallet", o = F(), a = I("span"), a.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" height="24px" width="24px" viewBox="0 0 24 24" fill="currentColor" class="svelte-1gnjz2"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z" class="svelte-1gnjz2"></path></svg>', d = F(), c = I("ul");
        for (let f = 0; f < v.length; f += 1)
          v[f].c();
        l = F();
        for (let f = 0; f < M.length; f += 1)
          M[f].c();
        m(i, "class", "text-xl svelte-1gnjz2"), m(a, "role", "button"), m(a, "alt", "Close"), m(a, "class", "cursor-pointer svelte-1gnjz2"), m(s, "class", "flex items-center justify-between mb-4 svelte-1gnjz2"), m(c, "class", "flex flex-col gap-3 svelte-1gnjz2"), m(r, "role", "dialog"), m(r, "class", ee("bg-slate-50 rounded-md shadow w-full max-w-[500px] mx-6 p-4 text-center z-50 dark:bg-neutral-900 dark:text-white") + " svelte-1gnjz2"), m(e, "class", h = ee("backdrop-blur-sm fixed inset-0 flex items-center justify-center bg-black/25 z-40 " + t[2]) + " svelte-1gnjz2");
      },
      m(f, x) {
        V(f, e, x), k(e, r), k(r, s), k(s, i), k(s, o), k(s, a), k(r, d), k(r, c);
        for (let w = 0; w < v.length; w += 1)
          v[w].m(c, null);
        k(c, l);
        for (let w = 0; w < M.length; w += 1)
          M[w].m(c, null);
        g || (u = [
          D(a, "click", t[10]),
          D(a, "keyup", t[11]),
          D(r, "click", tt),
          D(r, "keyup", rt),
          D(e, "click", t[16]),
          D(e, "keyup", t[17])
        ], g = !0);
      },
      p(f, [x]) {
        if (x & 26) {
          j = f[4];
          let w;
          for (w = 0; w < j.length; w += 1) {
            const O = Me(f, j, w);
            v[w] ? v[w].p(O, x) : (v[w] = ve(O), v[w].c(), v[w].m(c, l));
          }
          for (; w < v.length; w += 1)
            v[w].d(1);
          v.length = j.length;
        }
        if (x & 9) {
          y = f[0];
          let w;
          for (w = 0; w < y.length; w += 1) {
            const O = pe(f, y, w);
            M[w] ? M[w].p(O, x) : (M[w] = je(O), M[w].c(), M[w].m(c, null));
          }
          for (; w < M.length; w += 1)
            M[w].d(1);
          M.length = y.length;
        }
        x & 4 && h !== (h = ee("backdrop-blur-sm fixed inset-0 flex items-center justify-center bg-black/25 z-40 " + f[2]) + " svelte-1gnjz2") && m(e, "class", h);
      },
      i: E,
      o: E,
      d(f) {
        f && B(e), fe(v, f), fe(M, f), g = !1, L(u);
      }
    };
  }
  const tt = (t) => t.stopPropagation(), rt = (t) => t.stopPropagation();
  function st(t, e, r) {
    const s = typeof window < "u" ? window : null;
    let { lastWallet: i = null } = e, { installedWallets: o = [] } = e, { preAuthorizedWallets: a = [] } = e, { discoveryWallets: d = [] } = e, { callback: c = async () => {
    } } = e, { theme: l = null } = e, h = !1, g = async (b) => {
      var G;
      r(1, h = (G = b == null ? void 0 : b.id) != null ? G : !1), await c(b).catch(() => {
      }), r(1, h = !1);
    }, u = "";
    l === "dark" || l === null && (s == null ? void 0 : s.matchMedia("(prefers-color-scheme: dark)").matches) ? u = "dark" : u = "";
    const j = (b) => {
      r(2, u = b.matches ? "dark" : "");
    };
    We(() => {
      if (l === null)
        return s == null || s.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", j), () => {
          s == null || s.matchMedia("(prefers-color-scheme: dark)").removeEventListener("change", j);
        };
    });
    const v = [i, ...a, ...o].filter(Boolean), y = () => g(null), M = (b) => {
      b.key === "Enter" && g(null);
    }, f = (b) => g(b), x = (b, G) => {
      G.key === "Enter" && g(b);
    }, w = () => g(null), O = (b) => {
      b.key === "Enter" && g(null);
    }, xe = () => g(null), Ce = (b) => {
      b.key === "Escape" && g(null);
    };
    return t.$$set = (b) => {
      "lastWallet" in b && r(5, i = b.lastWallet), "installedWallets" in b && r(6, o = b.installedWallets), "preAuthorizedWallets" in b && r(7, a = b.preAuthorizedWallets), "discoveryWallets" in b && r(0, d = b.discoveryWallets), "callback" in b && r(8, c = b.callback), "theme" in b && r(9, l = b.theme);
    }, [
      d,
      h,
      u,
      g,
      v,
      i,
      o,
      a,
      c,
      l,
      y,
      M,
      f,
      x,
      w,
      O,
      xe,
      Ce
    ];
  }
  class nt extends Je {
    constructor(e) {
      super(), Xe(
        this,
        e,
        st,
        et,
        Oe,
        {
          lastWallet: 5,
          installedWallets: 6,
          preAuthorizedWallets: 7,
          discoveryWallets: 0,
          callback: 8,
          theme: 9
        },
        qe
      );
    }
  }
  function re(t, e) {
    return t.filter((r) => !e.some((s) => s.id === r.id));
  }
  async function it({
    discoveryWallets: t,
    installedWallets: e,
    lastWallet: r,
    preAuthorizedWallets: s,
    enable: i,
    modalOptions: o
  }) {
    return new Promise((a) => {
      var l;
      const d = [r].filter(Boolean);
      s = re(s, d), e = re(e, [
        ...d,
        ...s
      ]), t = re(t, [
        ...d,
        ...e,
        ...s
      ]);
      const c = new nt({
        target: document.body,
        props: {
          callback: async (h) => {
            var u;
            const g = (u = await (i == null ? void 0 : i(h))) != null ? u : h;
            c.$destroy(), a(g);
          },
          lastWallet: r,
          installedWallets: e,
          preAuthorizedWallets: s,
          discoveryWallets: t,
          theme: (o == null ? void 0 : o.theme) === "system" ? null : (l = o == null ? void 0 : o.theme) != null ? l : null
        }
      });
    });
  }
  const ot = {
    "Amazon Silk": "amazon_silk",
    "Android Browser": "android",
    Bada: "bada",
    BlackBerry: "blackberry",
    Chrome: "chrome",
    Chromium: "chromium",
    Electron: "electron",
    Epiphany: "epiphany",
    Firefox: "firefox",
    Focus: "focus",
    Generic: "generic",
    "Google Search": "google_search",
    Googlebot: "googlebot",
    "Internet Explorer": "ie",
    "K-Meleon": "k_meleon",
    Maxthon: "maxthon",
    "Microsoft Edge": "edge",
    "MZ Browser": "mz",
    "NAVER Whale Browser": "naver",
    Opera: "opera",
    "Opera Coast": "opera_coast",
    PhantomJS: "phantomjs",
    Puffin: "puffin",
    QupZilla: "qupzilla",
    QQ: "qq",
    QQLite: "qqlite",
    Safari: "safari",
    Sailfish: "sailfish",
    "Samsung Internet for Android": "samsung_internet",
    SeaMonkey: "seamonkey",
    Sleipnir: "sleipnir",
    Swing: "swing",
    Tizen: "tizen",
    "UC Browser": "uc",
    Vivaldi: "vivaldi",
    "WebOS Browser": "webos",
    WeChat: "wechat",
    "Yandex Browser": "yandex",
    Roku: "roku"
  }, Ae = {
    amazon_silk: "Amazon Silk",
    android: "Android Browser",
    bada: "Bada",
    blackberry: "BlackBerry",
    chrome: "Chrome",
    chromium: "Chromium",
    electron: "Electron",
    epiphany: "Epiphany",
    firefox: "Firefox",
    focus: "Focus",
    generic: "Generic",
    googlebot: "Googlebot",
    google_search: "Google Search",
    ie: "Internet Explorer",
    k_meleon: "K-Meleon",
    maxthon: "Maxthon",
    edge: "Microsoft Edge",
    mz: "MZ Browser",
    naver: "NAVER Whale Browser",
    opera: "Opera",
    opera_coast: "Opera Coast",
    phantomjs: "PhantomJS",
    puffin: "Puffin",
    qupzilla: "QupZilla",
    qq: "QQ Browser",
    qqlite: "QQ Browser Lite",
    safari: "Safari",
    sailfish: "Sailfish",
    samsung_internet: "Samsung Internet for Android",
    seamonkey: "SeaMonkey",
    sleipnir: "Sleipnir",
    swing: "Swing",
    tizen: "Tizen",
    uc: "UC Browser",
    vivaldi: "Vivaldi",
    webos: "WebOS Browser",
    wechat: "WeChat",
    yandex: "Yandex Browser"
  }, z = {
    tablet: "tablet",
    mobile: "mobile",
    desktop: "desktop",
    tv: "tv"
  }, N = {
    WindowsPhone: "Windows Phone",
    Windows: "Windows",
    MacOS: "macOS",
    iOS: "iOS",
    Android: "Android",
    WebOS: "WebOS",
    BlackBerry: "BlackBerry",
    Bada: "Bada",
    Tizen: "Tizen",
    Linux: "Linux",
    ChromeOS: "Chrome OS",
    PlayStation4: "PlayStation 4",
    Roku: "Roku"
  }, S = {
    EdgeHTML: "EdgeHTML",
    Blink: "Blink",
    Trident: "Trident",
    Presto: "Presto",
    Gecko: "Gecko",
    WebKit: "WebKit"
  };
  class n {
    static getFirstMatch(e, r) {
      const s = r.match(e);
      return s && s.length > 0 && s[1] || "";
    }
    static getSecondMatch(e, r) {
      const s = r.match(e);
      return s && s.length > 1 && s[2] || "";
    }
    static matchAndReturnConst(e, r, s) {
      if (e.test(r))
        return s;
    }
    static getWindowsVersionName(e) {
      switch (e) {
        case "NT":
          return "NT";
        case "XP":
          return "XP";
        case "NT 5.0":
          return "2000";
        case "NT 5.1":
          return "XP";
        case "NT 5.2":
          return "2003";
        case "NT 6.0":
          return "Vista";
        case "NT 6.1":
          return "7";
        case "NT 6.2":
          return "8";
        case "NT 6.3":
          return "8.1";
        case "NT 10.0":
          return "10";
        default:
          return;
      }
    }
    static getMacOSVersionName(e) {
      const r = e.split(".").splice(0, 2).map((s) => parseInt(s, 10) || 0);
      if (r.push(0), r[0] === 10)
        switch (r[1]) {
          case 5:
            return "Leopard";
          case 6:
            return "Snow Leopard";
          case 7:
            return "Lion";
          case 8:
            return "Mountain Lion";
          case 9:
            return "Mavericks";
          case 10:
            return "Yosemite";
          case 11:
            return "El Capitan";
          case 12:
            return "Sierra";
          case 13:
            return "High Sierra";
          case 14:
            return "Mojave";
          case 15:
            return "Catalina";
          default:
            return;
        }
    }
    static getAndroidVersionName(e) {
      const r = e.split(".").splice(0, 2).map((s) => parseInt(s, 10) || 0);
      if (r.push(0), !(r[0] === 1 && r[1] < 5)) {
        if (r[0] === 1 && r[1] < 6)
          return "Cupcake";
        if (r[0] === 1 && r[1] >= 6)
          return "Donut";
        if (r[0] === 2 && r[1] < 2)
          return "Eclair";
        if (r[0] === 2 && r[1] === 2)
          return "Froyo";
        if (r[0] === 2 && r[1] > 2)
          return "Gingerbread";
        if (r[0] === 3)
          return "Honeycomb";
        if (r[0] === 4 && r[1] < 1)
          return "Ice Cream Sandwich";
        if (r[0] === 4 && r[1] < 4)
          return "Jelly Bean";
        if (r[0] === 4 && r[1] >= 4)
          return "KitKat";
        if (r[0] === 5)
          return "Lollipop";
        if (r[0] === 6)
          return "Marshmallow";
        if (r[0] === 7)
          return "Nougat";
        if (r[0] === 8)
          return "Oreo";
        if (r[0] === 9)
          return "Pie";
      }
    }
    static getVersionPrecision(e) {
      return e.split(".").length;
    }
    static compareVersions(e, r, s = !1) {
      const i = n.getVersionPrecision(e), o = n.getVersionPrecision(r);
      let a = Math.max(i, o), d = 0;
      const c = n.map([e, r], (l) => {
        const h = a - n.getVersionPrecision(l), g = l + new Array(h + 1).join(".0");
        return n.map(g.split("."), (u) => new Array(20 - u.length).join("0") + u).reverse();
      });
      for (s && (d = a - Math.min(i, o)), a -= 1; a >= d; ) {
        if (c[0][a] > c[1][a])
          return 1;
        if (c[0][a] === c[1][a]) {
          if (a === d)
            return 0;
          a -= 1;
        } else if (c[0][a] < c[1][a])
          return -1;
      }
    }
    static map(e, r) {
      const s = [];
      let i;
      if (Array.prototype.map)
        return Array.prototype.map.call(e, r);
      for (i = 0; i < e.length; i += 1)
        s.push(r(e[i]));
      return s;
    }
    static find(e, r) {
      let s, i;
      if (Array.prototype.find)
        return Array.prototype.find.call(e, r);
      for (s = 0, i = e.length; s < i; s += 1) {
        const o = e[s];
        if (r(o, s))
          return o;
      }
    }
    static assign(e, ...r) {
      const s = e;
      let i, o;
      if (Object.assign)
        return Object.assign(e, ...r);
      for (i = 0, o = r.length; i < o; i += 1) {
        const a = r[i];
        typeof a == "object" && a !== null && Object.keys(a).forEach((c) => {
          s[c] = a[c];
        });
      }
      return e;
    }
    static getBrowserAlias(e) {
      return ot[e];
    }
    static getBrowserTypeByAlias(e) {
      return Ae[e] || "";
    }
  }
  const p = /version\/(\d+(\.?_?\d+)+)/i, at = [
    {
      test: [/googlebot/i],
      describe(t) {
        const e = {
          name: "Googlebot"
        }, r = n.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, t) || n.getFirstMatch(p, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/opera/i],
      describe(t) {
        const e = {
          name: "Opera"
        }, r = n.getFirstMatch(p, t) || n.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/opr\/|opios/i],
      describe(t) {
        const e = {
          name: "Opera"
        }, r = n.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, t) || n.getFirstMatch(p, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/SamsungBrowser/i],
      describe(t) {
        const e = {
          name: "Samsung Internet for Android"
        }, r = n.getFirstMatch(p, t) || n.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/Whale/i],
      describe(t) {
        const e = {
          name: "NAVER Whale Browser"
        }, r = n.getFirstMatch(p, t) || n.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/MZBrowser/i],
      describe(t) {
        const e = {
          name: "MZ Browser"
        }, r = n.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, t) || n.getFirstMatch(p, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/focus/i],
      describe(t) {
        const e = {
          name: "Focus"
        }, r = n.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, t) || n.getFirstMatch(p, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/swing/i],
      describe(t) {
        const e = {
          name: "Swing"
        }, r = n.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, t) || n.getFirstMatch(p, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/coast/i],
      describe(t) {
        const e = {
          name: "Opera Coast"
        }, r = n.getFirstMatch(p, t) || n.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/opt\/\d+(?:.?_?\d+)+/i],
      describe(t) {
        const e = {
          name: "Opera Touch"
        }, r = n.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, t) || n.getFirstMatch(p, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/yabrowser/i],
      describe(t) {
        const e = {
          name: "Yandex Browser"
        }, r = n.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, t) || n.getFirstMatch(p, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/ucbrowser/i],
      describe(t) {
        const e = {
          name: "UC Browser"
        }, r = n.getFirstMatch(p, t) || n.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/Maxthon|mxios/i],
      describe(t) {
        const e = {
          name: "Maxthon"
        }, r = n.getFirstMatch(p, t) || n.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/epiphany/i],
      describe(t) {
        const e = {
          name: "Epiphany"
        }, r = n.getFirstMatch(p, t) || n.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/puffin/i],
      describe(t) {
        const e = {
          name: "Puffin"
        }, r = n.getFirstMatch(p, t) || n.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/sleipnir/i],
      describe(t) {
        const e = {
          name: "Sleipnir"
        }, r = n.getFirstMatch(p, t) || n.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/k-meleon/i],
      describe(t) {
        const e = {
          name: "K-Meleon"
        }, r = n.getFirstMatch(p, t) || n.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/micromessenger/i],
      describe(t) {
        const e = {
          name: "WeChat"
        }, r = n.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, t) || n.getFirstMatch(p, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/qqbrowser/i],
      describe(t) {
        const e = {
          name: /qqbrowserlite/i.test(t) ? "QQ Browser Lite" : "QQ Browser"
        }, r = n.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, t) || n.getFirstMatch(p, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/msie|trident/i],
      describe(t) {
        const e = {
          name: "Internet Explorer"
        }, r = n.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/\sedg\//i],
      describe(t) {
        const e = {
          name: "Microsoft Edge"
        }, r = n.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/edg([ea]|ios)/i],
      describe(t) {
        const e = {
          name: "Microsoft Edge"
        }, r = n.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/vivaldi/i],
      describe(t) {
        const e = {
          name: "Vivaldi"
        }, r = n.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/seamonkey/i],
      describe(t) {
        const e = {
          name: "SeaMonkey"
        }, r = n.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/sailfish/i],
      describe(t) {
        const e = {
          name: "Sailfish"
        }, r = n.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/silk/i],
      describe(t) {
        const e = {
          name: "Amazon Silk"
        }, r = n.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/phantom/i],
      describe(t) {
        const e = {
          name: "PhantomJS"
        }, r = n.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/slimerjs/i],
      describe(t) {
        const e = {
          name: "SlimerJS"
        }, r = n.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
      describe(t) {
        const e = {
          name: "BlackBerry"
        }, r = n.getFirstMatch(p, t) || n.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/(web|hpw)[o0]s/i],
      describe(t) {
        const e = {
          name: "WebOS Browser"
        }, r = n.getFirstMatch(p, t) || n.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/bada/i],
      describe(t) {
        const e = {
          name: "Bada"
        }, r = n.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/tizen/i],
      describe(t) {
        const e = {
          name: "Tizen"
        }, r = n.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, t) || n.getFirstMatch(p, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/qupzilla/i],
      describe(t) {
        const e = {
          name: "QupZilla"
        }, r = n.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, t) || n.getFirstMatch(p, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/firefox|iceweasel|fxios/i],
      describe(t) {
        const e = {
          name: "Firefox"
        }, r = n.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/electron/i],
      describe(t) {
        const e = {
          name: "Electron"
        }, r = n.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/MiuiBrowser/i],
      describe(t) {
        const e = {
          name: "Miui"
        }, r = n.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/chromium/i],
      describe(t) {
        const e = {
          name: "Chromium"
        }, r = n.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, t) || n.getFirstMatch(p, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/chrome|crios|crmo/i],
      describe(t) {
        const e = {
          name: "Chrome"
        }, r = n.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/GSA/i],
      describe(t) {
        const e = {
          name: "Google Search"
        }, r = n.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, t);
        return r && (e.version = r), e;
      }
    },
    {
      test(t) {
        const e = !t.test(/like android/i), r = t.test(/android/i);
        return e && r;
      },
      describe(t) {
        const e = {
          name: "Android Browser"
        }, r = n.getFirstMatch(p, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/playstation 4/i],
      describe(t) {
        const e = {
          name: "PlayStation 4"
        }, r = n.getFirstMatch(p, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/safari|applewebkit/i],
      describe(t) {
        const e = {
          name: "Safari"
        }, r = n.getFirstMatch(p, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/.*/i],
      describe(t) {
        const e = /^(.*)\/(.*) /, r = /^(.*)\/(.*)[ \t]\((.*)/, i = t.search("\\(") !== -1 ? r : e;
        return {
          name: n.getFirstMatch(i, t),
          version: n.getSecondMatch(i, t)
        };
      }
    }
  ], ct = [
    {
      test: [/Roku\/DVP/],
      describe(t) {
        const e = n.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, t);
        return {
          name: N.Roku,
          version: e
        };
      }
    },
    {
      test: [/windows phone/i],
      describe(t) {
        const e = n.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, t);
        return {
          name: N.WindowsPhone,
          version: e
        };
      }
    },
    {
      test: [/windows /i],
      describe(t) {
        const e = n.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, t), r = n.getWindowsVersionName(e);
        return {
          name: N.Windows,
          version: e,
          versionName: r
        };
      }
    },
    {
      test: [/Macintosh(.*?) FxiOS(.*?)\//],
      describe(t) {
        const e = {
          name: N.iOS
        }, r = n.getSecondMatch(/(Version\/)(\d[\d.]+)/, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/macintosh/i],
      describe(t) {
        const e = n.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, t).replace(/[_\s]/g, "."), r = n.getMacOSVersionName(e), s = {
          name: N.MacOS,
          version: e
        };
        return r && (s.versionName = r), s;
      }
    },
    {
      test: [/(ipod|iphone|ipad)/i],
      describe(t) {
        const e = n.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, t).replace(/[_\s]/g, ".");
        return {
          name: N.iOS,
          version: e
        };
      }
    },
    {
      test(t) {
        const e = !t.test(/like android/i), r = t.test(/android/i);
        return e && r;
      },
      describe(t) {
        const e = n.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, t), r = n.getAndroidVersionName(e), s = {
          name: N.Android,
          version: e
        };
        return r && (s.versionName = r), s;
      }
    },
    {
      test: [/(web|hpw)[o0]s/i],
      describe(t) {
        const e = n.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, t), r = {
          name: N.WebOS
        };
        return e && e.length && (r.version = e), r;
      }
    },
    {
      test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
      describe(t) {
        const e = n.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, t) || n.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, t) || n.getFirstMatch(/\bbb(\d+)/i, t);
        return {
          name: N.BlackBerry,
          version: e
        };
      }
    },
    {
      test: [/bada/i],
      describe(t) {
        const e = n.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, t);
        return {
          name: N.Bada,
          version: e
        };
      }
    },
    {
      test: [/tizen/i],
      describe(t) {
        const e = n.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, t);
        return {
          name: N.Tizen,
          version: e
        };
      }
    },
    {
      test: [/linux/i],
      describe() {
        return {
          name: N.Linux
        };
      }
    },
    {
      test: [/CrOS/],
      describe() {
        return {
          name: N.ChromeOS
        };
      }
    },
    {
      test: [/PlayStation 4/],
      describe(t) {
        const e = n.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, t);
        return {
          name: N.PlayStation4,
          version: e
        };
      }
    }
  ], lt = [
    {
      test: [/googlebot/i],
      describe() {
        return {
          type: "bot",
          vendor: "Google"
        };
      }
    },
    {
      test: [/huawei/i],
      describe(t) {
        const e = n.getFirstMatch(/(can-l01)/i, t) && "Nova", r = {
          type: z.mobile,
          vendor: "Huawei"
        };
        return e && (r.model = e), r;
      }
    },
    {
      test: [/nexus\s*(?:7|8|9|10).*/i],
      describe() {
        return {
          type: z.tablet,
          vendor: "Nexus"
        };
      }
    },
    {
      test: [/ipad/i],
      describe() {
        return {
          type: z.tablet,
          vendor: "Apple",
          model: "iPad"
        };
      }
    },
    {
      test: [/Macintosh(.*?) FxiOS(.*?)\//],
      describe() {
        return {
          type: z.tablet,
          vendor: "Apple",
          model: "iPad"
        };
      }
    },
    {
      test: [/kftt build/i],
      describe() {
        return {
          type: z.tablet,
          vendor: "Amazon",
          model: "Kindle Fire HD 7"
        };
      }
    },
    {
      test: [/silk/i],
      describe() {
        return {
          type: z.tablet,
          vendor: "Amazon"
        };
      }
    },
    {
      test: [/tablet(?! pc)/i],
      describe() {
        return {
          type: z.tablet
        };
      }
    },
    {
      test(t) {
        const e = t.test(/ipod|iphone/i), r = t.test(/like (ipod|iphone)/i);
        return e && !r;
      },
      describe(t) {
        const e = n.getFirstMatch(/(ipod|iphone)/i, t);
        return {
          type: z.mobile,
          vendor: "Apple",
          model: e
        };
      }
    },
    {
      test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
      describe() {
        return {
          type: z.mobile,
          vendor: "Nexus"
        };
      }
    },
    {
      test: [/[^-]mobi/i],
      describe() {
        return {
          type: z.mobile
        };
      }
    },
    {
      test(t) {
        return t.getBrowserName(!0) === "blackberry";
      },
      describe() {
        return {
          type: z.mobile,
          vendor: "BlackBerry"
        };
      }
    },
    {
      test(t) {
        return t.getBrowserName(!0) === "bada";
      },
      describe() {
        return {
          type: z.mobile
        };
      }
    },
    {
      test(t) {
        return t.getBrowserName() === "windows phone";
      },
      describe() {
        return {
          type: z.mobile,
          vendor: "Microsoft"
        };
      }
    },
    {
      test(t) {
        const e = Number(String(t.getOSVersion()).split(".")[0]);
        return t.getOSName(!0) === "android" && e >= 3;
      },
      describe() {
        return {
          type: z.tablet
        };
      }
    },
    {
      test(t) {
        return t.getOSName(!0) === "android";
      },
      describe() {
        return {
          type: z.mobile
        };
      }
    },
    {
      test(t) {
        return t.getOSName(!0) === "macos";
      },
      describe() {
        return {
          type: z.desktop,
          vendor: "Apple"
        };
      }
    },
    {
      test(t) {
        return t.getOSName(!0) === "windows";
      },
      describe() {
        return {
          type: z.desktop
        };
      }
    },
    {
      test(t) {
        return t.getOSName(!0) === "linux";
      },
      describe() {
        return {
          type: z.desktop
        };
      }
    },
    {
      test(t) {
        return t.getOSName(!0) === "playstation 4";
      },
      describe() {
        return {
          type: z.tv
        };
      }
    },
    {
      test(t) {
        return t.getOSName(!0) === "roku";
      },
      describe() {
        return {
          type: z.tv
        };
      }
    }
  ], dt = [
    {
      test(t) {
        return t.getBrowserName(!0) === "microsoft edge";
      },
      describe(t) {
        if (/\sedg\//i.test(t))
          return {
            name: S.Blink
          };
        const r = n.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, t);
        return {
          name: S.EdgeHTML,
          version: r
        };
      }
    },
    {
      test: [/trident/i],
      describe(t) {
        const e = {
          name: S.Trident
        }, r = n.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, t);
        return r && (e.version = r), e;
      }
    },
    {
      test(t) {
        return t.test(/presto/i);
      },
      describe(t) {
        const e = {
          name: S.Presto
        }, r = n.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, t);
        return r && (e.version = r), e;
      }
    },
    {
      test(t) {
        const e = t.test(/gecko/i), r = t.test(/like gecko/i);
        return e && !r;
      },
      describe(t) {
        const e = {
          name: S.Gecko
        }, r = n.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, t);
        return r && (e.version = r), e;
      }
    },
    {
      test: [/(apple)?webkit\/537\.36/i],
      describe() {
        return {
          name: S.Blink
        };
      }
    },
    {
      test: [/(apple)?webkit/i],
      describe(t) {
        const e = {
          name: S.WebKit
        }, r = n.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, t);
        return r && (e.version = r), e;
      }
    }
  ];
  class ze {
    constructor(e, r = !1) {
      if (e == null || e === "")
        throw new Error("UserAgent parameter can't be empty");
      this._ua = e, this.parsedResult = {}, r !== !0 && this.parse();
    }
    getUA() {
      return this._ua;
    }
    test(e) {
      return e.test(this._ua);
    }
    parseBrowser() {
      this.parsedResult.browser = {};
      const e = n.find(at, (r) => {
        if (typeof r.test == "function")
          return r.test(this);
        if (r.test instanceof Array)
          return r.test.some((s) => this.test(s));
        throw new Error("Browser's test function is not valid");
      });
      return e && (this.parsedResult.browser = e.describe(this.getUA())), this.parsedResult.browser;
    }
    getBrowser() {
      return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
    }
    getBrowserName(e) {
      return e ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
    }
    getBrowserVersion() {
      return this.getBrowser().version;
    }
    getOS() {
      return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
    }
    parseOS() {
      this.parsedResult.os = {};
      const e = n.find(ct, (r) => {
        if (typeof r.test == "function")
          return r.test(this);
        if (r.test instanceof Array)
          return r.test.some((s) => this.test(s));
        throw new Error("Browser's test function is not valid");
      });
      return e && (this.parsedResult.os = e.describe(this.getUA())), this.parsedResult.os;
    }
    getOSName(e) {
      const { name: r } = this.getOS();
      return e ? String(r).toLowerCase() || "" : r || "";
    }
    getOSVersion() {
      return this.getOS().version;
    }
    getPlatform() {
      return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
    }
    getPlatformType(e = !1) {
      const { type: r } = this.getPlatform();
      return e ? String(r).toLowerCase() || "" : r || "";
    }
    parsePlatform() {
      this.parsedResult.platform = {};
      const e = n.find(lt, (r) => {
        if (typeof r.test == "function")
          return r.test(this);
        if (r.test instanceof Array)
          return r.test.some((s) => this.test(s));
        throw new Error("Browser's test function is not valid");
      });
      return e && (this.parsedResult.platform = e.describe(this.getUA())), this.parsedResult.platform;
    }
    getEngine() {
      return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
    }
    getEngineName(e) {
      return e ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
    }
    parseEngine() {
      this.parsedResult.engine = {};
      const e = n.find(dt, (r) => {
        if (typeof r.test == "function")
          return r.test(this);
        if (r.test instanceof Array)
          return r.test.some((s) => this.test(s));
        throw new Error("Browser's test function is not valid");
      });
      return e && (this.parsedResult.engine = e.describe(this.getUA())), this.parsedResult.engine;
    }
    parse() {
      return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
    }
    getResult() {
      return n.assign({}, this.parsedResult);
    }
    satisfies(e) {
      const r = {};
      let s = 0;
      const i = {};
      let o = 0;
      if (Object.keys(e).forEach((d) => {
        const c = e[d];
        typeof c == "string" ? (i[d] = c, o += 1) : typeof c == "object" && (r[d] = c, s += 1);
      }), s > 0) {
        const d = Object.keys(r), c = n.find(d, (h) => this.isOS(h));
        if (c) {
          const h = this.satisfies(r[c]);
          if (h !== void 0)
            return h;
        }
        const l = n.find(
          d,
          (h) => this.isPlatform(h)
        );
        if (l) {
          const h = this.satisfies(r[l]);
          if (h !== void 0)
            return h;
        }
      }
      if (o > 0) {
        const d = Object.keys(i), c = n.find(d, (l) => this.isBrowser(l, !0));
        if (c !== void 0)
          return this.compareVersion(i[c]);
      }
    }
    isBrowser(e, r = !1) {
      const s = this.getBrowserName().toLowerCase();
      let i = e.toLowerCase();
      const o = n.getBrowserTypeByAlias(i);
      return r && o && (i = o.toLowerCase()), i === s;
    }
    compareVersion(e) {
      let r = [0], s = e, i = !1;
      const o = this.getBrowserVersion();
      if (typeof o == "string")
        return e[0] === ">" || e[0] === "<" ? (s = e.substr(1), e[1] === "=" ? (i = !0, s = e.substr(2)) : r = [], e[0] === ">" ? r.push(1) : r.push(-1)) : e[0] === "=" ? s = e.substr(1) : e[0] === "~" && (i = !0, s = e.substr(1)), r.indexOf(
          n.compareVersions(o, s, i)
        ) > -1;
    }
    isOS(e) {
      return this.getOSName(!0) === String(e).toLowerCase();
    }
    isPlatform(e) {
      return this.getPlatformType(!0) === String(e).toLowerCase();
    }
    isEngine(e) {
      return this.getEngineName(!0) === String(e).toLowerCase();
    }
    is(e, r = !1) {
      return this.isBrowser(e, r) || this.isOS(e) || this.isPlatform(e);
    }
    some(e = []) {
      return e.some((r) => this.is(r));
    }
  }
  /*!
   * Bowser - a browser detector
   * https://github.com/lancedikson/bowser
   * MIT License | (c) Dustin Diaz 2012-2015
   * MIT License | (c) Denis Demchenko 2015-2019
   */
  class gt {
    static getParser(e, r = !1) {
      if (typeof e != "string")
        throw new Error("UserAgent should be a string");
      return new ze(e, r);
    }
    static parse(e) {
      return new ze(e).getResult();
    }
    static get BROWSER_MAP() {
      return Ae;
    }
    static get ENGINE_MAP() {
      return S;
    }
    static get OS_MAP() {
      return N;
    }
    static get PLATFORMS_MAP() {
      return z;
    }
  }
  var ut = Object.defineProperty, wt = (t, e, r) => e in t ? ut(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, ht = (t, e, r) => (wt(t, typeof e != "symbol" ? e + "" : e, r), r), we = (t, e, r) => {
    if (!e.has(t))
      throw TypeError("Cannot " + r);
  }, A = (t, e, r) => (we(t, e, "read from private field"), r ? r.call(t) : e.get(t)), P = (t, e, r) => {
    if (e.has(t))
      throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(t) : e.set(t, r);
  }, $ = (t, e, r, s) => (we(t, e, "write to private field"), s ? s.call(t, r) : e.set(t, r), r), X = (t, e, r) => (we(t, e, "access private method"), r);
  const ft = [
    {
      id: "argentX",
      name: "Argent X",
      icon: "data:image/svg+xml;base64,Cjxzdmcgd2lkdGg9IjQwIiBoZWlnaHQ9IjM2IiB2aWV3Qm94PSIwIDAgNDAgMzYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0yNC43NTgyIC0zLjk3MzY0ZS0wN0gxNC42MjM4QzE0LjI4NTEgLTMuOTczNjRlLTA3IDE0LjAxMzggMC4yODExNzggMTQuMDA2NCAwLjYzMDY4M0MxMy44MDE3IDEwLjQ1NDkgOC44MjIzNCAxOS43NzkyIDAuMjUxODkzIDI2LjM4MzdDLTAuMDIwMjA0NiAyNi41OTMzIC0wLjA4MjE5NDYgMjYuOTg3MiAwLjExNjczNCAyNy4yNzA5TDYuMDQ2MjMgMzUuNzM0QzYuMjQ3OTYgMzYuMDIyIDYuNjQwOTkgMzYuMDg3IDYuOTE3NjYgMzUuODc1NEMxMi4yNzY1IDMxLjc3MjggMTYuNTg2OSAyNi44MjM2IDE5LjY5MSAyMS4zMzhDMjIuNzk1MSAyNi44MjM2IDI3LjEwNTcgMzEuNzcyOCAzMi40NjQ2IDM1Ljg3NTRDMzIuNzQxIDM2LjA4NyAzMy4xMzQxIDM2LjAyMiAzMy4zMzYxIDM1LjczNEwzOS4yNjU2IDI3LjI3MDlDMzkuNDY0MiAyNi45ODcyIDM5LjQwMjIgMjYuNTkzMyAzOS4xMzA0IDI2LjM4MzdDMzAuNTU5NyAxOS43NzkyIDI1LjU4MDQgMTAuNDU0OSAyNS4zNzU5IDAuNjMwNjgzQzI1LjM2ODUgMC4yODExNzggMjUuMDk2OSAtMy45NzM2NGUtMDcgMjQuNzU4MiAtMy45NzM2NGUtMDdaIiBmaWxsPSIjRkY4NzVCIi8+Cjwvc3ZnPgo=",
      downloads: {
        chrome: "https://chrome.google.com/webstore/detail/argent-x-starknet-wallet/dlcobpjiigpikoobohmabehhmhfoodbb",
        firefox: "https://addons.mozilla.org/en-US/firefox/addon/argent-x"
      }
    },
    {
      id: "braavos",
      name: "Braavos",
      icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8cGF0aAogICAgICAgIGQ9Ik02Mi43MDUgMTMuOTExNkM2Mi44MzU5IDE0LjEzMzMgNjIuNjYyMSAxNC40MDcgNjIuNDAzOSAxNC40MDdDNTcuMTgwNyAxNC40MDcgNTIuOTM0OCAxOC41NDI3IDUyLjgzNTEgMjMuNjgxN0M1MS4wNDY1IDIzLjM0NzcgNDkuMTkzMyAyMy4zMjI2IDQ3LjM2MjYgMjMuNjMxMUM0Ny4yMzYxIDE4LjUxNTYgNDMuMDAwOSAxNC40MDcgMzcuNzk0OCAxNC40MDdDMzcuNTM2NSAxNC40MDcgMzcuMzYyNSAxNC4xMzMxIDM3LjQ5MzUgMTMuOTExMkM0MC4wMjE3IDkuNjI4MDkgNDQuNzIwNCA2Ljc1IDUwLjA5OTEgNi43NUM1NS40NzgxIDYuNzUgNjAuMTc2OSA5LjYyODI2IDYyLjcwNSAxMy45MTE2WiIKICAgICAgICBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfMzcyXzQwMjU5KSIgLz4KICAgIDxwYXRoCiAgICAgICAgZD0iTTc4Ljc2MDYgNDUuODcxOEM4MC4yNzI1IDQ2LjMyOTcgODEuNzAyNSA0NS4wMDU1IDgxLjE3MTQgNDMuNTIyMkM3Ni40MTM3IDMwLjIzMzQgNjEuMzkxMSAyNC44MDM5IDUwLjAyNzcgMjQuODAzOUMzOC42NDQyIDI0LjgwMzkgMjMuMjg2OCAzMC40MDcgMTguODc1NCA0My41OTEyQzE4LjM4MjQgNDUuMDY0NSAxOS44MDgzIDQ2LjM0NDYgMjEuMjk3OCA0NS44ODgxTDQ4Ljg3MiAzNy40MzgxQzQ5LjUzMzEgMzcuMjM1NSA1MC4yMzk5IDM3LjIzNDQgNTAuOTAxNyAzNy40MzQ4TDc4Ljc2MDYgNDUuODcxOFoiCiAgICAgICAgZmlsbD0idXJsKCNwYWludDFfbGluZWFyXzM3Ml80MDI1OSkiIC8+CiAgICA8cGF0aAogICAgICAgIGQ9Ik0xOC44MTMyIDQ4LjE3MDdMNDguODkzNSAzOS4wNDcyQzQ5LjU1MDYgMzguODQ3OCA1MC4yNTI0IDM4Ljg0NzMgNTAuOTA5OCAzOS4wNDU2TDgxLjE3ODEgNDguMTc1MkM4My42OTEyIDQ4LjkzMzIgODUuNDExIDUxLjI0ODMgODUuNDExIDUzLjg3MzVWODEuMjIzM0M4NS4yOTQ0IDg3Ljg5OTEgNzkuMjk3NyA5My4yNSA3Mi42MjQ1IDkzLjI1SDYxLjU0MDZDNjAuNDQ0OSA5My4yNSA1OS41NTc3IDkyLjM2MzcgNTkuNTU3NyA5MS4yNjhWODEuNjc4OUM1OS41NTc3IDc3LjkwMzEgNjEuNzkyMSA3NC40ODU1IDY1LjI0OTggNzIuOTcyOUM2OS44ODQ5IDcwLjk0NTQgNzUuMzY4MSA2OC4yMDI4IDc2LjM5OTQgNjIuNjk5MkM3Ni43MzIzIDYwLjkyMjkgNzUuNTc0MSA1OS4yMDk0IDczLjgwMjQgNTguODU3M0M2OS4zMjI2IDU3Ljk2NjcgNjQuMzU2MiA1OC4zMTA3IDYwLjE1NjQgNjAuMTg5M0M1NS4zODg3IDYyLjMyMTkgNTQuMTQxNSA2NS44Njk0IDUzLjY3OTcgNzAuNjMzN0w1My4xMjAxIDc1Ljc2NjJDNTIuOTQ5MSA3Ny4zMzQ5IDUxLjQ3ODUgNzguNTM2NiA0OS45MDE0IDc4LjUzNjZDNDguMjY5OSA3OC41MzY2IDQ3LjA0NjUgNzcuMjk0IDQ2Ljg2OTYgNzUuNjcxMkw0Ni4zMjA0IDcwLjYzMzdDNDUuOTI0OSA2Ni41NTI5IDQ1LjIwNzkgNjIuNTg4NyA0MC45ODk1IDYwLjcwMThDMzYuMTc3NiA1OC41NDk0IDMxLjM0MTkgNTcuODM0NyAyNi4xOTc2IDU4Ljg1NzNDMjQuNDI2IDU5LjIwOTQgMjMuMjY3OCA2MC45MjI5IDIzLjYwMDcgNjIuNjk5MkMyNC42NDEgNjguMjUwNyAzMC4wODEyIDcwLjkzMDUgMzQuNzUwMyA3Mi45NzI5QzM4LjIwOCA3NC40ODU1IDQwLjQ0MjQgNzcuOTAzMSA0MC40NDI0IDgxLjY3ODlWOTEuMjY2M0M0MC40NDI0IDkyLjM2MiAzOS41NTU1IDkzLjI1IDM4LjQ1OTkgOTMuMjVIMjcuMzc1NkMyMC43MDI0IDkzLjI1IDE0LjcwNTcgODcuODk5MSAxNC41ODkxIDgxLjIyMzNWNTMuODY2M0MxNC41ODkxIDUxLjI0NDYgMTYuMzA0NSA0OC45MzE2IDE4LjgxMzIgNDguMTcwN1oiCiAgICAgICAgZmlsbD0idXJsKCNwYWludDJfbGluZWFyXzM3Ml80MDI1OSkiIC8+CiAgICA8ZGVmcz4KICAgICAgICA8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfMzcyXzQwMjU5IiB4MT0iNDkuMzA1NyIgeTE9IjIuMDc5IiB4Mj0iODAuMzYyNyIgeTI9IjkzLjY1OTciCiAgICAgICAgICAgIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KICAgICAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIgLz4KICAgICAgICAgICAgPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRkY5NjAwIiAvPgogICAgICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgICAgICAgPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDFfbGluZWFyXzM3Ml80MDI1OSIgeDE9IjQ5LjMwNTciIHkxPSIyLjA3OSIgeDI9IjgwLjM2MjciIHkyPSI5My42NTk3IgogICAgICAgICAgICBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CiAgICAgICAgICAgIDxzdG9wIHN0b3AtY29sb3I9IiNGNUQ0NUUiIC8+CiAgICAgICAgICAgIDxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI0ZGOTYwMCIgLz4KICAgICAgICA8L2xpbmVhckdyYWRpZW50PgogICAgICAgIDxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQyX2xpbmVhcl8zNzJfNDAyNTkiIHgxPSI0OS4zMDU3IiB5MT0iMi4wNzkiIHgyPSI4MC4zNjI3IiB5Mj0iOTMuNjU5NyIKICAgICAgICAgICAgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgogICAgICAgICAgICA8c3RvcCBzdG9wLWNvbG9yPSIjRjVENDVFIiAvPgogICAgICAgICAgICA8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiIC8+CiAgICAgICAgPC9saW5lYXJHcmFkaWVudD4KICAgIDwvZGVmcz4KPC9zdmc+",
      downloads: {
        chrome: "https://chrome.google.com/webstore/detail/braavos-wallet/jnlgamecbpmbajjfhmmmlhejkemejdma",
        firefox: "https://addons.mozilla.org/en-US/firefox/addon/braavos-wallet",
        edge: "https://microsoftedge.microsoft.com/addons/detail/braavos-wallet/hkkpjehhcnhgefhbdcgfkeegglpjchdc"
      }
    }
  ], bt = () => `${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`, ye = (t) => {
    for (let e = t.length - 1; e > 0; e--) {
      const r = Math.floor(Math.random() * (e + 1));
      [t[e], t[r]] = [t[r], t[e]];
    }
    return t;
  };
  function se(...t) {
    return (e) => t.reduce((r, s) => r.then(s), Promise.resolve(e));
  }
  var _, C, U, ue, De, Q, q;
  class mt {
    constructor(e) {
      P(this, ue), P(this, Q), P(this, _, !1), P(this, C, void 0), P(this, U, void 0), ht(this, "value"), $(this, U, e), X(this, Q, q).call(this);
    }
    set(e) {
      return !A(this, _) && !X(this, Q, q).call(this) ? !1 : (this.delete(), this.value = e, e && ($(this, C, `${A(this, U)}-${bt()}`), localStorage.setItem(A(this, C), e)), !0);
    }
    get() {
      return X(this, ue, De).call(this), this.value;
    }
    delete() {
      return !A(this, _) && !X(this, Q, q).call(this) ? !1 : (this.value = null, A(this, C) && localStorage.removeItem(A(this, C)), !0);
    }
  }
  _ = /* @__PURE__ */ new WeakMap(), C = /* @__PURE__ */ new WeakMap(), U = /* @__PURE__ */ new WeakMap(), ue = /* @__PURE__ */ new WeakSet(), De = function() {
    this.value && this.set(this.value);
  }, Q = /* @__PURE__ */ new WeakSet(), q = function() {
    try {
      !A(this, _) && typeof window < "u" && ($(this, C, Object.keys(localStorage).find(
        (t) => t.startsWith(A(this, U))
      )), $(this, _, !0), A(this, C) && this.set(localStorage.getItem(A(this, C))));
    } catch (t) {
      console.warn(t);
    }
    return A(this, _);
  };
  function ne(t, e) {
    var r, s;
    if ((r = e == null ? void 0 : e.include) != null && r.length) {
      const i = new Set(e.include);
      return t.filter((o) => i.has(o.id));
    }
    if ((s = e == null ? void 0 : e.exclude) != null && s.length) {
      const i = new Set(e.exclude);
      return t.filter((o) => !i.has(o.id));
    }
    return t;
  }
  const ke = async (t) => {
    const e = await Promise.all(
      t.map((r) => r.isPreauthorized().catch(() => !1))
    );
    return t.filter((r, s) => e[s]);
  }, pt = (t) => {
    try {
      return t && [
        "request",
        "isConnected",
        "provider",
        "enable",
        "isPreauthorized",
        "on",
        "off",
        "version",
        "id",
        "name",
        "icon"
      ].every((e) => e in t);
    } catch {
    }
    return !1;
  };
  function ie(t, e) {
    return Object.values(
      Object.getOwnPropertyNames(t).reduce((r, s) => {
        if (s.startsWith("starknet")) {
          const i = t[s];
          e(i) && !r[i.id] && (r[i.id] = i);
        }
        return r;
      }, {})
    );
  }
  const oe = (t, e) => {
    if (e && Array.isArray(e)) {
      t.sort((s, i) => e.indexOf(s.id) - e.indexOf(i.id));
      const r = t.length - e.length;
      return [
        ...t.slice(r),
        ...ye(t.slice(0, r))
      ];
    } else
      return ye(t);
  }, Mt = typeof window < "u" ? window : {}, vt = {
    windowObject: Mt,
    isWalletObject: pt,
    storageFactoryImplementation: (t) => new mt(t)
  };
  function jt(t = {}) {
    const { storageFactoryImplementation: e, windowObject: r, isWalletObject: s } = {
      ...vt,
      ...t
    }, i = e("gsw-last");
    return {
      getAvailableWallets: async (o = {}) => {
        const a = ie(
          r,
          s
        );
        return se(
          (d) => ne(d, o),
          (d) => oe(d, o.sort)
        )(a);
      },
      getPreAuthorizedWallets: async (o = {}) => {
        const a = ie(
          r,
          s
        );
        return se(
          (d) => ke(d),
          (d) => ne(d, o),
          (d) => oe(d, o.sort)
        )(a);
      },
      getDiscoveryWallets: async (o = {}) => se(
        (a) => ne(a, o),
        (a) => oe(a, o.sort)
      )(ft),
      getLastConnectedWallet: async () => {
        const o = i.get(), a = ie(r, s).find(
          (c) => c.id === o
        ), [d] = await ke(
          a ? [a] : []
        );
        return d || (i.delete(), null);
      },
      enable: async (o, a) => {
        if (await o.enable(a), !o.isConnected)
          throw new Error("Failed to connect to wallet");
        return i.set(o.id), o;
      },
      disconnect: async ({ clearLastWallet: o } = {}) => {
        o && i.delete();
      }
    };
  }
  const T = jt(), ae = typeof window < "u" ? window : null;
  function zt() {
    var e;
    switch ((e = gt.getParser(ae == null ? void 0 : ae.navigator.userAgent).getBrowserName()) == null ? void 0 : e.toLowerCase()) {
      case "firefox":
        return "firefox";
      case "microsoft edge":
        return "edge";
      case "android browser":
      case "chrome":
      case "chromium":
      case "electron":
      case "opera":
      case "vivaldi":
        return "chrome";
      default:
        return null;
    }
  }
  const ce = async (t) => t ? T.enable(t, { starknetVersion: "v4" }).catch(() => null) : null, yt = async ({
    modalMode: t = "canAsk",
    storeVersion: e = zt(),
    modalTheme: r,
    ...s
  } = {}) => {
    var l, h;
    const i = await T.getPreAuthorizedWallets({
      ...s
    }), o = await T.getLastConnectedWallet();
    if (t === "neverAsk") {
      const g = (l = i.find((u) => u.id === (o == null ? void 0 : o.id))) != null ? l : i[0];
      return ce(g);
    }
    const a = await T.getAvailableWallets(s);
    if (t === "canAsk" && o) {
      const g = ((h = i.find((u) => u.id === (o == null ? void 0 : o.id))) != null ? h : a.length === 1) ? a[0] : void 0;
      if (g)
        return ce(g);
    }
    const c = (await T.getDiscoveryWallets(s)).filter((g) => Boolean(g.downloads[e])).map(({ downloads: g, ...u }) => ({
      ...u,
      download: g[e]
    }));
    return it({
      lastWallet: o,
      preAuthorizedWallets: i,
      installedWallets: a,
      discoveryWallets: c,
      enable: ce,
      modalOptions: {
        theme: r
      }
    });
  };

  var getStarkNetAccount = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var res;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              res = {
                address: '',
                balance: 0,
                shortAddress: ''
              };
              _context.next = 3;
              return getStarknetAccount();

            case 3:
              _context.next = 5;
              return _context.sent.address;

            case 5:
              res.address = _context.sent;
              return _context.abrupt("return", res);

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function getStarkNetAccount() {
      return _ref.apply(this, arguments);
    };
  }();
  var signWithStarkNet = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(signContent, address) {
      var _yield$getStarknetAcc;

      var provider, message, typedMessage, result, messageText, contractProvider, contact, _yield$contact$call, _yield$contact$call2, pubKey;

      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return getStarknetAccount();

            case 2:
              _context2.t1 = _yield$getStarknetAcc = _context2.sent;
              _context2.t0 = _context2.t1 === null;

              if (_context2.t0) {
                _context2.next = 6;
                break;
              }

              _context2.t0 = _yield$getStarknetAcc === void 0;

            case 6:
              if (!_context2.t0) {
                _context2.next = 10;
                break;
              }

              _context2.t2 = void 0;
              _context2.next = 11;
              break;

            case 10:
              _context2.t2 = _yield$getStarknetAcc.provider;

            case 11:
              _context2.next = 13;
              return _context2.t2;

            case 13:
              provider = _context2.sent;
              message = starknet.hash.starknetKeccak(signContent).toString('hex').substring(0, 31);
              typedMessage = {
                domain: {
                  name: 'Example DApp',
                  chainId: 'SN_GOERLI',
                  version: '0.0.1'
                },
                types: {
                  StarkNetDomain: [{
                    name: 'name',
                    type: 'felt'
                  }, {
                    name: 'chainId',
                    type: 'felt'
                  }, {
                    name: 'version',
                    type: 'felt'
                  }],
                  Message: [{
                    name: 'message',
                    type: 'felt'
                  }]
                },
                primaryType: 'Message',
                message: {
                  message: message
                }
              };
              _context2.next = 18;
              return provider.account.signMessage(typedMessage);

            case 18:
              result = _context2.sent;
              messageText = starknet.typedData.getMessageHash(typedMessage, address); // get argent public key

              contractProvider = new starknet.Provider({
                sequencer: {
                  network: 'goerli-alpha' // or 'goerli-alpha'

                }
              });
              contact = new starknet.Contract(testNet, address, contractProvider);
              _context2.next = 24;
              return contact.call('getSigner');

            case 24:
              _yield$contact$call = _context2.sent;
              _yield$contact$call2 = _slicedToArray(_yield$contact$call, 1);
              pubKey = _yield$contact$call2[0];
              return _context2.abrupt("return", {
                publicKey: starknet.number.toHex(pubKey),
                sign: starknet.number.toFelt(messageText) + ',' + result.join(',')
              });

            case 28:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function signWithStarkNet(_x, _x2) {
      return _ref2.apply(this, arguments);
    };
  }();

  var getStarknetAccount = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
      var starknet, _yield$starknet$enabl, _yield$starknet$enabl2, add;

      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return yt();

            case 2:
              starknet = _context3.sent;

              if (starknet) {
                _context3.next = 5;
                break;
              }

              return _context3.abrupt("return");

            case 5:
              _context3.next = 7;
              return starknet.enable();

            case 7:
              _yield$starknet$enabl = _context3.sent;
              _yield$starknet$enabl2 = _slicedToArray(_yield$starknet$enabl, 1);
              add = _yield$starknet$enabl2[0];
              return _context3.abrupt("return", {
                address: add,
                provider: starknet
              });

            case 11:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    return function getStarknetAccount() {
      return _ref3.apply(this, arguments);
    };
  }();

  var getEthAccount = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var res, reqParams, requestPermissionsRes, address, strLength, balance, realMoney;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              res = {
                address: '',
                balance: 0,
                shortAddress: ''
              };
              reqParams = {
                method: 'wallet_requestPermissions',
                params: [{
                  eth_accounts: {}
                }]
              }; // @ts-ignore

              _context.next = 4;
              return window.ethereum.request(reqParams)["catch"](function (e) {
                console.log(e, 'err');
              });

            case 4:
              requestPermissionsRes = _context.sent;

              if (requestPermissionsRes) {
                _context.next = 7;
                break;
              }

              return _context.abrupt("return", res);

            case 7:
              _context.prev = 7;
              _context.next = 10;
              return window.ethereum.request({
                method: 'eth_accounts'
              });

            case 10:
              address = _context.sent;

              if (!(address && address.length > 0)) {
                _context.next = 19;
                break;
              }

              res.address = address[0];
              strLength = address[0].length;
              res.shortAddress = address[0].substring(0, 5) + '...' + address[0].substring(strLength - 4, strLength); //@ts-ignore

              _context.next = 17;
              return window.ethereum.request({
                method: 'eth_getBalance',
                params: [address[0], 'latest']
              });

            case 17:
              balance = _context.sent;

              if (balance) {
                realMoney = balance.toString(10);
                res.balance = realMoney / 1000000000000000000;
              }

            case 19:
              _context.next = 24;
              break;

            case 21:
              _context.prev = 21;
              _context.t0 = _context["catch"](7);
              console.log(_context.t0);

            case 24:
              return _context.abrupt("return", res);

            case 25:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[7, 21]]);
    }));

    return function getEthAccount() {
      return _ref.apply(this, arguments);
    };
  }();
  var signWithEth = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(signContent, didValue) {
      var sign;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return window.ethereum.request({
                method: 'personal_sign',
                params: [signContent, didValue, 'web3mq']
              });

            case 2:
              sign = _context2.sent;
              return _context2.abrupt("return", {
                sign: sign
              });

            case 4:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function signWithEth(_x, _x2) {
      return _ref2.apply(this, arguments);
    };
  }();

  var WalletNameMap = {
    eth: 'Ethereum',
    starknet: 'Argent X',
    qrcode: 'Qrcode'
  };
  var SendMsgLoadingMap = {
    success: 'success',
    error: 'error',
    loading: 'loading'
  };

  var PbTypeConnectReqCommand = 2;
  var PbTypeConnectRespCommand = 3;
  var PbTypeUserTempConnectReqCommand = 5;
  var PbTypeUserTempConnectResp = 6; // contact

  var PbTypeMessage = 16;
  var PbTypeMessageStatusResp = 21;
  var PbTypeMessageChangeStatus = 22; // notification

  var PbTypeNotificationListResp = 20; // group

  var PbTypePingCommand = 128;
  var PbTypePongCommand = 129; // qrCode

  var PbTypeWeb3MQBridgeConnectCommand = 100;
  var PbTypeWeb3MQBridgeConnectResp = 101;

  var domainUrlList = {
    dev: ['https://dev-us-west-2.web3mq.com', 'https://dev-ap-jp-1.web3mq.com', 'https://dev-ap-singapore-1.web3mq.com'],
    test: ['https://testnet-us-west-1-1.web3mq.com', 'https://testnet-us-west-1-2.web3mq.com', 'https://testnet-ap-jp-1.web3mq.com', 'https://testnet-ap-jp-2.web3mq.com', 'https://testnet-ap-singapore-1.web3mq.com', 'https://testnet-ap-singapore-2.web3mq.com']
  };

  /**
   * @API Channel
   */

  var createRoomRequest = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(payload) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return request.post('/api/groups/', payload);

            case 2:
              return _context2.abrupt("return", _context2.sent);

            case 3:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function createRoomRequest(_x2) {
      return _ref2.apply(this, arguments);
    };
  }(); // export const getGroupListRequest = async (payload: createRoomParams) => {
  //   return await request.get('/api/groups/', {
  //     params: payload,
  //   });
  // };

  var getRoomListRequest = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(payload) {
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return request.get('/api/chats/', {
                params: payload
              });

            case 2:
              return _context3.abrupt("return", _context3.sent);

            case 3:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    return function getRoomListRequest(_x3) {
      return _ref3.apply(this, arguments);
    };
  }();
  var updateRoomListRequest = /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(payload) {
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return request.post('/api/chats/', payload);

            case 2:
              return _context4.abrupt("return", _context4.sent);

            case 3:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    return function updateRoomListRequest(_x4) {
      return _ref4.apply(this, arguments);
    };
  }();
  var getGroupMemberListRequest = /*#__PURE__*/function () {
    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(payload) {
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return request.get('/api/group_members/', {
                params: payload
              });

            case 2:
              return _context5.abrupt("return", _context5.sent);

            case 3:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));

    return function getGroupMemberListRequest(_x5) {
      return _ref5.apply(this, arguments);
    };
  }();
  var inviteGroupMemberRequest = /*#__PURE__*/function () {
    var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(payload) {
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return request.post('/api/group_invitation/', payload);

            case 2:
              return _context6.abrupt("return", _context6.sent);

            case 3:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }));

    return function inviteGroupMemberRequest(_x6) {
      return _ref6.apply(this, arguments);
    };
  }();
  var joinGroupRequest = /*#__PURE__*/function () {
    var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(payload) {
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return request.post('/api/user_join_group/', payload);

            case 2:
              return _context7.abrupt("return", _context7.sent);

            case 3:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    }));

    return function joinGroupRequest(_x7) {
      return _ref7.apply(this, arguments);
    };
  }();
  var updateGroupPermissionsRequest = /*#__PURE__*/function () {
    var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(payload) {
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              _context8.next = 2;
              return request.post('/api/update_group_permissions/', payload);

            case 2:
              return _context8.abrupt("return", _context8.sent);

            case 3:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8);
    }));

    return function updateGroupPermissionsRequest(_x8) {
      return _ref8.apply(this, arguments);
    };
  }();
  var getGroupPermissionsRequest = /*#__PURE__*/function () {
    var _ref9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(payload) {
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              _context9.next = 2;
              return request.get('/api/get_group_permissions/', {
                params: payload
              });

            case 2:
              return _context9.abrupt("return", _context9.sent);

            case 3:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9);
    }));

    return function getGroupPermissionsRequest(_x9) {
      return _ref9.apply(this, arguments);
    };
  }();
  /**
   * @API Message
   */

  var getMessageListRequest = /*#__PURE__*/function () {
    var _ref10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(payload) {
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              _context10.next = 2;
              return request.get('/api/messages/history/', {
                params: payload
              });

            case 2:
              return _context10.abrupt("return", _context10.sent);

            case 3:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10);
    }));

    return function getMessageListRequest(_x10) {
      return _ref10.apply(this, arguments);
    };
  }();
  var changeMessageStatusRequest = /*#__PURE__*/function () {
    var _ref11 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(payload) {
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              _context11.next = 2;
              return request.post('/api/messages/status/', payload);

            case 2:
              return _context11.abrupt("return", _context11.sent);

            case 3:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11);
    }));

    return function changeMessageStatusRequest(_x11) {
      return _ref11.apply(this, arguments);
    };
  }();
  var syncNewMessagesRequest = /*#__PURE__*/function () {
    var _ref12 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(payload) {
      return _regeneratorRuntime().wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              _context12.next = 2;
              return request.post('/api/get_new_messages/', payload);

            case 2:
              return _context12.abrupt("return", _context12.sent);

            case 3:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12);
    }));

    return function syncNewMessagesRequest(_x12) {
      return _ref12.apply(this, arguments);
    };
  }();
  /**
   * @API User
   */

  var searchUsersRequest = /*#__PURE__*/function () {
    var _ref13 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(payload) {
      return _regeneratorRuntime().wrap(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              _context13.next = 2;
              return request.get('/api/users/search/', {
                params: payload
              });

            case 2:
              return _context13.abrupt("return", _context13.sent);

            case 3:
            case "end":
              return _context13.stop();
          }
        }
      }, _callee13);
    }));

    return function searchUsersRequest(_x13) {
      return _ref13.apply(this, arguments);
    };
  }();
  var getMyProfileRequest = /*#__PURE__*/function () {
    var _ref14 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(payload) {
      return _regeneratorRuntime().wrap(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              _context14.next = 2;
              return request.get('/api/my_profile/', {
                params: payload
              });

            case 2:
              return _context14.abrupt("return", _context14.sent);

            case 3:
            case "end":
              return _context14.stop();
          }
        }
      }, _callee14);
    }));

    return function getMyProfileRequest(_x14) {
      return _ref14.apply(this, arguments);
    };
  }();
  var updateMyProfileRequest = /*#__PURE__*/function () {
    var _ref15 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(payload) {
      return _regeneratorRuntime().wrap(function _callee15$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              _context15.next = 2;
              return request.post('/api/my_profile/', payload);

            case 2:
              return _context15.abrupt("return", _context15.sent);

            case 3:
            case "end":
              return _context15.stop();
          }
        }
      }, _callee15);
    }));

    return function updateMyProfileRequest(_x15) {
      return _ref15.apply(this, arguments);
    };
  }();
  var getUserInfoRequest = /*#__PURE__*/function () {
    var _ref16 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(payload) {
      return _regeneratorRuntime().wrap(function _callee16$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              _context16.next = 2;
              return request.post('/api/get_user_info/', payload);

            case 2:
              return _context16.abrupt("return", _context16.sent);

            case 3:
            case "end":
              return _context16.stop();
          }
        }
      }, _callee16);
    }));

    return function getUserInfoRequest(_x16) {
      return _ref16.apply(this, arguments);
    };
  }();
  var userRegisterRequest = /*#__PURE__*/function () {
    var _ref17 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(payload) {
      return _regeneratorRuntime().wrap(function _callee17$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              _context17.next = 2;
              return request.post('/api/user_register_v2/', payload);

            case 2:
              return _context17.abrupt("return", _context17.sent);

            case 3:
            case "end":
              return _context17.stop();
          }
        }
      }, _callee17);
    }));

    return function userRegisterRequest(_x17) {
      return _ref17.apply(this, arguments);
    };
  }();
  var resetPasswordRequest = /*#__PURE__*/function () {
    var _ref18 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(payload) {
      return _regeneratorRuntime().wrap(function _callee18$(_context18) {
        while (1) {
          switch (_context18.prev = _context18.next) {
            case 0:
              _context18.next = 2;
              return request.post('/api/user_reset_password_v2/', payload);

            case 2:
              return _context18.abrupt("return", _context18.sent);

            case 3:
            case "end":
              return _context18.stop();
          }
        }
      }, _callee18);
    }));

    return function resetPasswordRequest(_x18) {
      return _ref18.apply(this, arguments);
    };
  }();
  var userLoginRequest = /*#__PURE__*/function () {
    var _ref19 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(payload) {
      return _regeneratorRuntime().wrap(function _callee19$(_context19) {
        while (1) {
          switch (_context19.prev = _context19.next) {
            case 0:
              _context19.next = 2;
              return request.post('/api/user_login_v2/', payload);

            case 2:
              return _context19.abrupt("return", _context19.sent);

            case 3:
            case "end":
              return _context19.stop();
          }
        }
      }, _callee19);
    }));

    return function userLoginRequest(_x19) {
      return _ref19.apply(this, arguments);
    };
  }();
  var getUserBindDidsRequest = /*#__PURE__*/function () {
    var _ref20 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(payload) {
      return _regeneratorRuntime().wrap(function _callee20$(_context20) {
        while (1) {
          switch (_context20.prev = _context20.next) {
            case 0:
              _context20.next = 2;
              return request.post('/api/get_user_binddids/', payload);

            case 2:
              return _context20.abrupt("return", _context20.sent);

            case 3:
            case "end":
              return _context20.stop();
          }
        }
      }, _callee20);
    }));

    return function getUserBindDidsRequest(_x20) {
      return _ref20.apply(this, arguments);
    };
  }();
  var userBindDidRequest = /*#__PURE__*/function () {
    var _ref21 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(payload) {
      return _regeneratorRuntime().wrap(function _callee21$(_context21) {
        while (1) {
          switch (_context21.prev = _context21.next) {
            case 0:
              _context21.next = 2;
              return request.post('/api/user_binddid/', payload);

            case 2:
              return _context21.abrupt("return", _context21.sent);

            case 3:
            case "end":
              return _context21.stop();
          }
        }
      }, _callee21);
    }));

    return function userBindDidRequest(_x21) {
      return _ref21.apply(this, arguments);
    };
  }();
  var followOperationRequest = /*#__PURE__*/function () {
    var _ref22 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(payload) {
      return _regeneratorRuntime().wrap(function _callee22$(_context22) {
        while (1) {
          switch (_context22.prev = _context22.next) {
            case 0:
              _context22.next = 2;
              return request.post('/api/following/', payload);

            case 2:
              return _context22.abrupt("return", _context22.sent);

            case 3:
            case "end":
              return _context22.stop();
          }
        }
      }, _callee22);
    }));

    return function followOperationRequest(_x22) {
      return _ref22.apply(this, arguments);
    };
  }();
  var getFollowerListRequest = /*#__PURE__*/function () {
    var _ref23 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23(payload) {
      return _regeneratorRuntime().wrap(function _callee23$(_context23) {
        while (1) {
          switch (_context23.prev = _context23.next) {
            case 0:
              _context23.next = 2;
              return request.get('/api/user_followers/', {
                params: payload
              });

            case 2:
              return _context23.abrupt("return", _context23.sent);

            case 3:
            case "end":
              return _context23.stop();
          }
        }
      }, _callee23);
    }));

    return function getFollowerListRequest(_x23) {
      return _ref23.apply(this, arguments);
    };
  }();
  var getFollowingListRequest = /*#__PURE__*/function () {
    var _ref24 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24(payload) {
      return _regeneratorRuntime().wrap(function _callee24$(_context24) {
        while (1) {
          switch (_context24.prev = _context24.next) {
            case 0:
              _context24.next = 2;
              return request.get('/api/user_following/', {
                params: payload
              });

            case 2:
              return _context24.abrupt("return", _context24.sent);

            case 3:
            case "end":
              return _context24.stop();
          }
        }
      }, _callee24);
    }));

    return function getFollowingListRequest(_x24) {
      return _ref24.apply(this, arguments);
    };
  }();
  var getUserPublicProfileRequest = /*#__PURE__*/function () {
    var _ref25 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25(payload) {
      return _regeneratorRuntime().wrap(function _callee25$(_context25) {
        while (1) {
          switch (_context25.prev = _context25.next) {
            case 0:
              _context25.next = 2;
              return request.get('/api/get_user_public_profile/', {
                params: payload
              });

            case 2:
              return _context25.abrupt("return", _context25.sent);

            case 3:
            case "end":
              return _context25.stop();
          }
        }
      }, _callee25);
    }));

    return function getUserPublicProfileRequest(_x25) {
      return _ref25.apply(this, arguments);
    };
  }();
  var getPublicFollowerListRequest = /*#__PURE__*/function () {
    var _ref26 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26(payload) {
      return _regeneratorRuntime().wrap(function _callee26$(_context26) {
        while (1) {
          switch (_context26.prev = _context26.next) {
            case 0:
              _context26.next = 2;
              return request.get('/api/user_public_followers/', {
                params: payload
              });

            case 2:
              return _context26.abrupt("return", _context26.sent);

            case 3:
            case "end":
              return _context26.stop();
          }
        }
      }, _callee26);
    }));

    return function getPublicFollowerListRequest(_x26) {
      return _ref26.apply(this, arguments);
    };
  }();
  var getPublicFollowingListRequest = /*#__PURE__*/function () {
    var _ref27 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee27(payload) {
      return _regeneratorRuntime().wrap(function _callee27$(_context27) {
        while (1) {
          switch (_context27.prev = _context27.next) {
            case 0:
              _context27.next = 2;
              return request.get('/api/user_public_following/', {
                params: payload
              });

            case 2:
              return _context27.abrupt("return", _context27.sent);

            case 3:
            case "end":
              return _context27.stop();
          }
        }
      }, _callee27);
    }));

    return function getPublicFollowingListRequest(_x27) {
      return _ref27.apply(this, arguments);
    };
  }();
  var publishNotificationToFollowersRequest = /*#__PURE__*/function () {
    var _ref28 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee28(payload) {
      return _regeneratorRuntime().wrap(function _callee28$(_context28) {
        while (1) {
          switch (_context28.prev = _context28.next) {
            case 0:
              _context28.next = 2;
              return request.post('/api/publish_notification_to_followers/', payload);

            case 2:
              return _context28.abrupt("return", _context28.sent);

            case 3:
            case "end":
              return _context28.stop();
          }
        }
      }, _callee28);
    }));

    return function publishNotificationToFollowersRequest(_x28) {
      return _ref28.apply(this, arguments);
    };
  }();
  var getTargetUserPermissionsRequest = /*#__PURE__*/function () {
    var _ref29 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee29(payload) {
      return _regeneratorRuntime().wrap(function _callee29$(_context29) {
        while (1) {
          switch (_context29.prev = _context29.next) {
            case 0:
              _context29.next = 2;
              return request.post('/api/get_target_user_permissions/', payload);

            case 2:
              return _context29.abrupt("return", _context29.sent);

            case 3:
            case "end":
              return _context29.stop();
          }
        }
      }, _callee29);
    }));

    return function getTargetUserPermissionsRequest(_x29) {
      return _ref29.apply(this, arguments);
    };
  }();
  var getUserPermissionsRequest = /*#__PURE__*/function () {
    var _ref30 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee30(payload) {
      return _regeneratorRuntime().wrap(function _callee30$(_context30) {
        while (1) {
          switch (_context30.prev = _context30.next) {
            case 0:
              _context30.next = 2;
              return request.get('/api/get_user_permissions/', {
                params: payload
              });

            case 2:
              return _context30.abrupt("return", _context30.sent);

            case 3:
            case "end":
              return _context30.stop();
          }
        }
      }, _callee30);
    }));

    return function getUserPermissionsRequest(_x30) {
      return _ref30.apply(this, arguments);
    };
  }();
  var updateUserPermissionsRequest = /*#__PURE__*/function () {
    var _ref31 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee31(payload) {
      return _regeneratorRuntime().wrap(function _callee31$(_context31) {
        while (1) {
          switch (_context31.prev = _context31.next) {
            case 0:
              _context31.next = 2;
              return request.post('/api/update_user_permissions/', payload);

            case 2:
              return _context31.abrupt("return", _context31.sent);

            case 3:
            case "end":
              return _context31.stop();
          }
        }
      }, _callee31);
    }));

    return function updateUserPermissionsRequest(_x31) {
      return _ref31.apply(this, arguments);
    };
  }();
  /**
   * @API Contact
   */

  var searchContactRequest = /*#__PURE__*/function () {
    var _ref32 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee32(payload) {
      return _regeneratorRuntime().wrap(function _callee32$(_context32) {
        while (1) {
          switch (_context32.prev = _context32.next) {
            case 0:
              _context32.next = 2;
              return request.get('/api/contacts/search/', {
                params: payload
              });

            case 2:
              return _context32.abrupt("return", _context32.sent);

            case 3:
            case "end":
              return _context32.stop();
          }
        }
      }, _callee32);
    }));

    return function searchContactRequest(_x32) {
      return _ref32.apply(this, arguments);
    };
  }();
  var getContactListRequest = /*#__PURE__*/function () {
    var _ref33 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee33(payload) {
      return _regeneratorRuntime().wrap(function _callee33$(_context33) {
        while (1) {
          switch (_context33.prev = _context33.next) {
            case 0:
              _context33.next = 2;
              return request.get('/api/user_follow_contacts/', {
                params: payload
              });

            case 2:
              return _context33.abrupt("return", _context33.sent);

            case 3:
            case "end":
              return _context33.stop();
          }
        }
      }, _callee33);
    }));

    return function getContactListRequest(_x33) {
      return _ref33.apply(this, arguments);
    };
  }();
  var sendFriendRequest = /*#__PURE__*/function () {
    var _ref34 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee34(payload) {
      return _regeneratorRuntime().wrap(function _callee34$(_context34) {
        while (1) {
          switch (_context34.prev = _context34.next) {
            case 0:
              _context34.next = 2;
              return request.post('/api/contacts/add_friends/', payload);

            case 2:
              return _context34.abrupt("return", _context34.sent);

            case 3:
            case "end":
              return _context34.stop();
          }
        }
      }, _callee34);
    }));

    return function sendFriendRequest(_x34) {
      return _ref34.apply(this, arguments);
    };
  }();
  var getMyFriendListRequset = /*#__PURE__*/function () {
    var _ref35 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee35(payload) {
      return _regeneratorRuntime().wrap(function _callee35$(_context35) {
        while (1) {
          switch (_context35.prev = _context35.next) {
            case 0:
              _context35.next = 2;
              return request.get('/api/contacts/add_friends/', {
                params: payload
              });

            case 2:
              return _context35.abrupt("return", _context35.sent);

            case 3:
            case "end":
              return _context35.stop();
          }
        }
      }, _callee35);
    }));

    return function getMyFriendListRequset(_x35) {
      return _ref35.apply(this, arguments);
    };
  }();
  var getRreceiveFriendListRequests = /*#__PURE__*/function () {
    var _ref36 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee36(payload) {
      return _regeneratorRuntime().wrap(function _callee36$(_context36) {
        while (1) {
          switch (_context36.prev = _context36.next) {
            case 0:
              _context36.next = 2;
              return request.get('/api/contacts/friend_requests/', {
                params: payload
              });

            case 2:
              return _context36.abrupt("return", _context36.sent);

            case 3:
            case "end":
              return _context36.stop();
          }
        }
      }, _callee36);
    }));

    return function getRreceiveFriendListRequests(_x36) {
      return _ref36.apply(this, arguments);
    };
  }();
  var operationFriendRequest = /*#__PURE__*/function () {
    var _ref37 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee37(payload) {
      return _regeneratorRuntime().wrap(function _callee37$(_context37) {
        while (1) {
          switch (_context37.prev = _context37.next) {
            case 0:
              _context37.next = 2;
              return request.post('/api/contacts/friend_requests/', payload);

            case 2:
              return _context37.abrupt("return", _context37.sent);

            case 3:
            case "end":
              return _context37.stop();
          }
        }
      }, _callee37);
    }));

    return function operationFriendRequest(_x37) {
      return _ref37.apply(this, arguments);
    };
  }();
  /**
   * @API Notification
   */

  var changeNotificationStatusRequest = /*#__PURE__*/function () {
    var _ref38 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee38(payload) {
      return _regeneratorRuntime().wrap(function _callee38$(_context38) {
        while (1) {
          switch (_context38.prev = _context38.next) {
            case 0:
              _context38.next = 2;
              return request.post('/api/notification/status/', payload);

            case 2:
              return _context38.abrupt("return", _context38.sent);

            case 3:
            case "end":
              return _context38.stop();
          }
        }
      }, _callee38);
    }));

    return function changeNotificationStatusRequest(_x38) {
      return _ref38.apply(this, arguments);
    };
  }();
  var createTopicRequest = /*#__PURE__*/function () {
    var _ref39 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee39(payload) {
      return _regeneratorRuntime().wrap(function _callee39$(_context39) {
        while (1) {
          switch (_context39.prev = _context39.next) {
            case 0:
              _context39.next = 2;
              return request.post('/api/create_topic/', payload);

            case 2:
              return _context39.abrupt("return", _context39.sent);

            case 3:
            case "end":
              return _context39.stop();
          }
        }
      }, _callee39);
    }));

    return function createTopicRequest(_x39) {
      return _ref39.apply(this, arguments);
    };
  }();
  var subscribeTopicRequest = /*#__PURE__*/function () {
    var _ref40 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee40(payload) {
      return _regeneratorRuntime().wrap(function _callee40$(_context40) {
        while (1) {
          switch (_context40.prev = _context40.next) {
            case 0:
              _context40.next = 2;
              return request.post('/api/subscribe_topic/', payload);

            case 2:
              return _context40.abrupt("return", _context40.sent);

            case 3:
            case "end":
              return _context40.stop();
          }
        }
      }, _callee40);
    }));

    return function subscribeTopicRequest(_x40) {
      return _ref40.apply(this, arguments);
    };
  }();
  var publishTopicMessageRequest = /*#__PURE__*/function () {
    var _ref41 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee41(payload) {
      return _regeneratorRuntime().wrap(function _callee41$(_context41) {
        while (1) {
          switch (_context41.prev = _context41.next) {
            case 0:
              _context41.next = 2;
              return request.post('/api/publish_topic_message/', payload);

            case 2:
              return _context41.abrupt("return", _context41.sent);

            case 3:
            case "end":
              return _context41.stop();
          }
        }
      }, _callee41);
    }));

    return function publishTopicMessageRequest(_x41) {
      return _ref41.apply(this, arguments);
    };
  }();
  var myCreateTopicListRequest = /*#__PURE__*/function () {
    var _ref42 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee42(payload) {
      return _regeneratorRuntime().wrap(function _callee42$(_context42) {
        while (1) {
          switch (_context42.prev = _context42.next) {
            case 0:
              _context42.next = 2;
              return request.get('/api/my_create_topic_list/', {
                params: payload
              });

            case 2:
              return _context42.abrupt("return", _context42.sent);

            case 3:
            case "end":
              return _context42.stop();
          }
        }
      }, _callee42);
    }));

    return function myCreateTopicListRequest(_x42) {
      return _ref42.apply(this, arguments);
    };
  }();
  var mySubscribeTopicListRequest = /*#__PURE__*/function () {
    var _ref43 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee43(payload) {
      return _regeneratorRuntime().wrap(function _callee43$(_context43) {
        while (1) {
          switch (_context43.prev = _context43.next) {
            case 0:
              _context43.next = 2;
              return request.get('/api/my_subscribe_topic_list/', {
                params: payload
              });

            case 2:
              return _context43.abrupt("return", _context43.sent);

            case 3:
            case "end":
              return _context43.stop();
          }
        }
      }, _callee43);
    }));

    return function mySubscribeTopicListRequest(_x43) {
      return _ref43.apply(this, arguments);
    };
  }();

  var ByteArrayToHexString$1 = function ByteArrayToHexString(byteArray) {
    return Array.from(byteArray, function (_byte) {
      return ('0' + (_byte & 0xff).toString(16)).slice(-2);
    }).join('');
  };

  var Uint8ToBase64String$1 = function Uint8ToBase64String(u8a) {
    return btoa(String.fromCharCode.apply(null, u8a));
  };

  var GetContactBytes = function GetContactBytes(command, bytes) {
    // client category type
    var categoryType = 10;
    var concatArray = new Uint8Array([categoryType, command].concat(_toConsumableArray(bytes)));
    return concatArray;
  };
  var GenerateEd25519KeyPair = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var privateObj, pubkeyObj, PrivateKey, PublicKey;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              privateObj = ed__default["default"].utils.randomPrivateKey();
              _context.next = 3;
              return ed__default["default"].getPublicKey(privateObj);

            case 3:
              pubkeyObj = _context.sent;
              PrivateKey = ByteArrayToHexString$1(privateObj);
              PublicKey = ByteArrayToHexString$1(pubkeyObj);
              return _context.abrupt("return", {
                PrivateKey: PrivateKey,
                PublicKey: PublicKey
              });

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function GenerateEd25519KeyPair() {
      return _ref.apply(this, arguments);
    };
  }(); // export const GenerateQrCode = async (text: string) => {
  //   try {
  //     return await QRCode.toDataURL(text);
  //   } catch (err: any) {
  //     throw new Error(err.message);
  //   }
  // };

  var sha256 = function sha256(data) {
    return new Uint8Array(jssha256__default["default"].sha256.digest(data));
  };
  var DownloadKeyPair = function DownloadKeyPair(text) {
    var filename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'KeyPairs';
    var aTag = document.createElement('a');
    aTag.download = filename; // @ts-ignore

    aTag.style = 'display: none';
    aTag.href = "data:text/txt;charset=utf-8,".concat(text);
    document.body.appendChild(aTag);
    aTag.click();
  };
  var GenerateRandomSixCode = function GenerateRandomSixCode() {
    var code = '';

    for (var i = 0; i < 6; i++) {
      code += String(Math.floor(Math.random() * 10));
    }

    return code;
  };
  var getDataSignature = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(PrivateKey, signContent) {
      var signature;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (PrivateKey) {
                _context2.next = 2;
                break;
              }

              throw new Error('Ed25519PrivateKey not found');

            case 2:
              _context2.next = 4;
              return ed__default["default"].sign(new TextEncoder().encode(signContent), PrivateKey);

            case 4:
              signature = _context2.sent;
              return _context2.abrupt("return", Uint8ToBase64String$1(signature));

            case 6:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function getDataSignature(_x, _x2) {
      return _ref2.apply(this, arguments);
    };
  }();
  var getCurrentDate = function getCurrentDate() {
    var d = new Date();
    return ('0' + d.getDate()).slice(-2) + '/' + ('0' + (d.getMonth() + 1)).slice(-2) + '/' + d.getFullYear() + ' ' + ('0' + d.getHours()).slice(-2) + ':' + ('0' + d.getMinutes()).slice(-2);
  };
  var selectUrl = function selectUrl(url) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'http';

    if (type === 'ws') {
      var Domain = url.split('://')[1];
      return "wss://".concat(Domain, "/messages");
    }

    return url;
  }; // eslint-disable-next-line no-unused-vars

  var getServerList = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(arr) {
      var serverList, i, domain;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              serverList = [];
              i = 0;

            case 2:
              if (!(i < arr.length)) {
                _context3.next = 19;
                break;
              }

              domain = arr[i];
              _context3.prev = 4;
              _context3.next = 7;
              return axios__default["default"].get("".concat(domain, "/api/server-list/"));

            case 7:
              _context3.next = 9;
              return _context3.sent.data.data;

            case 9:
              serverList = _context3.sent;
              return _context3.abrupt("break", 19);

            case 13:
              _context3.prev = 13;
              _context3.t0 = _context3["catch"](4);
              return _context3.abrupt("continue", 16);

            case 16:
              i++;
              _context3.next = 2;
              break;

            case 19:
              return _context3.abrupt("return", serverList);

            case 20:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, null, [[4, 13]]);
    }));

    return function getServerList(_x3) {
      return _ref3.apply(this, arguments);
    };
  }();

  var getAllDomainList = /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(env) {
      var list, timestamp, requestQueue, i, item, _yield$axios$head, headers, timeDifference;

      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return getServerList(domainUrlList[env]);

            case 2:
              list = _context4.sent;
              timestamp = Date.now();
              requestQueue = [];
              i = 0;

            case 6:
              if (!(i < list.length)) {
                _context4.next = 23;
                break;
              }

              item = list[i].endpoint;
              _context4.prev = 8;
              _context4.next = 11;
              return axios__default["default"].head("".concat(item, "/api/ping/"));

            case 11:
              _yield$axios$head = _context4.sent;
              headers = _yield$axios$head.headers;
              timeDifference = new Date(headers.date).valueOf() - timestamp;
              requestQueue.push({
                time: timeDifference,
                url: item,
                serverRate: headers['server-rate'],
                nodeId: headers.nodeid
              });
              _context4.next = 20;
              break;

            case 17:
              _context4.prev = 17;
              _context4.t0 = _context4["catch"](8);
              console.log(_context4.t0);

            case 20:
              i++;
              _context4.next = 6;
              break;

            case 23:
              return _context4.abrupt("return", requestQueue);

            case 24:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, null, [[8, 17]]);
    }));

    return function getAllDomainList(_x4) {
      return _ref4.apply(this, arguments);
    };
  }();

  var handleSort = function handleSort(key) {
    return function (a, b) {
      var val1 = Number(a[key]);
      var val2 = Number(b[key]);
      return val1 - val2;
    };
  };

  var getFastestUrl = /*#__PURE__*/function () {
    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
      var env,
          list,
          _args5 = arguments;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              env = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : 'test';
              _context5.next = 3;
              return getAllDomainList(env);

            case 3:
              list = _context5.sent;
              return _context5.abrupt("return", list.sort(handleSort('time'))[0].url);

            case 5:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));

    return function getFastestUrl() {
      return _ref5.apply(this, arguments);
    };
  }();
  var renderMessagesList = /*#__PURE__*/function () {
    var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(msglist) {
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              return _context6.abrupt("return", msglist.map(function (msg, idx) {
                var content = '';

                if (msg.cipher_suite == 'NONE') {
                  content = decodeURIComponent(escape(window.atob(msg.payload)));
                } // else if (msg.cipher_suite == 'RSA_OAEP') {
                //   if (msg.payload) {
                //     let byteContent = Uint8Array.from(atob(msg.payload), (c) => c.charCodeAt(0));
                //     let decodeBytes = await getRsaDecryptData(RsaPrivateKeyStr ?? '', byteContent);
                //     content = new TextDecoder().decode(decodeBytes);
                //   } else {
                //     content = '';
                //   }
                // }
                else {
                  content = ' ' + msg.cipher_suite;
                }

                var date = new Date(msg.timestamp);
                var timestampStr = date.getHours() + ':' + date.getMinutes();
                var dateStr = date.getFullYear() + '-' + (date.getMonth() + 1) + '-' + date.getDate();
                var message = {
                  _id: idx + 1,
                  id: idx + 1,
                  indexId: idx + 1,
                  content: content,
                  senderId: msg.from,
                  username: '',
                  avatar: 'assets/imgs/doe.png',
                  // date: "13 November",
                  // timestamp: "10:20",
                  date: dateStr,
                  timestamp: timestampStr,
                  system: false,
                  saved: false,
                  distributed: true,
                  seen: true,
                  failure: false
                };
                return message;
              }));

            case 1:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }));

    return function renderMessagesList(_x5) {
      return _ref6.apply(this, arguments);
    };
  }();
  var getGroupId = function getGroupId(msg, client) {
    var comeFrom = msg.comeFrom,
        contentTopic = msg.contentTopic;
    var userid = client.keys.userid;

    if (contentTopic === userid) {
      return comeFrom;
    }

    return contentTopic;
  };
  var renderMessage = function renderMessage(pbType, msg, client) {
    var messageId = msg.messageId,
        timestamp = msg.timestamp,
        payload = msg.payload;
    var content = '';
    var senderId = '';

    if (pbType === PbTypeMessage) {
      // received message
      content = new TextDecoder().decode(payload);
      senderId = getGroupId(msg, client);
    }

    if (pbType === PbTypeMessageStatusResp) {
      // send message
      content = client.message.msg_text;
      senderId = client.keys.userid;
    }

    var date = pbType === PbTypeMessage ? new Date(Number(timestamp)) : new Date(Number(timestamp) * 1000);
    var timestampStr = date.getHours() + ':' + date.getMinutes();
    var dateStr = date.getFullYear() + '-' + (date.getMonth() + 1) + '-' + date.getDate();
    var message = {
      _id: messageId,
      id: messageId,
      indexId: messageId,
      // receivesuccess
      msgLoading: pbType === PbTypeMessage ? SendMsgLoadingMap['success'] : SendMsgLoadingMap['loading'],
      content: content,
      senderId: senderId,
      username: '',
      avatar: 'assets/imgs/doe.png',
      // date: "13 November",
      // timestamp: "10:20",
      date: dateStr,
      timestamp: timestampStr,
      system: false,
      saved: false,
      distributed: true,
      seen: true,
      failure: false
    };
    return message;
  };
  var transformAddress = /*#__PURE__*/function () {
    var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(walletAddress) {
      var cacheUserId, _yield$getUserInfoReq, data, userid;

      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (!walletAddress.toLowerCase().startsWith('0x')) {
                _context7.next = 11;
                break;
              }

              cacheUserId = localStorage.getItem(walletAddress);

              if (!cacheUserId) {
                _context7.next = 4;
                break;
              }

              return _context7.abrupt("return", cacheUserId);

            case 4:
              _context7.next = 6;
              return getUserInfoRequest({
                did_type: 'eth',
                did_value: walletAddress,
                timestamp: Date.now()
              });

            case 6:
              _yield$getUserInfoReq = _context7.sent;
              data = _yield$getUserInfoReq.data;
              userid = data.userid;
              localStorage.setItem(walletAddress, userid);
              return _context7.abrupt("return", userid);

            case 11:
              return _context7.abrupt("return", walletAddress);

            case 12:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    }));

    return function transformAddress(_x6) {
      return _ref7.apply(this, arguments);
    };
  }();
  var saveMessageUpdateDate = function saveMessageUpdateDate() {
    localStorage.setItem('MESSAGEUPDATEDATE', String(Date.now()));
  };
  var getMessageUpdateDate = function getMessageUpdateDate() {
    return Number(localStorage.getItem('MESSAGEUPDATEDATE'));
  };
  var updateMessageLoadStatus = function updateMessageLoadStatus(msgList, msg) {
    var status = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : SendMsgLoadingMap['success'];
    var message = msgList.find(function (item) {
      return item.id === msg.id;
    });

    if (message) {
      message.msgLoading = status;
    }

    return msgList;
  };
  function newDateFormat(time, format) {
    var t = new Date(time);
    format = format || 'Y-m-d h:i:s';
    var year = t.getFullYear();
    var month = t.getMonth() + 1;
    var day = t.getDate();
    var hours = t.getHours();
    var minutes = t.getMinutes();
    var seconds = t.getSeconds();
    var hash = {
      y: year,
      m: month,
      d: day,
      h: hours,
      i: minutes,
      s: seconds
    }; //  0

    var isAddZero = function isAddZero(o) {
      return /M|D|H|I|S/.test(o);
    };

    return format.replace(/\w/g, function (o) {
      // @ts-ignore
      var rt = hash[o.toLocaleLowerCase()];
      if (typeof rt === 'string') return rt;
      return rt >= 10 || isAddZero(o) ? rt : "0".concat(rt);
    });
  }

  var getEd25519SharedKey = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(myEd25519PrivateKey, targetUserPubkey) {
      var sharedKey;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return ed__default["default"].getSharedSecret(myEd25519PrivateKey, targetUserPubkey);

            case 2:
              sharedKey = _context.sent;
              return _context.abrupt("return", sharedKey);

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function getEd25519SharedKey(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();

  var stringToArrayBuffer = function stringToArrayBuffer(str) {
    var buf = new ArrayBuffer(str.length);
    var bufView = new Uint8Array(buf);

    for (var i = 0, strLen = str.length; i < strLen; i++) {
      bufView[i] = str.charCodeAt(i);
    }

    return buf;
  };

  var importSecretKey = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(rawKey, aesName) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return window.crypto.subtle.importKey('raw', rawKey, aesName, true, ['encrypt', 'decrypt']);

            case 2:
              return _context2.abrupt("return", _context2.sent);

            case 3:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function importSecretKey(_x3, _x4) {
      return _ref2.apply(this, arguments);
    };
  }();

  var fromHexString = function fromHexString(hexString) {
    return Uint8Array.from(hexString.match(/.{1,2}/g).map(function (_byte) {
      return parseInt(_byte, 16);
    }));
  };

  var aesDecrypt = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(aesName, keyStr, keySize, iv, encoded) {
      var alg, key, result;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              alg = {
                name: aesName,
                iv: stringToArrayBuffer(atob(iv)),
                length: keySize
              };
              _context3.next = 3;
              return importSecretKey(stringToArrayBuffer(atob(keyStr)), aesName);

            case 3:
              key = _context3.sent;
              _context3.next = 6;
              return window.crypto.subtle.decrypt(alg, key, encoded);

            case 6:
              result = _context3.sent;
              return _context3.abrupt("return", result);

            case 8:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    return function aesDecrypt(_x5, _x6, _x7, _x8, _x9) {
      return _ref3.apply(this, arguments);
    };
  }();

  var aesEncrypt = /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(aesName, keyStr, keySize, iv, encoded) {
      var alg, key, result;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              alg = {
                name: aesName,
                iv: stringToArrayBuffer(atob(iv)),
                length: keySize
              };
              _context4.next = 3;
              return importSecretKey(stringToArrayBuffer(atob(keyStr)), aesName);

            case 3:
              key = _context4.sent;
              _context4.next = 6;
              return window.crypto.subtle.encrypt(alg, key, encoded);

            case 6:
              result = _context4.sent;
              return _context4.abrupt("return", result);

            case 8:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    return function aesEncrypt(_x10, _x11, _x12, _x13, _x14) {
      return _ref4.apply(this, arguments);
    };
  }();

  var ByteArrayToHexString = function ByteArrayToHexString(byteArray) {
    return Array.from(byteArray, function (_byte2) {
      return ('0' + (_byte2 & 0xff).toString(16)).slice(-2);
    }).join('');
  };

  var Uint8ToBase64String = function Uint8ToBase64String(u8a) {
    return window.btoa(String.fromCharCode.apply(String, u8a));
  };
  var Base64StringToUint8 = function Base64StringToUint8(base64) {
    var binary_string = window.atob(base64);
    var len = binary_string.length;
    var bytes = new Uint8Array(len);

    for (var i = 0; i < len; i++) {
      bytes[i] = binary_string.charCodeAt(i);
    }

    return bytes;
  };
  var GetAESBase64Key = /*#__PURE__*/function () {
    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(hex_key) {
      var master_key, aes_key_obj, arrayBuffer, base64String;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return crypto.subtle.importKey('raw', fromHexString(hex_key), 'HKDF', false, ['deriveKey']);

            case 2:
              master_key = _context5.sent;
              _context5.next = 5;
              return window.crypto.subtle.deriveKey({
                name: 'HKDF',
                salt: new Uint8Array(),
                info: new Uint8Array(),
                hash: 'SHA-384'
              }, master_key, {
                name: 'AES-GCM',
                length: 256
              }, true, ['encrypt', 'decrypt']);

            case 5:
              aes_key_obj = _context5.sent;
              _context5.next = 8;
              return crypto.subtle.exportKey('raw', aes_key_obj);

            case 8:
              arrayBuffer = _context5.sent;
              base64String = btoa(String.fromCharCode.apply(String, _toConsumableArray(new Uint8Array(arrayBuffer))));
              return _context5.abrupt("return", base64String);

            case 11:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));

    return function GetAESBase64Key(_x15) {
      return _ref5.apply(this, arguments);
    };
  }();
  var getMessageSharedSecret = /*#__PURE__*/function () {
    var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(myEd25519PrivateKey, targetUserPubkey) {
      var sharedKey;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return getEd25519SharedKey(myEd25519PrivateKey, targetUserPubkey);

            case 2:
              sharedKey = _context6.sent;
              return _context6.abrupt("return", ByteArrayToHexString(sharedKey));

            case 4:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }));

    return function getMessageSharedSecret(_x16, _x17) {
      return _ref6.apply(this, arguments);
    };
  }();
  var aesGCMEncrypt = /*#__PURE__*/function () {
    var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(keyStr, iv, inputByteData) {
      var keySize;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              keySize = 256;
              _context7.next = 3;
              return aesEncrypt('AES-GCM', keyStr, keySize, iv, inputByteData);

            case 3:
              return _context7.abrupt("return", _context7.sent);

            case 4:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    }));

    return function aesGCMEncrypt(_x18, _x19, _x20) {
      return _ref7.apply(this, arguments);
    };
  }();
  var aesGCMDecrypt = /*#__PURE__*/function () {
    var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(keyStr, iv, encoded) {
      var keySize;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              keySize = 256;
              _context8.next = 3;
              return aesDecrypt('AES-GCM', keyStr, keySize, iv, encoded);

            case 3:
              return _context8.abrupt("return", _context8.sent);

            case 4:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8);
    }));

    return function aesGCMDecrypt(_x21, _x22, _x23) {
      return _ref8.apply(this, arguments);
    };
  }();

  var Register = /*#__PURE__*/_createClass(function Register(appKey) {
    var _this = this;

    _classCallCheck(this, Register);

    _defineProperty(this, "appKey", void 0);

    _defineProperty(this, "pubicKeyType", 'ed25519');

    _defineProperty(this, "registerTime", void 0);

    _defineProperty(this, "registerSignContent", void 0);

    _defineProperty(this, "getUserInfo", /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options) {
        var userid, userExist, did_type, did_value, timestamp, _yield$getUserInfoReq, data;

        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                userid = '';
                userExist = false;
                did_type = options.did_type, did_value = options.did_value;
                timestamp = Date.now();
                _context.prev = 4;
                _context.next = 7;
                return getUserInfoRequest({
                  did_type: did_type,
                  did_value: did_value,
                  timestamp: timestamp
                });

              case 7:
                _yield$getUserInfoReq = _context.sent;
                data = _yield$getUserInfoReq.data;
                userid = data.userid;

                if (data.main_pubkey) {
                  userExist = true;
                }

                _context.next = 17;
                break;

              case 13:
                _context.prev = 13;
                _context.t0 = _context["catch"](4);
                userid = "user:".concat(jsSha3.sha3_224(did_type + did_value + timestamp));
                userExist = false;

              case 17:
                return _context.abrupt("return", {
                  userid: userid,
                  userExist: userExist
                });

              case 18:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[4, 13]]);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());

    _defineProperty(this, "getMainKeypair", /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(options) {
        var password, did_value, did_type, _yield$_this$getMainK, signContent, _yield$_this$sign, signature;

        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                password = options.password, did_value = options.did_value, did_type = options.did_type;
                _context2.next = 3;
                return _this.getMainKeypairSignContent(options);

              case 3:
                _yield$_this$getMainK = _context2.sent;
                signContent = _yield$_this$getMainK.signContent;
                _context2.next = 7;
                return _this.sign(signContent, did_value, did_type);

              case 7:
                _yield$_this$sign = _context2.sent;
                signature = _yield$_this$sign.sign;
                _context2.next = 11;
                return _this.getMainKeypairBySignature(signature, password);

              case 11:
                return _context2.abrupt("return", _context2.sent);

              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      return function (_x2) {
        return _ref2.apply(this, arguments);
      };
    }());

    _defineProperty(this, "register", /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(options) {
        var userid, didValue, mainPublicKey, signature, _options$did_pubkey, did_pubkey, _options$didType, didType, _options$nickname, nickname, _options$avatar_url, avatar_url, _options$avatar_base, avatar_base64, payload;

        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                userid = options.userid, didValue = options.didValue, mainPublicKey = options.mainPublicKey, signature = options.signature, _options$did_pubkey = options.did_pubkey, did_pubkey = _options$did_pubkey === void 0 ? '' : _options$did_pubkey, _options$didType = options.didType, didType = _options$didType === void 0 ? 'eth' : _options$didType, _options$nickname = options.nickname, nickname = _options$nickname === void 0 ? '' : _options$nickname, _options$avatar_url = options.avatar_url, avatar_url = _options$avatar_url === void 0 ? '' : _options$avatar_url, _options$avatar_base = options.avatar_base64, avatar_base64 = _options$avatar_base === void 0 ? '' : _options$avatar_base;

                if (!(!_this.registerTime || !_this.registerSignContent)) {
                  _context3.next = 3;
                  break;
                }

                throw new Error('Please create register sign content first!');

              case 3:
                payload = {
                  userid: userid,
                  did_type: didType,
                  did_value: didValue,
                  did_pubkey: did_pubkey,
                  did_signature: signature,
                  signature_content: _this.registerSignContent,
                  pubkey_type: _this.pubicKeyType,
                  pubkey_value: mainPublicKey,
                  nickname: nickname,
                  avatar_url: avatar_url,
                  avatar_base64: avatar_base64,
                  timestamp: _this.registerTime,
                  testnet_access_key: _this.appKey
                };
                _context3.prev = 4;
                _context3.next = 7;
                return userRegisterRequest(payload);

              case 7:
                return _context3.abrupt("return", _context3.sent);

              case 10:
                _context3.prev = 10;
                _context3.t0 = _context3["catch"](4);
                throw new Error(_context3.t0.message);

              case 13:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, null, [[4, 10]]);
      }));

      return function (_x3) {
        return _ref3.apply(this, arguments);
      };
    }());

    _defineProperty(this, "login", /*#__PURE__*/function () {
      var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(options) {
        var password, userid, didValue, _options$didType2, didType, mainPrivateKey, mainPublicKey, _options$pubkeyExpire, pubkeyExpiredTimestamp, timestamp, _yield$GenerateEd, PublicKey, PrivateKey, signContent, AesKey, AesIv, decode_data, decode_dataStr, login_signature, payload;

        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                password = options.password, userid = options.userid, didValue = options.didValue, _options$didType2 = options.didType, didType = _options$didType2 === void 0 ? 'eth' : _options$didType2, mainPrivateKey = options.mainPrivateKey, mainPublicKey = options.mainPublicKey, _options$pubkeyExpire = options.pubkeyExpiredTimestamp, pubkeyExpiredTimestamp = _options$pubkeyExpire === void 0 ? Date.now() + 86400 * 1000 : _options$pubkeyExpire;
                _context4.prev = 1;
                timestamp = Date.now();
                _context4.next = 5;
                return GenerateEd25519KeyPair();

              case 5:
                _yield$GenerateEd = _context4.sent;
                PublicKey = _yield$GenerateEd.PublicKey;
                PrivateKey = _yield$GenerateEd.PrivateKey;
                signContent = jsSha3.sha3_224(userid + PublicKey + pubkeyExpiredTimestamp + timestamp);
                _context4.next = 11;
                return GetAESBase64Key(password);

              case 11:
                AesKey = _context4.sent;
                AesIv = AesKey.slice(0, 16);
                _context4.next = 15;
                return aesGCMDecrypt(AesKey, AesIv, Base64StringToUint8(mainPrivateKey));

              case 15:
                decode_data = _context4.sent;
                decode_dataStr = new TextDecoder().decode(new Uint8Array(decode_data));
                _context4.next = 19;
                return getDataSignature(decode_dataStr, signContent);

              case 19:
                login_signature = _context4.sent;
                payload = {
                  userid: userid,
                  did_type: didType,
                  did_value: didValue,
                  login_signature: login_signature,
                  signature_content: signContent,
                  main_pubkey: mainPublicKey,
                  pubkey_value: PublicKey,
                  pubkey_type: 'ed25519',
                  timestamp: timestamp,
                  pubkey_expired_timestamp: pubkeyExpiredTimestamp
                };
                _context4.next = 23;
                return userLoginRequest(payload);

              case 23:
                // @ts-ignore
                request.defaults.headers['web3mq-request-pubkey'] = PublicKey; // @ts-ignore

                request.defaults.headers['didkey'] = "".concat(didType, ":").concat(didValue);
                return _context4.abrupt("return", {
                  tempPrivateKey: PrivateKey,
                  tempPublicKey: PublicKey,
                  mainPrivateKey: mainPrivateKey,
                  mainPublicKey: mainPublicKey,
                  pubkeyExpiredTimestamp: pubkeyExpiredTimestamp
                });

              case 28:
                _context4.prev = 28;
                _context4.t0 = _context4["catch"](1);
                throw new Error(_context4.t0.message);

              case 31:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, null, [[1, 28]]);
      }));

      return function (_x4) {
        return _ref4.apply(this, arguments);
      };
    }());

    _defineProperty(this, "resetPassword", /*#__PURE__*/function () {
      var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(options) {
        var userid, didValue, mainPublicKey, signature, _options$did_pubkey2, did_pubkey, _options$didType3, didType, _options$nickname2, nickname, _options$avatar_url2, avatar_url, payload;

        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                userid = options.userid, didValue = options.didValue, mainPublicKey = options.mainPublicKey, signature = options.signature, _options$did_pubkey2 = options.did_pubkey, did_pubkey = _options$did_pubkey2 === void 0 ? '' : _options$did_pubkey2, _options$didType3 = options.didType, didType = _options$didType3 === void 0 ? 'eth' : _options$didType3, _options$nickname2 = options.nickname, nickname = _options$nickname2 === void 0 ? '' : _options$nickname2, _options$avatar_url2 = options.avatar_url, avatar_url = _options$avatar_url2 === void 0 ? '' : _options$avatar_url2;

                if (!(!_this.registerTime || !_this.registerSignContent)) {
                  _context5.next = 3;
                  break;
                }

                throw new Error('Please create register sign content first!');

              case 3:
                payload = {
                  userid: userid,
                  did_type: didType,
                  did_value: didValue,
                  did_pubkey: did_pubkey,
                  did_signature: signature,
                  signature_content: _this.registerSignContent,
                  pubkey_type: _this.pubicKeyType,
                  pubkey_value: mainPublicKey,
                  nickname: nickname,
                  avatar_url: avatar_url,
                  timestamp: _this.registerTime,
                  testnet_access_key: _this.appKey
                };
                _context5.prev = 4;
                _context5.next = 7;
                return resetPasswordRequest(payload);

              case 7:
                return _context5.abrupt("return", _context5.sent);

              case 10:
                _context5.prev = 10;
                _context5.t0 = _context5["catch"](4);
                throw new Error(_context5.t0.message);

              case 13:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, null, [[4, 10]]);
      }));

      return function (_x5) {
        return _ref5.apply(this, arguments);
      };
    }());

    _defineProperty(this, "sign", /*#__PURE__*/function () {
      var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(signContent, address, walletType) {
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.t0 = walletType;
                _context6.next = _context6.t0 === 'starknet' ? 3 : 4;
                break;

              case 3:
                return _context6.abrupt("return", signWithStarkNet(signContent, address));

              case 4:
                return _context6.abrupt("return", signWithEth(signContent, address));

              case 5:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));

      return function (_x6, _x7, _x8) {
        return _ref6.apply(this, arguments);
      };
    }());

    _defineProperty(this, "getAccount", /*#__PURE__*/function () {
      var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(walletType) {
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.t0 = walletType;
                _context7.next = _context7.t0 === 'starknet' ? 3 : 6;
                break;

              case 3:
                _context7.next = 5;
                return getStarkNetAccount();

              case 5:
                return _context7.abrupt("return", _context7.sent);

              case 6:
                _context7.next = 8;
                return getEthAccount();

              case 8:
                return _context7.abrupt("return", _context7.sent);

              case 9:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));

      return function (_x9) {
        return _ref7.apply(this, arguments);
      };
    }());

    _defineProperty(this, "getMainKeypairSignContent", /*#__PURE__*/function () {
      var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(options) {
        var password, did_value, did_type, keyIndex, keyMSG, magicString, signContent;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                password = options.password, did_value = options.did_value, did_type = options.did_type;
                keyIndex = 1;
                keyMSG = "".concat(did_type, ":").concat(did_value).concat(keyIndex).concat(password);
                magicString = Uint8ToBase64String(new TextEncoder().encode(jsSha3.sha3_224("$web3mq".concat(keyMSG, "web3mq$"))));
                signContent = "Signing this message will allow this app to decrypt messages in the Web3MQ protocol for the following address: ".concat(did_value, ". This won\u2019t cost you anything.\n\nIf your Web3MQ wallet-associated password and this signature is exposed to any malicious app, this would result in exposure of Web3MQ account access and encryption keys, and the attacker would be able to read your messages.\n\nIn the event of such an incident, don\u2019t panic. You can call Web3MQ\u2019s key revoke API and service to revoke access to the exposed encryption key and generate a new one!\n\nNonce: ").concat(magicString);
                return _context8.abrupt("return", {
                  signContent: signContent
                });

              case 6:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      }));

      return function (_x10) {
        return _ref8.apply(this, arguments);
      };
    }());

    _defineProperty(this, "getMainKeypairBySignature", /*#__PURE__*/function () {
      var _ref9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(signature, password) {
        var secretKey, publicKey, AesKey, AesIv, encrytData, encrytDataStr;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                secretKey = sha256(signature);

                if (!(secretKey.length !== 32)) {
                  _context9.next = 3;
                  break;
                }

                throw new Error('Secret key must have 32 bytes');

              case 3:
                _context9.next = 5;
                return ed__default["default"].getPublicKey(secretKey);

              case 5:
                publicKey = _context9.sent;
                _context9.next = 8;
                return GetAESBase64Key(password);

              case 8:
                AesKey = _context9.sent;
                AesIv = AesKey.slice(0, 16);
                _context9.next = 12;
                return aesGCMEncrypt(AesKey, AesIv, new TextEncoder().encode(ByteArrayToHexString$1(secretKey)));

              case 12:
                encrytData = _context9.sent;
                encrytDataStr = Uint8ToBase64String(new Uint8Array(encrytData));
                return _context9.abrupt("return", {
                  publicKey: ByteArrayToHexString$1(publicKey),
                  secretKey: encrytDataStr
                });

              case 15:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      }));

      return function (_x11, _x12) {
        return _ref9.apply(this, arguments);
      };
    }());

    _defineProperty(this, "getRegisterSignContent", /*#__PURE__*/function () {
      var _ref10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(options) {
        var mainPublicKey, didType, didValue, userid, _options$signContentU, signContentURI, wallet_type_name, pubkey_type, timestamp, NonceContent, signContent;

        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                mainPublicKey = options.mainPublicKey, didType = options.didType, didValue = options.didValue, userid = options.userid, _options$signContentU = options.signContentURI, signContentURI = _options$signContentU === void 0 ? window.location.origin : _options$signContentU;
                wallet_type_name = WalletNameMap[didType];
                pubkey_type = _this.pubicKeyType;
                timestamp = Date.now();
                NonceContent = jsSha3.sha3_224(userid + pubkey_type + mainPublicKey + didType + didValue + timestamp);
                signContent = "Web3MQ wants you to sign in with your ".concat(wallet_type_name, " account:\n").concat(didValue, "\nFor Web3MQ register\nURI: ").concat(signContentURI, "\nVersion: 1\n\nNonce: ").concat(NonceContent, "\nIssued At: ").concat(getCurrentDate());
                _this.registerSignContent = signContent;
                _this.registerTime = timestamp;
                return _context10.abrupt("return", {
                  signContent: signContent
                });

              case 9:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10);
      }));

      return function (_x13) {
        return _ref10.apply(this, arguments);
      };
    }());

    this.appKey = appKey || '';
    this.registerTime = 0;
    this.registerSignContent = '';
  });

  var Channel = /*#__PURE__*/function () {
    function Channel(client) {
      _classCallCheck(this, Channel);

      _defineProperty(this, "_client", void 0);

      _defineProperty(this, "_keys", void 0);

      _defineProperty(this, "channelList", void 0);

      _defineProperty(this, "activeChannel", void 0);

      this._client = client;
      this._keys = client.keys;
      this.channelList = null;
      this.activeChannel = null;
    }

    _createClass(Channel, [{
      key: "handleUpdateChannel",
      value: function handleUpdateChannel(msg, chatid) {
        if (!this.channelList) {
          return;
        }

        this.channelList.map(function (item) {
          if (item.chatid === chatid) {
            item.lastMessage = msg.lastMessage;
            item.updatedAt = msg.updatedAt;
            item.unread = msg.unread || 0;
          }
        });

        this._client.emit('channel.updated', {
          type: 'channel.updated'
        });
      }
    }, {
      key: "syncNewMessages",
      value: function () {
        var _syncNewMessages = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          var sync_timestamp, _this$_keys, userid, PrivateKey, timestamp, signContent, web3mq_signature, _yield$syncNewMessage, data;

          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  sync_timestamp = getMessageUpdateDate();

                  if (sync_timestamp) {
                    _context.next = 3;
                    break;
                  }

                  return _context.abrupt("return", {});

                case 3:
                  _this$_keys = this._keys, userid = _this$_keys.userid, PrivateKey = _this$_keys.PrivateKey;
                  timestamp = Date.now();
                  signContent = userid + sync_timestamp + timestamp;
                  _context.next = 8;
                  return getDataSignature(PrivateKey, signContent);

                case 8:
                  web3mq_signature = _context.sent;
                  _context.next = 11;
                  return syncNewMessagesRequest({
                    sync_timestamp: sync_timestamp,
                    timestamp: timestamp,
                    userid: userid,
                    web3mq_user_signature: web3mq_signature
                  });

                case 11:
                  _yield$syncNewMessage = _context.sent;
                  data = _yield$syncNewMessage.data;
                  return _context.abrupt("return", data);

                case 14:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function syncNewMessages() {
          return _syncNewMessages.apply(this, arguments);
        }

        return syncNewMessages;
      }()
    }, {
      key: "handleUnread",
      value: function () {
        var _handleUnread = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(resp, msg) {
          var _this$activeChannel;

          var storage, count, comeFrom, data, msglist, indexeddbData;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  if (this.activeChannel) {
                    _context2.next = 2;
                    break;
                  }

                  return _context2.abrupt("return");

                case 2:
                  storage = this._client.storage;
                  count = 0;
                  comeFrom = getGroupId(resp, this._client) || this.activeChannel.chatid;
                  _context2.next = 7;
                  return storage.getData(comeFrom);

                case 7:
                  data = _context2.sent;
                  msglist = !data ? [msg] : [].concat(_toConsumableArray(data.payload.messageList), [msg]);

                  if (comeFrom !== ((_this$activeChannel = this.activeChannel) === null || _this$activeChannel === void 0 ? void 0 : _this$activeChannel.chatid)) {
                    count = !data ? 1 : data.unread + 1;
                  }

                  indexeddbData = {
                    messageId: resp.messageId,
                    from: comeFrom,
                    contentTopic: resp.contentTopic,
                    timestamp: Number(resp.timestamp),
                    unread: count,
                    lastMessage: msg.content,
                    updatedAt: msg.date,
                    payload: {
                      messageList: msglist
                    }
                  };
                  _context2.next = 13;
                  return storage.setData(comeFrom, indexeddbData);

                case 13:
                  this.handleUpdateChannel(indexeddbData, comeFrom);

                case 14:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function handleUnread(_x, _x2) {
          return _handleUnread.apply(this, arguments);
        }

        return handleUnread;
      }()
    }, {
      key: "setActiveChannel",
      value: function () {
        var _setActiveChannel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(channel) {
          var data;
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  this.activeChannel = channel;

                  if (!channel) {
                    _context3.next = 10;
                    break;
                  }

                  this.activeChannel.unread = 0;
                  _context3.next = 5;
                  return this._client.storage.getData(channel.chatid);

                case 5:
                  data = _context3.sent;

                  if (!(data && data.unread !== 0)) {
                    _context3.next = 10;
                    break;
                  }

                  data.unread = 0;
                  _context3.next = 10;
                  return this._client.storage.setData(channel === null || channel === void 0 ? void 0 : channel.chatid, data);

                case 10:
                  this._client.emit('channel.activeChange', {
                    type: 'channel.activeChange'
                  }); // if (data && data.unread !== 0) {
                  //   data.unread = 0;
                  //   await this._client.storage.setData(channel?.chatid as string, data);
                  //   this.channelList = (this.channelList as Array<ActiveChannelType>).map((item) => {
                  //     if (item.chatid === channel?.chatid) {
                  //       item.unread = 0;
                  //     }
                  //     return item;
                  //   });
                  //   this._client.emit('channel.updated', { type: 'channel.updated' });
                  // }


                case 11:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function setActiveChannel(_x3) {
          return _setActiveChannel.apply(this, arguments);
        }

        return setActiveChannel;
      }()
    }, {
      key: "queryChannels",
      value: function () {
        var _queryChannels = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(option) {
          var _this = this;

          var _this$_keys2, userid, PrivateKey, timestamp, signContent, web3mq_signature, _yield$getRoomListReq, _yield$getRoomListReq2, result, allNewMessageData, list;

          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  _this$_keys2 = this._keys, userid = _this$_keys2.userid, PrivateKey = _this$_keys2.PrivateKey;
                  timestamp = Date.now();
                  signContent = userid + timestamp;
                  _context5.next = 5;
                  return getDataSignature(PrivateKey, signContent);

                case 5:
                  web3mq_signature = _context5.sent;
                  _context5.next = 8;
                  return getRoomListRequest(_objectSpread2({
                    web3mq_signature: web3mq_signature,
                    userid: userid,
                    timestamp: timestamp
                  }, option));

                case 8:
                  _yield$getRoomListReq = _context5.sent;
                  _yield$getRoomListReq2 = _yield$getRoomListReq.data.result;
                  result = _yield$getRoomListReq2 === void 0 ? [] : _yield$getRoomListReq2;
                  _context5.next = 13;
                  return this.syncNewMessages();

                case 13:
                  allNewMessageData = _context5.sent;
                  _context5.next = 16;
                  return Promise.all(result.map( /*#__PURE__*/function () {
                    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(item) {
                      var data, currentNewMsgObj, newMessageUnread, messageid, unread, lastMessage, updatedAt;
                      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
                        while (1) {
                          switch (_context4.prev = _context4.next) {
                            case 0:
                              _context4.next = 2;
                              return _this._client.storage.getData(item.chatid);

                            case 2:
                              data = _context4.sent;
                              currentNewMsgObj = allNewMessageData[item.chatid];
                              newMessageUnread = 0;

                              for (messageid in currentNewMsgObj) {
                                if (currentNewMsgObj.hasOwnProperty(messageid) && currentNewMsgObj[messageid] !== 'read') {
                                  newMessageUnread++;
                                }
                              }

                              if (!data) {
                                _context4.next = 15;
                                break;
                              }

                              if (!newMessageUnread) {
                                _context4.next = 11;
                                break;
                              }

                              data.unread = newMessageUnread;
                              _context4.next = 11;
                              return _this._client.storage.setData(item.chatid, data);

                            case 11:
                              unread = data.unread, lastMessage = data.lastMessage, updatedAt = data.updatedAt;
                              item.unread = unread;
                              item.lastMessage = lastMessage;
                              item.updatedAt = updatedAt;

                            case 15:
                              return _context4.abrupt("return", item);

                            case 16:
                            case "end":
                              return _context4.stop();
                          }
                        }
                      }, _callee4);
                    }));

                    return function (_x5) {
                      return _ref.apply(this, arguments);
                    };
                  }()));

                case 16:
                  list = _context5.sent;

                  if (this.channelList && option.page !== 1) {
                    this.channelList = [].concat(_toConsumableArray(this.channelList), _toConsumableArray(list));
                  } else {
                    this.channelList = list;
                  }

                  this._client.emit('channel.getList', {
                    type: 'channel.getList'
                  });

                case 19:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5, this);
        }));

        function queryChannels(_x4) {
          return _queryChannels.apply(this, arguments);
        }

        return queryChannels;
      }()
    }, {
      key: "updateChannels",
      value: function () {
        var _updateChannels = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(params) {
          var topic, topic_type, _this$_keys3, userid, PrivateKey, timestamp, signContent, web3mq_signature, data;

          return _regeneratorRuntime().wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  topic = params.topic, topic_type = params.topic_type;
                  _this$_keys3 = this._keys, userid = _this$_keys3.userid, PrivateKey = _this$_keys3.PrivateKey;
                  timestamp = Date.now();
                  signContent = userid + topic + topic_type + timestamp;
                  _context6.next = 6;
                  return getDataSignature(PrivateKey, signContent);

                case 6:
                  web3mq_signature = _context6.sent;
                  _context6.next = 9;
                  return updateRoomListRequest(_objectSpread2({
                    userid: userid,
                    web3mq_signature: web3mq_signature,
                    timestamp: timestamp
                  }, params));

                case 9:
                  data = _context6.sent;
                  return _context6.abrupt("return", data);

                case 11:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6, this);
        }));

        function updateChannels(_x6) {
          return _updateChannels.apply(this, arguments);
        }

        return updateChannels;
      }()
    }, {
      key: "createRoom",
      value: function () {
        var _createRoom = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(params) {
          var _params$groupid, groupid, _this$_keys4, userid, PrivateKey, timestamp, signContent, web3mq_signature, _yield$createRoomRequ, _yield$createRoomRequ2, data;

          return _regeneratorRuntime().wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  _params$groupid = params.groupid, groupid = _params$groupid === void 0 ? '' : _params$groupid;
                  _this$_keys4 = this._keys, userid = _this$_keys4.userid, PrivateKey = _this$_keys4.PrivateKey;
                  timestamp = Date.now();
                  signContent = userid + groupid + timestamp;
                  _context7.next = 6;
                  return getDataSignature(PrivateKey, signContent);

                case 6:
                  web3mq_signature = _context7.sent;
                  _context7.next = 9;
                  return createRoomRequest(_objectSpread2({
                    web3mq_signature: web3mq_signature,
                    userid: userid,
                    timestamp: timestamp
                  }, params));

                case 9:
                  _yield$createRoomRequ = _context7.sent;
                  _yield$createRoomRequ2 = _yield$createRoomRequ.data;
                  data = _yield$createRoomRequ2 === void 0 ? {
                    groupid: '',
                    group_name: '',
                    avatar_base64: '',
                    avatar_url: ''
                  } : _yield$createRoomRequ2;

                  if (this.channelList) {
                    _context7.next = 14;
                    break;
                  }

                  return _context7.abrupt("return");

                case 14:
                  this.channelList = [{
                    chatid: data.groupid,
                    chat_type: 'group',
                    chat_name: data.group_name,
                    avatar_base64: data.avatar_base64,
                    avatar_url: data.avatar_url
                  }].concat(_toConsumableArray(this.channelList));

                  this._client.emit('channel.getList', {
                    type: 'channel.getList'
                  });

                case 16:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7, this);
        }));

        function createRoom(_x7) {
          return _createRoom.apply(this, arguments);
        }

        return createRoom;
      }() // async updateRoom(topic: string, topic_type: string) {
      //   const { userid, PrivateKey } = this._keys;
      //   const timestamp = Date.now();
      //   const signContent = userid + timestamp;
      //   const web3mq_signature = await getDataSignature(PrivateKey, signContent);
      //   const data = await updateRoomListRequest({
      //     userid,
      //     timestamp,
      //     web3mq_signature,
      //     topic,
      //     topic_type,
      //   });
      //   return data;
      // }

    }, {
      key: "getGroupMemberList",
      value: function () {
        var _getGroupMemberList = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(option) {
          var _this$activeChannel2;

          var groupid, _this$_keys5, userid, PrivateKey, timestamp, signContent, web3mq_signature, data;

          return _regeneratorRuntime().wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  groupid = (_this$activeChannel2 = this.activeChannel) === null || _this$activeChannel2 === void 0 ? void 0 : _this$activeChannel2.chatid;

                  if (!groupid) {
                    _context8.next = 12;
                    break;
                  }

                  _this$_keys5 = this._keys, userid = _this$_keys5.userid, PrivateKey = _this$_keys5.PrivateKey;
                  timestamp = Date.now();
                  signContent = userid + groupid + timestamp;
                  _context8.next = 7;
                  return getDataSignature(PrivateKey, signContent);

                case 7:
                  web3mq_signature = _context8.sent;
                  _context8.next = 10;
                  return getGroupMemberListRequest(_objectSpread2({
                    web3mq_signature: web3mq_signature,
                    userid: userid,
                    timestamp: timestamp,
                    groupid: groupid
                  }, option));

                case 10:
                  data = _context8.sent;
                  return _context8.abrupt("return", data);

                case 12:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee8, this);
        }));

        function getGroupMemberList(_x8) {
          return _getGroupMemberList.apply(this, arguments);
        }

        return getGroupMemberList;
      }()
    }, {
      key: "inviteGroupMember",
      value: function () {
        var _inviteGroupMember = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(members) {
          var _this$activeChannel3;

          var groupid, _this$_keys6, userid, PrivateKey, timestamp, signContent, web3mq_signature, data;

          return _regeneratorRuntime().wrap(function _callee9$(_context9) {
            while (1) {
              switch (_context9.prev = _context9.next) {
                case 0:
                  groupid = (_this$activeChannel3 = this.activeChannel) === null || _this$activeChannel3 === void 0 ? void 0 : _this$activeChannel3.chatid;

                  if (!groupid) {
                    _context9.next = 12;
                    break;
                  }

                  _this$_keys6 = this._keys, userid = _this$_keys6.userid, PrivateKey = _this$_keys6.PrivateKey;
                  timestamp = Date.now();
                  signContent = userid + groupid + timestamp;
                  _context9.next = 7;
                  return getDataSignature(PrivateKey, signContent);

                case 7:
                  web3mq_signature = _context9.sent;
                  _context9.next = 10;
                  return inviteGroupMemberRequest({
                    web3mq_signature: web3mq_signature,
                    userid: userid,
                    timestamp: timestamp,
                    groupid: groupid,
                    members: members
                  });

                case 10:
                  data = _context9.sent;
                  return _context9.abrupt("return", data);

                case 12:
                case "end":
                  return _context9.stop();
              }
            }
          }, _callee9, this);
        }));

        function inviteGroupMember(_x9) {
          return _inviteGroupMember.apply(this, arguments);
        }

        return inviteGroupMember;
      }()
    }, {
      key: "joinGroup",
      value: function () {
        var _joinGroup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(groupid) {
          var _this$_keys7, userid, PrivateKey, timestamp, signContent, web3mq_user_signature, _yield$joinGroupReque, data, _data$groupid, group_id, _data$group_name, group_name, _data$avatar_base, avatar_base64, _data$avatar_url, avatar_url;

          return _regeneratorRuntime().wrap(function _callee10$(_context10) {
            while (1) {
              switch (_context10.prev = _context10.next) {
                case 0:
                  _this$_keys7 = this._keys, userid = _this$_keys7.userid, PrivateKey = _this$_keys7.PrivateKey;
                  timestamp = Date.now();
                  signContent = userid + groupid + timestamp;
                  _context10.next = 5;
                  return getDataSignature(PrivateKey, signContent);

                case 5:
                  web3mq_user_signature = _context10.sent;
                  _context10.next = 8;
                  return joinGroupRequest({
                    web3mq_user_signature: web3mq_user_signature,
                    userid: userid,
                    timestamp: timestamp,
                    groupid: groupid
                  });

                case 8:
                  _yield$joinGroupReque = _context10.sent;
                  data = _yield$joinGroupReque.data;

                  if (this.channelList) {
                    _context10.next = 12;
                    break;
                  }

                  return _context10.abrupt("return");

                case 12:
                  if (!this.channelList.find(function (item) {
                    return item.chatid !== groupid;
                  })) {
                    _data$groupid = data.groupid, group_id = _data$groupid === void 0 ? '' : _data$groupid, _data$group_name = data.group_name, group_name = _data$group_name === void 0 ? '' : _data$group_name, _data$avatar_base = data.avatar_base64, avatar_base64 = _data$avatar_base === void 0 ? '' : _data$avatar_base, _data$avatar_url = data.avatar_url, avatar_url = _data$avatar_url === void 0 ? '' : _data$avatar_url;
                    this.channelList = [{
                      chatid: group_id,
                      chat_type: 'group',
                      chat_name: group_name,
                      avatar_base64: avatar_base64,
                      avatar_url: avatar_url
                    }].concat(_toConsumableArray(this.channelList));

                    this._client.emit('channel.getList', {
                      type: 'channel.getList'
                    });
                  }

                case 13:
                case "end":
                  return _context10.stop();
              }
            }
          }, _callee10, this);
        }));

        function joinGroup(_x10) {
          return _joinGroup.apply(this, arguments);
        }

        return joinGroup;
      }()
    }, {
      key: "getGroupPermissions",
      value: function () {
        var _getGroupPermissions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(groupid) {
          var _this$_keys8, userid, PrivateKey, timestamp, signContent, web3mq_user_signature, data;

          return _regeneratorRuntime().wrap(function _callee11$(_context11) {
            while (1) {
              switch (_context11.prev = _context11.next) {
                case 0:
                  _this$_keys8 = this._keys, userid = _this$_keys8.userid, PrivateKey = _this$_keys8.PrivateKey;
                  timestamp = Date.now();
                  signContent = userid + groupid + timestamp;
                  _context11.next = 5;
                  return getDataSignature(PrivateKey, signContent);

                case 5:
                  web3mq_user_signature = _context11.sent;
                  _context11.next = 8;
                  return getGroupPermissionsRequest({
                    web3mq_user_signature: web3mq_user_signature,
                    userid: userid,
                    timestamp: timestamp,
                    groupid: groupid
                  });

                case 8:
                  data = _context11.sent;
                  return _context11.abrupt("return", data);

                case 10:
                case "end":
                  return _context11.stop();
              }
            }
          }, _callee11, this);
        }));

        function getGroupPermissions(_x11) {
          return _getGroupPermissions.apply(this, arguments);
        }

        return getGroupPermissions;
      }()
    }, {
      key: "updateGroupPermissions",
      value: function () {
        var _updateGroupPermissions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(params) {
          var groupid, _this$_keys9, userid, PrivateKey, timestamp, signContent, web3mq_user_signature, data;

          return _regeneratorRuntime().wrap(function _callee12$(_context12) {
            while (1) {
              switch (_context12.prev = _context12.next) {
                case 0:
                  groupid = params.groupid;
                  _this$_keys9 = this._keys, userid = _this$_keys9.userid, PrivateKey = _this$_keys9.PrivateKey;
                  timestamp = Date.now();
                  signContent = userid + groupid + timestamp;
                  _context12.next = 6;
                  return getDataSignature(PrivateKey, signContent);

                case 6:
                  web3mq_user_signature = _context12.sent;
                  _context12.next = 9;
                  return updateGroupPermissionsRequest(_objectSpread2({
                    web3mq_user_signature: web3mq_user_signature,
                    userid: userid,
                    timestamp: timestamp
                  }, params));

                case 9:
                  data = _context12.sent;
                  return _context12.abrupt("return", data);

                case 11:
                case "end":
                  return _context12.stop();
              }
            }
          }, _callee12, this);
        }));

        function updateGroupPermissions(_x12) {
          return _updateGroupPermissions.apply(this, arguments);
        }

        return updateGroupPermissions;
      }()
    }]);

    return Channel;
  }();

  /**
   * Get the type of a JSON value.
   * Distinguishes between array, null and object.
   */
  function typeofJsonValue(value) {
      let t = typeof value;
      if (t == "object") {
          if (Array.isArray(value))
              return "array";
          if (value === null)
              return "null";
      }
      return t;
  }
  /**
   * Is this a JSON object (instead of an array or null)?
   */
  function isJsonObject(value) {
      return value !== null && typeof value == "object" && !Array.isArray(value);
  }

  // lookup table from base64 character to byte
  let encTable = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
  // lookup table from base64 character *code* to byte because lookup by number is fast
  let decTable = [];
  for (let i = 0; i < encTable.length; i++)
      decTable[encTable[i].charCodeAt(0)] = i;
  // support base64url variants
  decTable["-".charCodeAt(0)] = encTable.indexOf("+");
  decTable["_".charCodeAt(0)] = encTable.indexOf("/");
  /**
   * Decodes a base64 string to a byte array.
   *
   * - ignores white-space, including line breaks and tabs
   * - allows inner padding (can decode concatenated base64 strings)
   * - does not require padding
   * - understands base64url encoding:
   *   "-" instead of "+",
   *   "_" instead of "/",
   *   no padding
   */
  function base64decode(base64Str) {
      // estimate byte size, not accounting for inner padding and whitespace
      let es = base64Str.length * 3 / 4;
      // if (es % 3 !== 0)
      // throw new Error('invalid base64 string');
      if (base64Str[base64Str.length - 2] == '=')
          es -= 2;
      else if (base64Str[base64Str.length - 1] == '=')
          es -= 1;
      let bytes = new Uint8Array(es), bytePos = 0, // position in byte array
      groupPos = 0, // position in base64 group
      b, // current byte
      p = 0 // previous byte
      ;
      for (let i = 0; i < base64Str.length; i++) {
          b = decTable[base64Str.charCodeAt(i)];
          if (b === undefined) {
              // noinspection FallThroughInSwitchStatementJS
              switch (base64Str[i]) {
                  case '=':
                      groupPos = 0; // reset state when padding found
                  case '\n':
                  case '\r':
                  case '\t':
                  case ' ':
                      continue; // skip white-space, and padding
                  default:
                      throw Error(`invalid base64 string.`);
              }
          }
          switch (groupPos) {
              case 0:
                  p = b;
                  groupPos = 1;
                  break;
              case 1:
                  bytes[bytePos++] = p << 2 | (b & 48) >> 4;
                  p = b;
                  groupPos = 2;
                  break;
              case 2:
                  bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;
                  p = b;
                  groupPos = 3;
                  break;
              case 3:
                  bytes[bytePos++] = (p & 3) << 6 | b;
                  groupPos = 0;
                  break;
          }
      }
      if (groupPos == 1)
          throw Error(`invalid base64 string.`);
      return bytes.subarray(0, bytePos);
  }
  /**
   * Encodes a byte array to a base64 string.
   * Adds padding at the end.
   * Does not insert newlines.
   */
  function base64encode(bytes) {
      let base64 = '', groupPos = 0, // position in base64 group
      b, // current byte
      p = 0; // carry over from previous byte
      for (let i = 0; i < bytes.length; i++) {
          b = bytes[i];
          switch (groupPos) {
              case 0:
                  base64 += encTable[b >> 2];
                  p = (b & 3) << 4;
                  groupPos = 1;
                  break;
              case 1:
                  base64 += encTable[p | b >> 4];
                  p = (b & 15) << 2;
                  groupPos = 2;
                  break;
              case 2:
                  base64 += encTable[p | b >> 6];
                  base64 += encTable[b & 63];
                  groupPos = 0;
                  break;
          }
      }
      // padding required?
      if (groupPos) {
          base64 += encTable[p];
          base64 += '=';
          if (groupPos == 1)
              base64 += '=';
      }
      return base64;
  }

  /**
   * This handler implements the default behaviour for unknown fields.
   * When reading data, unknown fields are stored on the message, in a
   * symbol property.
   * When writing data, the symbol property is queried and unknown fields
   * are serialized into the output again.
   */
  var UnknownFieldHandler;
  (function (UnknownFieldHandler) {
      /**
       * The symbol used to store unknown fields for a message.
       * The property must conform to `UnknownFieldContainer`.
       */
      UnknownFieldHandler.symbol = Symbol.for("protobuf-ts/unknown");
      /**
       * Store an unknown field during binary read directly on the message.
       * This method is compatible with `BinaryReadOptions.readUnknownField`.
       */
      UnknownFieldHandler.onRead = (typeName, message, fieldNo, wireType, data) => {
          let container = is(message) ? message[UnknownFieldHandler.symbol] : message[UnknownFieldHandler.symbol] = [];
          container.push({ no: fieldNo, wireType, data });
      };
      /**
       * Write unknown fields stored for the message to the writer.
       * This method is compatible with `BinaryWriteOptions.writeUnknownFields`.
       */
      UnknownFieldHandler.onWrite = (typeName, message, writer) => {
          for (let { no, wireType, data } of UnknownFieldHandler.list(message))
              writer.tag(no, wireType).raw(data);
      };
      /**
       * List unknown fields stored for the message.
       * Note that there may be multiples fields with the same number.
       */
      UnknownFieldHandler.list = (message, fieldNo) => {
          if (is(message)) {
              let all = message[UnknownFieldHandler.symbol];
              return fieldNo ? all.filter(uf => uf.no == fieldNo) : all;
          }
          return [];
      };
      /**
       * Returns the last unknown field by field number.
       */
      UnknownFieldHandler.last = (message, fieldNo) => UnknownFieldHandler.list(message, fieldNo).slice(-1)[0];
      const is = (message) => message && Array.isArray(message[UnknownFieldHandler.symbol]);
  })(UnknownFieldHandler || (UnknownFieldHandler = {}));
  /**
   * Protobuf binary format wire types.
   *
   * A wire type provides just enough information to find the length of the
   * following value.
   *
   * See https://developers.google.com/protocol-buffers/docs/encoding#structure
   */
  var WireType;
  (function (WireType) {
      /**
       * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum
       */
      WireType[WireType["Varint"] = 0] = "Varint";
      /**
       * Used for fixed64, sfixed64, double.
       * Always 8 bytes with little-endian byte order.
       */
      WireType[WireType["Bit64"] = 1] = "Bit64";
      /**
       * Used for string, bytes, embedded messages, packed repeated fields
       *
       * Only repeated numeric types (types which use the varint, 32-bit,
       * or 64-bit wire types) can be packed. In proto3, such fields are
       * packed by default.
       */
      WireType[WireType["LengthDelimited"] = 2] = "LengthDelimited";
      /**
       * Used for groups
       * @deprecated
       */
      WireType[WireType["StartGroup"] = 3] = "StartGroup";
      /**
       * Used for groups
       * @deprecated
       */
      WireType[WireType["EndGroup"] = 4] = "EndGroup";
      /**
       * Used for fixed32, sfixed32, float.
       * Always 4 bytes with little-endian byte order.
       */
      WireType[WireType["Bit32"] = 5] = "Bit32";
  })(WireType || (WireType = {}));

  // Copyright 2008 Google Inc.  All rights reserved.
  //
  // Redistribution and use in source and binary forms, with or without
  // modification, are permitted provided that the following conditions are
  // met:
  //
  // * Redistributions of source code must retain the above copyright
  // notice, this list of conditions and the following disclaimer.
  // * Redistributions in binary form must reproduce the above
  // copyright notice, this list of conditions and the following disclaimer
  // in the documentation and/or other materials provided with the
  // distribution.
  // * Neither the name of Google Inc. nor the names of its
  // contributors may be used to endorse or promote products derived from
  // this software without specific prior written permission.
  //
  // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // Code generated by the Protocol Buffer compiler is owned by the owner
  // of the input file used when generating it.  This code is not
  // standalone and requires a support library to be linked with it.  This
  // support library is itself covered by the above license.
  /**
   * Read a 64 bit varint as two JS numbers.
   *
   * Returns tuple:
   * [0]: low bits
   * [0]: high bits
   *
   * Copyright 2008 Google Inc.  All rights reserved.
   *
   * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175
   */
  function varint64read() {
      let lowBits = 0;
      let highBits = 0;
      for (let shift = 0; shift < 28; shift += 7) {
          let b = this.buf[this.pos++];
          lowBits |= (b & 0x7F) << shift;
          if ((b & 0x80) == 0) {
              this.assertBounds();
              return [lowBits, highBits];
          }
      }
      let middleByte = this.buf[this.pos++];
      // last four bits of the first 32 bit number
      lowBits |= (middleByte & 0x0F) << 28;
      // 3 upper bits are part of the next 32 bit number
      highBits = (middleByte & 0x70) >> 4;
      if ((middleByte & 0x80) == 0) {
          this.assertBounds();
          return [lowBits, highBits];
      }
      for (let shift = 3; shift <= 31; shift += 7) {
          let b = this.buf[this.pos++];
          highBits |= (b & 0x7F) << shift;
          if ((b & 0x80) == 0) {
              this.assertBounds();
              return [lowBits, highBits];
          }
      }
      throw new Error('invalid varint');
  }
  /**
   * Write a 64 bit varint, given as two JS numbers, to the given bytes array.
   *
   * Copyright 2008 Google Inc.  All rights reserved.
   *
   * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344
   */
  function varint64write(lo, hi, bytes) {
      for (let i = 0; i < 28; i = i + 7) {
          const shift = lo >>> i;
          const hasNext = !((shift >>> 7) == 0 && hi == 0);
          const byte = (hasNext ? shift | 0x80 : shift) & 0xFF;
          bytes.push(byte);
          if (!hasNext) {
              return;
          }
      }
      const splitBits = ((lo >>> 28) & 0x0F) | ((hi & 0x07) << 4);
      const hasMoreBits = !((hi >> 3) == 0);
      bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xFF);
      if (!hasMoreBits) {
          return;
      }
      for (let i = 3; i < 31; i = i + 7) {
          const shift = hi >>> i;
          const hasNext = !((shift >>> 7) == 0);
          const byte = (hasNext ? shift | 0x80 : shift) & 0xFF;
          bytes.push(byte);
          if (!hasNext) {
              return;
          }
      }
      bytes.push((hi >>> 31) & 0x01);
  }
  // constants for binary math
  const TWO_PWR_32_DBL$1 = (1 << 16) * (1 << 16);
  /**
   * Parse decimal string of 64 bit integer value as two JS numbers.
   *
   * Returns tuple:
   * [0]: minus sign?
   * [1]: low bits
   * [2]: high bits
   *
   * Copyright 2008 Google Inc.
   */
  function int64fromString(dec) {
      // Check for minus sign.
      let minus = dec[0] == '-';
      if (minus)
          dec = dec.slice(1);
      // Work 6 decimal digits at a time, acting like we're converting base 1e6
      // digits to binary. This is safe to do with floating point math because
      // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.
      const base = 1e6;
      let lowBits = 0;
      let highBits = 0;
      function add1e6digit(begin, end) {
          // Note: Number('') is 0.
          const digit1e6 = Number(dec.slice(begin, end));
          highBits *= base;
          lowBits = lowBits * base + digit1e6;
          // Carry bits from lowBits to
          if (lowBits >= TWO_PWR_32_DBL$1) {
              highBits = highBits + ((lowBits / TWO_PWR_32_DBL$1) | 0);
              lowBits = lowBits % TWO_PWR_32_DBL$1;
          }
      }
      add1e6digit(-24, -18);
      add1e6digit(-18, -12);
      add1e6digit(-12, -6);
      add1e6digit(-6);
      return [minus, lowBits, highBits];
  }
  /**
   * Format 64 bit integer value (as two JS numbers) to decimal string.
   *
   * Copyright 2008 Google Inc.
   */
  function int64toString(bitsLow, bitsHigh) {
      // Skip the expensive conversion if the number is small enough to use the
      // built-in conversions.
      if (bitsHigh <= 0x1FFFFF) {
          return '' + (TWO_PWR_32_DBL$1 * bitsHigh + bitsLow);
      }
      // What this code is doing is essentially converting the input number from
      // base-2 to base-1e7, which allows us to represent the 64-bit range with
      // only 3 (very large) digits. Those digits are then trivial to convert to
      // a base-10 string.
      // The magic numbers used here are -
      // 2^24 = 16777216 = (1,6777216) in base-1e7.
      // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.
      // Split 32:32 representation into 16:24:24 representation so our
      // intermediate digits don't overflow.
      let low = bitsLow & 0xFFFFFF;
      let mid = (((bitsLow >>> 24) | (bitsHigh << 8)) >>> 0) & 0xFFFFFF;
      let high = (bitsHigh >> 16) & 0xFFFF;
      // Assemble our three base-1e7 digits, ignoring carries. The maximum
      // value in a digit at this step is representable as a 48-bit integer, which
      // can be stored in a 64-bit floating point number.
      let digitA = low + (mid * 6777216) + (high * 6710656);
      let digitB = mid + (high * 8147497);
      let digitC = (high * 2);
      // Apply carries from A to B and from B to C.
      let base = 10000000;
      if (digitA >= base) {
          digitB += Math.floor(digitA / base);
          digitA %= base;
      }
      if (digitB >= base) {
          digitC += Math.floor(digitB / base);
          digitB %= base;
      }
      // Convert base-1e7 digits to base-10, with optional leading zeroes.
      function decimalFrom1e7(digit1e7, needLeadingZeros) {
          let partial = digit1e7 ? String(digit1e7) : '';
          if (needLeadingZeros) {
              return '0000000'.slice(partial.length) + partial;
          }
          return partial;
      }
      return decimalFrom1e7(digitC, /*needLeadingZeros=*/ 0) +
          decimalFrom1e7(digitB, /*needLeadingZeros=*/ digitC) +
          // If the final 1e7 digit didn't need leading zeros, we would have
          // returned via the trivial code path at the top.
          decimalFrom1e7(digitA, /*needLeadingZeros=*/ 1);
  }
  /**
   * Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`
   *
   * Copyright 2008 Google Inc.  All rights reserved.
   *
   * See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144
   */
  function varint32write(value, bytes) {
      if (value >= 0) {
          // write value as varint 32
          while (value > 0x7f) {
              bytes.push((value & 0x7f) | 0x80);
              value = value >>> 7;
          }
          bytes.push(value);
      }
      else {
          for (let i = 0; i < 9; i++) {
              bytes.push(value & 127 | 128);
              value = value >> 7;
          }
          bytes.push(1);
      }
  }
  /**
   * Read an unsigned 32 bit varint.
   *
   * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220
   */
  function varint32read() {
      let b = this.buf[this.pos++];
      let result = b & 0x7F;
      if ((b & 0x80) == 0) {
          this.assertBounds();
          return result;
      }
      b = this.buf[this.pos++];
      result |= (b & 0x7F) << 7;
      if ((b & 0x80) == 0) {
          this.assertBounds();
          return result;
      }
      b = this.buf[this.pos++];
      result |= (b & 0x7F) << 14;
      if ((b & 0x80) == 0) {
          this.assertBounds();
          return result;
      }
      b = this.buf[this.pos++];
      result |= (b & 0x7F) << 21;
      if ((b & 0x80) == 0) {
          this.assertBounds();
          return result;
      }
      // Extract only last 4 bits
      b = this.buf[this.pos++];
      result |= (b & 0x0F) << 28;
      for (let readBytes = 5; ((b & 0x80) !== 0) && readBytes < 10; readBytes++)
          b = this.buf[this.pos++];
      if ((b & 0x80) != 0)
          throw new Error('invalid varint');
      this.assertBounds();
      // Result can have 32 bits, convert it to unsigned
      return result >>> 0;
  }

  function detectBi() {
      const dv = new DataView(new ArrayBuffer(8));
      const ok = globalThis.BigInt !== undefined
          && typeof dv.getBigInt64 === "function"
          && typeof dv.getBigUint64 === "function"
          && typeof dv.setBigInt64 === "function"
          && typeof dv.setBigUint64 === "function";
      return ok ? {
          MIN: BigInt("-9223372036854775808"),
          MAX: BigInt("9223372036854775807"),
          UMIN: BigInt("0"),
          UMAX: BigInt("18446744073709551615"),
          C: BigInt,
          V: dv,
      } : undefined;
  }
  const BI = detectBi();
  function assertBi(bi) {
      if (!bi)
          throw new Error("BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support");
  }
  // used to validate from(string) input (when bigint is unavailable)
  const RE_DECIMAL_STR = /^-?[0-9]+$/;
  // constants for binary math
  const TWO_PWR_32_DBL = (1 << 16) * (1 << 16);
  // base class for PbLong and PbULong provides shared code
  class SharedPbLong {
      /**
       * Create a new instance with the given bits.
       */
      constructor(lo, hi) {
          this.lo = lo | 0;
          this.hi = hi | 0;
      }
      /**
       * Is this instance equal to 0?
       */
      isZero() {
          return this.lo == 0 && this.hi == 0;
      }
      /**
       * Convert to a native number.
       */
      toNumber() {
          let result = this.hi * TWO_PWR_32_DBL + (this.lo >>> 0);
          if (!Number.isSafeInteger(result))
              throw new Error("cannot convert to safe number");
          return result;
      }
  }
  /**
   * 64-bit unsigned integer as two 32-bit values.
   * Converts between `string`, `number` and `bigint` representations.
   */
  class PbULong extends SharedPbLong {
      /**
       * Create instance from a `string`, `number` or `bigint`.
       */
      static from(value) {
          if (BI)
              // noinspection FallThroughInSwitchStatementJS
              switch (typeof value) {
                  case "string":
                      if (value == "0")
                          return this.ZERO;
                      if (value == "")
                          throw new Error('string is no integer');
                      value = BI.C(value);
                  case "number":
                      if (value === 0)
                          return this.ZERO;
                      value = BI.C(value);
                  case "bigint":
                      if (!value)
                          return this.ZERO;
                      if (value < BI.UMIN)
                          throw new Error('signed value for ulong');
                      if (value > BI.UMAX)
                          throw new Error('ulong too large');
                      BI.V.setBigUint64(0, value, true);
                      return new PbULong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
              }
          else
              switch (typeof value) {
                  case "string":
                      if (value == "0")
                          return this.ZERO;
                      value = value.trim();
                      if (!RE_DECIMAL_STR.test(value))
                          throw new Error('string is no integer');
                      let [minus, lo, hi] = int64fromString(value);
                      if (minus)
                          throw new Error('signed value');
                      return new PbULong(lo, hi);
                  case "number":
                      if (value == 0)
                          return this.ZERO;
                      if (!Number.isSafeInteger(value))
                          throw new Error('number is no integer');
                      if (value < 0)
                          throw new Error('signed value for ulong');
                      return new PbULong(value, value / TWO_PWR_32_DBL);
              }
          throw new Error('unknown value ' + typeof value);
      }
      /**
       * Convert to decimal string.
       */
      toString() {
          return BI ? this.toBigInt().toString() : int64toString(this.lo, this.hi);
      }
      /**
       * Convert to native bigint.
       */
      toBigInt() {
          assertBi(BI);
          BI.V.setInt32(0, this.lo, true);
          BI.V.setInt32(4, this.hi, true);
          return BI.V.getBigUint64(0, true);
      }
  }
  /**
   * ulong 0 singleton.
   */
  PbULong.ZERO = new PbULong(0, 0);
  /**
   * 64-bit signed integer as two 32-bit values.
   * Converts between `string`, `number` and `bigint` representations.
   */
  class PbLong extends SharedPbLong {
      /**
       * Create instance from a `string`, `number` or `bigint`.
       */
      static from(value) {
          if (BI)
              // noinspection FallThroughInSwitchStatementJS
              switch (typeof value) {
                  case "string":
                      if (value == "0")
                          return this.ZERO;
                      if (value == "")
                          throw new Error('string is no integer');
                      value = BI.C(value);
                  case "number":
                      if (value === 0)
                          return this.ZERO;
                      value = BI.C(value);
                  case "bigint":
                      if (!value)
                          return this.ZERO;
                      if (value < BI.MIN)
                          throw new Error('ulong too small');
                      if (value > BI.MAX)
                          throw new Error('ulong too large');
                      BI.V.setBigInt64(0, value, true);
                      return new PbLong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
              }
          else
              switch (typeof value) {
                  case "string":
                      if (value == "0")
                          return this.ZERO;
                      value = value.trim();
                      if (!RE_DECIMAL_STR.test(value))
                          throw new Error('string is no integer');
                      let [minus, lo, hi] = int64fromString(value);
                      let pbl = new PbLong(lo, hi);
                      return minus ? pbl.negate() : pbl;
                  case "number":
                      if (value == 0)
                          return this.ZERO;
                      if (!Number.isSafeInteger(value))
                          throw new Error('number is no integer');
                      return value > 0
                          ? new PbLong(value, value / TWO_PWR_32_DBL)
                          : new PbLong(-value, -value / TWO_PWR_32_DBL).negate();
              }
          throw new Error('unknown value ' + typeof value);
      }
      /**
       * Do we have a minus sign?
       */
      isNegative() {
          return (this.hi & 0x80000000) !== 0;
      }
      /**
       * Negate two's complement.
       * Invert all the bits and add one to the result.
       */
      negate() {
          let hi = ~this.hi, lo = this.lo;
          if (lo)
              lo = ~lo + 1;
          else
              hi += 1;
          return new PbLong(lo, hi);
      }
      /**
       * Convert to decimal string.
       */
      toString() {
          if (BI)
              return this.toBigInt().toString();
          if (this.isNegative()) {
              let n = this.negate();
              return '-' + int64toString(n.lo, n.hi);
          }
          return int64toString(this.lo, this.hi);
      }
      /**
       * Convert to native bigint.
       */
      toBigInt() {
          assertBi(BI);
          BI.V.setInt32(0, this.lo, true);
          BI.V.setInt32(4, this.hi, true);
          return BI.V.getBigInt64(0, true);
      }
  }
  /**
   * long 0 singleton.
   */
  PbLong.ZERO = new PbLong(0, 0);

  const defaultsRead$1 = {
      readUnknownField: true,
      readerFactory: bytes => new BinaryReader(bytes),
  };
  /**
   * Make options for reading binary data form partial options.
   */
  function binaryReadOptions(options) {
      return options ? Object.assign(Object.assign({}, defaultsRead$1), options) : defaultsRead$1;
  }
  class BinaryReader {
      constructor(buf, textDecoder) {
          this.varint64 = varint64read; // dirty cast for `this`
          /**
           * Read a `uint32` field, an unsigned 32 bit varint.
           */
          this.uint32 = varint32read; // dirty cast for `this` and access to protected `buf`
          this.buf = buf;
          this.len = buf.length;
          this.pos = 0;
          this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
          this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder("utf-8", {
              fatal: true
          });
      }
      /**
       * Reads a tag - field number and wire type.
       */
      tag() {
          let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
          if (fieldNo <= 0 || wireType < 0 || wireType > 5)
              throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
          return [fieldNo, wireType];
      }
      /**
       * Skip one element on the wire and return the skipped data.
       * Supports WireType.StartGroup since v2.0.0-alpha.23.
       */
      skip(wireType) {
          let start = this.pos;
          // noinspection FallThroughInSwitchStatementJS
          switch (wireType) {
              case WireType.Varint:
                  while (this.buf[this.pos++] & 0x80) {
                      // ignore
                  }
                  break;
              case WireType.Bit64:
                  this.pos += 4;
              case WireType.Bit32:
                  this.pos += 4;
                  break;
              case WireType.LengthDelimited:
                  let len = this.uint32();
                  this.pos += len;
                  break;
              case WireType.StartGroup:
                  // From descriptor.proto: Group type is deprecated, not supported in proto3.
                  // But we must still be able to parse and treat as unknown.
                  let t;
                  while ((t = this.tag()[1]) !== WireType.EndGroup) {
                      this.skip(t);
                  }
                  break;
              default:
                  throw new Error("cant skip wire type " + wireType);
          }
          this.assertBounds();
          return this.buf.subarray(start, this.pos);
      }
      /**
       * Throws error if position in byte array is out of range.
       */
      assertBounds() {
          if (this.pos > this.len)
              throw new RangeError("premature EOF");
      }
      /**
       * Read a `int32` field, a signed 32 bit varint.
       */
      int32() {
          return this.uint32() | 0;
      }
      /**
       * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
       */
      sint32() {
          let zze = this.uint32();
          // decode zigzag
          return (zze >>> 1) ^ -(zze & 1);
      }
      /**
       * Read a `int64` field, a signed 64-bit varint.
       */
      int64() {
          return new PbLong(...this.varint64());
      }
      /**
       * Read a `uint64` field, an unsigned 64-bit varint.
       */
      uint64() {
          return new PbULong(...this.varint64());
      }
      /**
       * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
       */
      sint64() {
          let [lo, hi] = this.varint64();
          // decode zig zag
          let s = -(lo & 1);
          lo = ((lo >>> 1 | (hi & 1) << 31) ^ s);
          hi = (hi >>> 1 ^ s);
          return new PbLong(lo, hi);
      }
      /**
       * Read a `bool` field, a variant.
       */
      bool() {
          let [lo, hi] = this.varint64();
          return lo !== 0 || hi !== 0;
      }
      /**
       * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
       */
      fixed32() {
          return this.view.getUint32((this.pos += 4) - 4, true);
      }
      /**
       * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
       */
      sfixed32() {
          return this.view.getInt32((this.pos += 4) - 4, true);
      }
      /**
       * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
       */
      fixed64() {
          return new PbULong(this.sfixed32(), this.sfixed32());
      }
      /**
       * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
       */
      sfixed64() {
          return new PbLong(this.sfixed32(), this.sfixed32());
      }
      /**
       * Read a `float` field, 32-bit floating point number.
       */
      float() {
          return this.view.getFloat32((this.pos += 4) - 4, true);
      }
      /**
       * Read a `double` field, a 64-bit floating point number.
       */
      double() {
          return this.view.getFloat64((this.pos += 8) - 8, true);
      }
      /**
       * Read a `bytes` field, length-delimited arbitrary data.
       */
      bytes() {
          let len = this.uint32();
          let start = this.pos;
          this.pos += len;
          this.assertBounds();
          return this.buf.subarray(start, start + len);
      }
      /**
       * Read a `string` field, length-delimited data converted to UTF-8 text.
       */
      string() {
          return this.textDecoder.decode(this.bytes());
      }
  }

  /**
   * assert that condition is true or throw error (with message)
   */
  function assert(condition, msg) {
      if (!condition) {
          throw new Error(msg);
      }
  }
  const FLOAT32_MAX = 3.4028234663852886e+38, FLOAT32_MIN = -3.4028234663852886e+38, UINT32_MAX = 0xFFFFFFFF, INT32_MAX = 0X7FFFFFFF, INT32_MIN = -0X80000000;
  function assertInt32(arg) {
      if (typeof arg !== "number")
          throw new Error('invalid int 32: ' + typeof arg);
      if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
          throw new Error('invalid int 32: ' + arg);
  }
  function assertUInt32(arg) {
      if (typeof arg !== "number")
          throw new Error('invalid uint 32: ' + typeof arg);
      if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
          throw new Error('invalid uint 32: ' + arg);
  }
  function assertFloat32(arg) {
      if (typeof arg !== "number")
          throw new Error('invalid float 32: ' + typeof arg);
      if (!Number.isFinite(arg))
          return;
      if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
          throw new Error('invalid float 32: ' + arg);
  }

  const defaultsWrite$1 = {
      writeUnknownFields: true,
      writerFactory: () => new BinaryWriter(),
  };
  /**
   * Make options for writing binary data form partial options.
   */
  function binaryWriteOptions(options) {
      return options ? Object.assign(Object.assign({}, defaultsWrite$1), options) : defaultsWrite$1;
  }
  class BinaryWriter {
      constructor(textEncoder) {
          /**
           * Previous fork states.
           */
          this.stack = [];
          this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
          this.chunks = [];
          this.buf = [];
      }
      /**
       * Return all bytes written and reset this writer.
       */
      finish() {
          this.chunks.push(new Uint8Array(this.buf)); // flush the buffer
          let len = 0;
          for (let i = 0; i < this.chunks.length; i++)
              len += this.chunks[i].length;
          let bytes = new Uint8Array(len);
          let offset = 0;
          for (let i = 0; i < this.chunks.length; i++) {
              bytes.set(this.chunks[i], offset);
              offset += this.chunks[i].length;
          }
          this.chunks = [];
          return bytes;
      }
      /**
       * Start a new fork for length-delimited data like a message
       * or a packed repeated field.
       *
       * Must be joined later with `join()`.
       */
      fork() {
          this.stack.push({ chunks: this.chunks, buf: this.buf });
          this.chunks = [];
          this.buf = [];
          return this;
      }
      /**
       * Join the last fork. Write its length and bytes, then
       * return to the previous state.
       */
      join() {
          // get chunk of fork
          let chunk = this.finish();
          // restore previous state
          let prev = this.stack.pop();
          if (!prev)
              throw new Error('invalid state, fork stack empty');
          this.chunks = prev.chunks;
          this.buf = prev.buf;
          // write length of chunk as varint
          this.uint32(chunk.byteLength);
          return this.raw(chunk);
      }
      /**
       * Writes a tag (field number and wire type).
       *
       * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
       *
       * Generated code should compute the tag ahead of time and call `uint32()`.
       */
      tag(fieldNo, type) {
          return this.uint32((fieldNo << 3 | type) >>> 0);
      }
      /**
       * Write a chunk of raw bytes.
       */
      raw(chunk) {
          if (this.buf.length) {
              this.chunks.push(new Uint8Array(this.buf));
              this.buf = [];
          }
          this.chunks.push(chunk);
          return this;
      }
      /**
       * Write a `uint32` value, an unsigned 32 bit varint.
       */
      uint32(value) {
          assertUInt32(value);
          // write value as varint 32, inlined for speed
          while (value > 0x7f) {
              this.buf.push((value & 0x7f) | 0x80);
              value = value >>> 7;
          }
          this.buf.push(value);
          return this;
      }
      /**
       * Write a `int32` value, a signed 32 bit varint.
       */
      int32(value) {
          assertInt32(value);
          varint32write(value, this.buf);
          return this;
      }
      /**
       * Write a `bool` value, a variant.
       */
      bool(value) {
          this.buf.push(value ? 1 : 0);
          return this;
      }
      /**
       * Write a `bytes` value, length-delimited arbitrary data.
       */
      bytes(value) {
          this.uint32(value.byteLength); // write length of chunk as varint
          return this.raw(value);
      }
      /**
       * Write a `string` value, length-delimited data converted to UTF-8 text.
       */
      string(value) {
          let chunk = this.textEncoder.encode(value);
          this.uint32(chunk.byteLength); // write length of chunk as varint
          return this.raw(chunk);
      }
      /**
       * Write a `float` value, 32-bit floating point number.
       */
      float(value) {
          assertFloat32(value);
          let chunk = new Uint8Array(4);
          new DataView(chunk.buffer).setFloat32(0, value, true);
          return this.raw(chunk);
      }
      /**
       * Write a `double` value, a 64-bit floating point number.
       */
      double(value) {
          let chunk = new Uint8Array(8);
          new DataView(chunk.buffer).setFloat64(0, value, true);
          return this.raw(chunk);
      }
      /**
       * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
       */
      fixed32(value) {
          assertUInt32(value);
          let chunk = new Uint8Array(4);
          new DataView(chunk.buffer).setUint32(0, value, true);
          return this.raw(chunk);
      }
      /**
       * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
       */
      sfixed32(value) {
          assertInt32(value);
          let chunk = new Uint8Array(4);
          new DataView(chunk.buffer).setInt32(0, value, true);
          return this.raw(chunk);
      }
      /**
       * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
       */
      sint32(value) {
          assertInt32(value);
          // zigzag encode
          value = ((value << 1) ^ (value >> 31)) >>> 0;
          varint32write(value, this.buf);
          return this;
      }
      /**
       * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
       */
      sfixed64(value) {
          let chunk = new Uint8Array(8);
          let view = new DataView(chunk.buffer);
          let long = PbLong.from(value);
          view.setInt32(0, long.lo, true);
          view.setInt32(4, long.hi, true);
          return this.raw(chunk);
      }
      /**
       * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
       */
      fixed64(value) {
          let chunk = new Uint8Array(8);
          let view = new DataView(chunk.buffer);
          let long = PbULong.from(value);
          view.setInt32(0, long.lo, true);
          view.setInt32(4, long.hi, true);
          return this.raw(chunk);
      }
      /**
       * Write a `int64` value, a signed 64-bit varint.
       */
      int64(value) {
          let long = PbLong.from(value);
          varint64write(long.lo, long.hi, this.buf);
          return this;
      }
      /**
       * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
       */
      sint64(value) {
          let long = PbLong.from(value), 
          // zigzag encode
          sign = long.hi >> 31, lo = (long.lo << 1) ^ sign, hi = ((long.hi << 1) | (long.lo >>> 31)) ^ sign;
          varint64write(lo, hi, this.buf);
          return this;
      }
      /**
       * Write a `uint64` value, an unsigned 64-bit varint.
       */
      uint64(value) {
          let long = PbULong.from(value);
          varint64write(long.lo, long.hi, this.buf);
          return this;
      }
  }

  const defaultsWrite = {
      emitDefaultValues: false,
      enumAsInteger: false,
      useProtoFieldName: false,
      prettySpaces: 0,
  }, defaultsRead = {
      ignoreUnknownFields: false,
  };
  /**
   * Make options for reading JSON data from partial options.
   */
  function jsonReadOptions(options) {
      return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
  }
  /**
   * Make options for writing JSON data from partial options.
   */
  function jsonWriteOptions(options) {
      return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
  }

  /**
   * The symbol used as a key on message objects to store the message type.
   *
   * Note that this is an experimental feature - it is here to stay, but
   * implementation details may change without notice.
   */
  const MESSAGE_TYPE = Symbol.for("protobuf-ts/message-type");

  /**
   * Converts snake_case to lowerCamelCase.
   *
   * Should behave like protoc:
   * https://github.com/protocolbuffers/protobuf/blob/e8ae137c96444ea313485ed1118c5e43b2099cf1/src/google/protobuf/compiler/java/java_helpers.cc#L118
   */
  function lowerCamelCase(snakeCase) {
      let capNext = false;
      const sb = [];
      for (let i = 0; i < snakeCase.length; i++) {
          let next = snakeCase.charAt(i);
          if (next == '_') {
              capNext = true;
          }
          else if (/\d/.test(next)) {
              sb.push(next);
              capNext = true;
          }
          else if (capNext) {
              sb.push(next.toUpperCase());
              capNext = false;
          }
          else if (i == 0) {
              sb.push(next.toLowerCase());
          }
          else {
              sb.push(next);
          }
      }
      return sb.join('');
  }

  /**
   * Scalar value types. This is a subset of field types declared by protobuf
   * enum google.protobuf.FieldDescriptorProto.Type The types GROUP and MESSAGE
   * are omitted, but the numerical values are identical.
   */
  var ScalarType;
  (function (ScalarType) {
      // 0 is reserved for errors.
      // Order is weird for historical reasons.
      ScalarType[ScalarType["DOUBLE"] = 1] = "DOUBLE";
      ScalarType[ScalarType["FLOAT"] = 2] = "FLOAT";
      // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
      // negative values are likely.
      ScalarType[ScalarType["INT64"] = 3] = "INT64";
      ScalarType[ScalarType["UINT64"] = 4] = "UINT64";
      // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
      // negative values are likely.
      ScalarType[ScalarType["INT32"] = 5] = "INT32";
      ScalarType[ScalarType["FIXED64"] = 6] = "FIXED64";
      ScalarType[ScalarType["FIXED32"] = 7] = "FIXED32";
      ScalarType[ScalarType["BOOL"] = 8] = "BOOL";
      ScalarType[ScalarType["STRING"] = 9] = "STRING";
      // Tag-delimited aggregate.
      // Group type is deprecated and not supported in proto3. However, Proto3
      // implementations should still be able to parse the group wire format and
      // treat group fields as unknown fields.
      // TYPE_GROUP = 10,
      // TYPE_MESSAGE = 11,  // Length-delimited aggregate.
      // New in version 2.
      ScalarType[ScalarType["BYTES"] = 12] = "BYTES";
      ScalarType[ScalarType["UINT32"] = 13] = "UINT32";
      // TYPE_ENUM = 14,
      ScalarType[ScalarType["SFIXED32"] = 15] = "SFIXED32";
      ScalarType[ScalarType["SFIXED64"] = 16] = "SFIXED64";
      ScalarType[ScalarType["SINT32"] = 17] = "SINT32";
      ScalarType[ScalarType["SINT64"] = 18] = "SINT64";
  })(ScalarType || (ScalarType = {}));
  /**
   * JavaScript representation of 64 bit integral types. Equivalent to the
   * field option "jstype".
   *
   * By default, protobuf-ts represents 64 bit types as `bigint`.
   *
   * You can change the default behaviour by enabling the plugin parameter
   * `long_type_string`, which will represent 64 bit types as `string`.
   *
   * Alternatively, you can change the behaviour for individual fields
   * with the field option "jstype":
   *
   * ```protobuf
   * uint64 my_field = 1 [jstype = JS_STRING];
   * uint64 other_field = 2 [jstype = JS_NUMBER];
   * ```
   */
  var LongType;
  (function (LongType) {
      /**
       * Use JavaScript `bigint`.
       *
       * Field option `[jstype = JS_NORMAL]`.
       */
      LongType[LongType["BIGINT"] = 0] = "BIGINT";
      /**
       * Use JavaScript `string`.
       *
       * Field option `[jstype = JS_STRING]`.
       */
      LongType[LongType["STRING"] = 1] = "STRING";
      /**
       * Use JavaScript `number`.
       *
       * Large values will loose precision.
       *
       * Field option `[jstype = JS_NUMBER]`.
       */
      LongType[LongType["NUMBER"] = 2] = "NUMBER";
  })(LongType || (LongType = {}));
  /**
   * Protobuf 2.1.0 introduced packed repeated fields.
   * Setting the field option `[packed = true]` enables packing.
   *
   * In proto3, all repeated fields are packed by default.
   * Setting the field option `[packed = false]` disables packing.
   *
   * Packed repeated fields are encoded with a single tag,
   * then a length-delimiter, then the element values.
   *
   * Unpacked repeated fields are encoded with a tag and
   * value for each element.
   *
   * `bytes` and `string` cannot be packed.
   */
  var RepeatType;
  (function (RepeatType) {
      /**
       * The field is not repeated.
       */
      RepeatType[RepeatType["NO"] = 0] = "NO";
      /**
       * The field is repeated and should be packed.
       * Invalid for `bytes` and `string`, they cannot be packed.
       */
      RepeatType[RepeatType["PACKED"] = 1] = "PACKED";
      /**
       * The field is repeated but should not be packed.
       * The only valid repeat type for repeated `bytes` and `string`.
       */
      RepeatType[RepeatType["UNPACKED"] = 2] = "UNPACKED";
  })(RepeatType || (RepeatType = {}));
  /**
   * Turns PartialFieldInfo into FieldInfo.
   */
  function normalizeFieldInfo(field) {
      var _a, _b, _c, _d;
      field.localName = (_a = field.localName) !== null && _a !== void 0 ? _a : lowerCamelCase(field.name);
      field.jsonName = (_b = field.jsonName) !== null && _b !== void 0 ? _b : lowerCamelCase(field.name);
      field.repeat = (_c = field.repeat) !== null && _c !== void 0 ? _c : RepeatType.NO;
      field.opt = (_d = field.opt) !== null && _d !== void 0 ? _d : (field.repeat ? false : field.oneof ? false : field.kind == "message");
      return field;
  }

  /**
   * Is the given value a valid oneof group?
   *
   * We represent protobuf `oneof` as algebraic data types (ADT) in generated
   * code. But when working with messages of unknown type, the ADT does not
   * help us.
   *
   * This type guard checks if the given object adheres to the ADT rules, which
   * are as follows:
   *
   * 1) Must be an object.
   *
   * 2) Must have a "oneofKind" discriminator property.
   *
   * 3) If "oneofKind" is `undefined`, no member field is selected. The object
   * must not have any other properties.
   *
   * 4) If "oneofKind" is a `string`, the member field with this name is
   * selected.
   *
   * 5) If a member field is selected, the object must have a second property
   * with this name. The property must not be `undefined`.
   *
   * 6) No extra properties are allowed. The object has either one property
   * (no selection) or two properties (selection).
   *
   */
  function isOneofGroup(any) {
      if (typeof any != 'object' || any === null || !any.hasOwnProperty('oneofKind')) {
          return false;
      }
      switch (typeof any.oneofKind) {
          case "string":
              if (any[any.oneofKind] === undefined)
                  return false;
              return Object.keys(any).length == 2;
          case "undefined":
              return Object.keys(any).length == 1;
          default:
              return false;
      }
  }

  // noinspection JSMethodCanBeStatic
  class ReflectionTypeCheck {
      constructor(info) {
          var _a;
          this.fields = (_a = info.fields) !== null && _a !== void 0 ? _a : [];
      }
      prepare() {
          if (this.data)
              return;
          const req = [], known = [], oneofs = [];
          for (let field of this.fields) {
              if (field.oneof) {
                  if (!oneofs.includes(field.oneof)) {
                      oneofs.push(field.oneof);
                      req.push(field.oneof);
                      known.push(field.oneof);
                  }
              }
              else {
                  known.push(field.localName);
                  switch (field.kind) {
                      case "scalar":
                      case "enum":
                          if (!field.opt || field.repeat)
                              req.push(field.localName);
                          break;
                      case "message":
                          if (field.repeat)
                              req.push(field.localName);
                          break;
                      case "map":
                          req.push(field.localName);
                          break;
                  }
              }
          }
          this.data = { req, known, oneofs: Object.values(oneofs) };
      }
      /**
       * Is the argument a valid message as specified by the
       * reflection information?
       *
       * Checks all field types recursively. The `depth`
       * specifies how deep into the structure the check will be.
       *
       * With a depth of 0, only the presence of fields
       * is checked.
       *
       * With a depth of 1 or more, the field types are checked.
       *
       * With a depth of 2 or more, the members of map, repeated
       * and message fields are checked.
       *
       * Message fields will be checked recursively with depth - 1.
       *
       * The number of map entries / repeated values being checked
       * is < depth.
       */
      is(message, depth, allowExcessProperties = false) {
          if (depth < 0)
              return true;
          if (message === null || message === undefined || typeof message != 'object')
              return false;
          this.prepare();
          let keys = Object.keys(message), data = this.data;
          // if a required field is missing in arg, this cannot be a T
          if (keys.length < data.req.length || data.req.some(n => !keys.includes(n)))
              return false;
          if (!allowExcessProperties) {
              // if the arg contains a key we dont know, this is not a literal T
              if (keys.some(k => !data.known.includes(k)))
                  return false;
          }
          // "With a depth of 0, only the presence and absence of fields is checked."
          // "With a depth of 1 or more, the field types are checked."
          if (depth < 1) {
              return true;
          }
          // check oneof group
          for (const name of data.oneofs) {
              const group = message[name];
              if (!isOneofGroup(group))
                  return false;
              if (group.oneofKind === undefined)
                  continue;
              const field = this.fields.find(f => f.localName === group.oneofKind);
              if (!field)
                  return false; // we found no field, but have a kind, something is wrong
              if (!this.field(group[group.oneofKind], field, allowExcessProperties, depth))
                  return false;
          }
          // check types
          for (const field of this.fields) {
              if (field.oneof !== undefined)
                  continue;
              if (!this.field(message[field.localName], field, allowExcessProperties, depth))
                  return false;
          }
          return true;
      }
      field(arg, field, allowExcessProperties, depth) {
          let repeated = field.repeat;
          switch (field.kind) {
              case "scalar":
                  if (arg === undefined)
                      return field.opt;
                  if (repeated)
                      return this.scalars(arg, field.T, depth, field.L);
                  return this.scalar(arg, field.T, field.L);
              case "enum":
                  if (arg === undefined)
                      return field.opt;
                  if (repeated)
                      return this.scalars(arg, ScalarType.INT32, depth);
                  return this.scalar(arg, ScalarType.INT32);
              case "message":
                  if (arg === undefined)
                      return true;
                  if (repeated)
                      return this.messages(arg, field.T(), allowExcessProperties, depth);
                  return this.message(arg, field.T(), allowExcessProperties, depth);
              case "map":
                  if (typeof arg != 'object' || arg === null)
                      return false;
                  if (depth < 2)
                      return true;
                  if (!this.mapKeys(arg, field.K, depth))
                      return false;
                  switch (field.V.kind) {
                      case "scalar":
                          return this.scalars(Object.values(arg), field.V.T, depth, field.V.L);
                      case "enum":
                          return this.scalars(Object.values(arg), ScalarType.INT32, depth);
                      case "message":
                          return this.messages(Object.values(arg), field.V.T(), allowExcessProperties, depth);
                  }
                  break;
          }
          return true;
      }
      message(arg, type, allowExcessProperties, depth) {
          if (allowExcessProperties) {
              return type.isAssignable(arg, depth);
          }
          return type.is(arg, depth);
      }
      messages(arg, type, allowExcessProperties, depth) {
          if (!Array.isArray(arg))
              return false;
          if (depth < 2)
              return true;
          if (allowExcessProperties) {
              for (let i = 0; i < arg.length && i < depth; i++)
                  if (!type.isAssignable(arg[i], depth - 1))
                      return false;
          }
          else {
              for (let i = 0; i < arg.length && i < depth; i++)
                  if (!type.is(arg[i], depth - 1))
                      return false;
          }
          return true;
      }
      scalar(arg, type, longType) {
          let argType = typeof arg;
          switch (type) {
              case ScalarType.UINT64:
              case ScalarType.FIXED64:
              case ScalarType.INT64:
              case ScalarType.SFIXED64:
              case ScalarType.SINT64:
                  switch (longType) {
                      case LongType.BIGINT:
                          return argType == "bigint";
                      case LongType.NUMBER:
                          return argType == "number" && !isNaN(arg);
                      default:
                          return argType == "string";
                  }
              case ScalarType.BOOL:
                  return argType == 'boolean';
              case ScalarType.STRING:
                  return argType == 'string';
              case ScalarType.BYTES:
                  return arg instanceof Uint8Array;
              case ScalarType.DOUBLE:
              case ScalarType.FLOAT:
                  return argType == 'number' && !isNaN(arg);
              default:
                  // case ScalarType.UINT32:
                  // case ScalarType.FIXED32:
                  // case ScalarType.INT32:
                  // case ScalarType.SINT32:
                  // case ScalarType.SFIXED32:
                  return argType == 'number' && Number.isInteger(arg);
          }
      }
      scalars(arg, type, depth, longType) {
          if (!Array.isArray(arg))
              return false;
          if (depth < 2)
              return true;
          if (Array.isArray(arg))
              for (let i = 0; i < arg.length && i < depth; i++)
                  if (!this.scalar(arg[i], type, longType))
                      return false;
          return true;
      }
      mapKeys(map, type, depth) {
          let keys = Object.keys(map);
          switch (type) {
              case ScalarType.INT32:
              case ScalarType.FIXED32:
              case ScalarType.SFIXED32:
              case ScalarType.SINT32:
              case ScalarType.UINT32:
                  return this.scalars(keys.slice(0, depth).map(k => parseInt(k)), type, depth);
              case ScalarType.BOOL:
                  return this.scalars(keys.slice(0, depth).map(k => k == 'true' ? true : k == 'false' ? false : k), type, depth);
              default:
                  return this.scalars(keys, type, depth, LongType.STRING);
          }
      }
  }

  /**
   * Utility method to convert a PbLong or PbUlong to a JavaScript
   * representation during runtime.
   *
   * Works with generated field information, `undefined` is equivalent
   * to `STRING`.
   */
  function reflectionLongConvert(long, type) {
      switch (type) {
          case LongType.BIGINT:
              return long.toBigInt();
          case LongType.NUMBER:
              return long.toNumber();
          default:
              // case undefined:
              // case LongType.STRING:
              return long.toString();
      }
  }

  /**
   * Reads proto3 messages in canonical JSON format using reflection information.
   *
   * https://developers.google.com/protocol-buffers/docs/proto3#json
   */
  class ReflectionJsonReader {
      constructor(info) {
          this.info = info;
      }
      prepare() {
          var _a;
          if (this.fMap === undefined) {
              this.fMap = {};
              const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
              for (const field of fieldsInput) {
                  this.fMap[field.name] = field;
                  this.fMap[field.jsonName] = field;
                  this.fMap[field.localName] = field;
              }
          }
      }
      // Cannot parse JSON <type of jsonValue> for <type name>#<fieldName>.
      assert(condition, fieldName, jsonValue) {
          if (!condition) {
              let what = typeofJsonValue(jsonValue);
              if (what == "number" || what == "boolean")
                  what = jsonValue.toString();
              throw new Error(`Cannot parse JSON ${what} for ${this.info.typeName}#${fieldName}`);
          }
      }
      /**
       * Reads a message from canonical JSON format into the target message.
       *
       * Repeated fields are appended. Map entries are added, overwriting
       * existing keys.
       *
       * If a message field is already present, it will be merged with the
       * new data.
       */
      read(input, message, options) {
          this.prepare();
          const oneofsHandled = [];
          for (const [jsonKey, jsonValue] of Object.entries(input)) {
              const field = this.fMap[jsonKey];
              if (!field) {
                  if (!options.ignoreUnknownFields)
                      throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${jsonKey}`);
                  continue;
              }
              const localName = field.localName;
              // handle oneof ADT
              let target; // this will be the target for the field value, whether it is member of a oneof or not
              if (field.oneof) {
                  // since json objects are unordered by specification, it is not possible to take the last of multiple oneofs
                  if (oneofsHandled.includes(field.oneof))
                      throw new Error(`Multiple members of the oneof group "${field.oneof}" of ${this.info.typeName} are present in JSON.`);
                  oneofsHandled.push(field.oneof);
                  target = message[field.oneof] = {
                      oneofKind: localName
                  };
              }
              else {
                  target = message;
              }
              // we have handled oneof above. we just have read the value into `target`.
              if (field.kind == 'map') {
                  if (jsonValue === null) {
                      continue;
                  }
                  // check input
                  this.assert(isJsonObject(jsonValue), field.name, jsonValue);
                  // our target to put map entries into
                  const fieldObj = target[localName];
                  // read entries
                  for (const [jsonObjKey, jsonObjValue] of Object.entries(jsonValue)) {
                      this.assert(jsonObjValue !== null, field.name + " map value", null);
                      // read value
                      let val;
                      switch (field.V.kind) {
                          case "message":
                              val = field.V.T().internalJsonRead(jsonObjValue, options);
                              break;
                          case "enum":
                              val = this.enum(field.V.T(), jsonObjValue, field.name, options.ignoreUnknownFields);
                              if (val === false)
                                  continue;
                              break;
                          case "scalar":
                              val = this.scalar(jsonObjValue, field.V.T, field.V.L, field.name);
                              break;
                      }
                      this.assert(val !== undefined, field.name + " map value", jsonObjValue);
                      // read key
                      let key = jsonObjKey;
                      if (field.K == ScalarType.BOOL)
                          key = key == "true" ? true : key == "false" ? false : key;
                      key = this.scalar(key, field.K, LongType.STRING, field.name).toString();
                      fieldObj[key] = val;
                  }
              }
              else if (field.repeat) {
                  if (jsonValue === null)
                      continue;
                  // check input
                  this.assert(Array.isArray(jsonValue), field.name, jsonValue);
                  // our target to put array entries into
                  const fieldArr = target[localName];
                  // read array entries
                  for (const jsonItem of jsonValue) {
                      this.assert(jsonItem !== null, field.name, null);
                      let val;
                      switch (field.kind) {
                          case "message":
                              val = field.T().internalJsonRead(jsonItem, options);
                              break;
                          case "enum":
                              val = this.enum(field.T(), jsonItem, field.name, options.ignoreUnknownFields);
                              if (val === false)
                                  continue;
                              break;
                          case "scalar":
                              val = this.scalar(jsonItem, field.T, field.L, field.name);
                              break;
                      }
                      this.assert(val !== undefined, field.name, jsonValue);
                      fieldArr.push(val);
                  }
              }
              else {
                  switch (field.kind) {
                      case "message":
                          if (jsonValue === null && field.T().typeName != 'google.protobuf.Value') {
                              this.assert(field.oneof === undefined, field.name + " (oneof member)", null);
                              continue;
                          }
                          target[localName] = field.T().internalJsonRead(jsonValue, options, target[localName]);
                          break;
                      case "enum":
                          let val = this.enum(field.T(), jsonValue, field.name, options.ignoreUnknownFields);
                          if (val === false)
                              continue;
                          target[localName] = val;
                          break;
                      case "scalar":
                          target[localName] = this.scalar(jsonValue, field.T, field.L, field.name);
                          break;
                  }
              }
          }
      }
      /**
       * Returns `false` for unrecognized string representations.
       *
       * google.protobuf.NullValue accepts only JSON `null`.
       */
      enum(type, json, fieldName, ignoreUnknownFields) {
          if (type[0] == 'google.protobuf.NullValue')
              assert(json === null, `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} only accepts null.`);
          if (json === null)
              // we require 0 to be default value for all enums
              return 0;
          switch (typeof json) {
              case "number":
                  assert(Number.isInteger(json), `Unable to parse field ${this.info.typeName}#${fieldName}, enum can only be integral number, got ${json}.`);
                  return json;
              case "string":
                  let localEnumName = json;
                  if (type[2] && json.substring(0, type[2].length) === type[2])
                      // lookup without the shared prefix
                      localEnumName = json.substring(type[2].length);
                  let enumNumber = type[1][localEnumName];
                  if (typeof enumNumber === 'undefined' && ignoreUnknownFields) {
                      return false;
                  }
                  assert(typeof enumNumber == "number", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} has no value for "${json}".`);
                  return enumNumber;
          }
          assert(false, `Unable to parse field ${this.info.typeName}#${fieldName}, cannot parse enum value from ${typeof json}".`);
      }
      scalar(json, type, longType, fieldName) {
          let e;
          try {
              switch (type) {
                  // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
                  // Either numbers or strings are accepted. Exponent notation is also accepted.
                  case ScalarType.DOUBLE:
                  case ScalarType.FLOAT:
                      if (json === null)
                          return .0;
                      if (json === "NaN")
                          return Number.NaN;
                      if (json === "Infinity")
                          return Number.POSITIVE_INFINITY;
                      if (json === "-Infinity")
                          return Number.NEGATIVE_INFINITY;
                      if (json === "") {
                          e = "empty string";
                          break;
                      }
                      if (typeof json == "string" && json.trim().length !== json.length) {
                          e = "extra whitespace";
                          break;
                      }
                      if (typeof json != "string" && typeof json != "number") {
                          break;
                      }
                      let float = Number(json);
                      if (Number.isNaN(float)) {
                          e = "not a number";
                          break;
                      }
                      if (!Number.isFinite(float)) {
                          // infinity and -infinity are handled by string representation above, so this is an error
                          e = "too large or small";
                          break;
                      }
                      if (type == ScalarType.FLOAT)
                          assertFloat32(float);
                      return float;
                  // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
                  case ScalarType.INT32:
                  case ScalarType.FIXED32:
                  case ScalarType.SFIXED32:
                  case ScalarType.SINT32:
                  case ScalarType.UINT32:
                      if (json === null)
                          return 0;
                      let int32;
                      if (typeof json == "number")
                          int32 = json;
                      else if (json === "")
                          e = "empty string";
                      else if (typeof json == "string") {
                          if (json.trim().length !== json.length)
                              e = "extra whitespace";
                          else
                              int32 = Number(json);
                      }
                      if (int32 === undefined)
                          break;
                      if (type == ScalarType.UINT32)
                          assertUInt32(int32);
                      else
                          assertInt32(int32);
                      return int32;
                  // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.
                  case ScalarType.INT64:
                  case ScalarType.SFIXED64:
                  case ScalarType.SINT64:
                      if (json === null)
                          return reflectionLongConvert(PbLong.ZERO, longType);
                      if (typeof json != "number" && typeof json != "string")
                          break;
                      return reflectionLongConvert(PbLong.from(json), longType);
                  case ScalarType.FIXED64:
                  case ScalarType.UINT64:
                      if (json === null)
                          return reflectionLongConvert(PbULong.ZERO, longType);
                      if (typeof json != "number" && typeof json != "string")
                          break;
                      return reflectionLongConvert(PbULong.from(json), longType);
                  // bool:
                  case ScalarType.BOOL:
                      if (json === null)
                          return false;
                      if (typeof json !== "boolean")
                          break;
                      return json;
                  // string:
                  case ScalarType.STRING:
                      if (json === null)
                          return "";
                      if (typeof json !== "string") {
                          e = "extra whitespace";
                          break;
                      }
                      try {
                          encodeURIComponent(json);
                      }
                      catch (e) {
                          e = "invalid UTF8";
                          break;
                      }
                      return json;
                  // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
                  // Either standard or URL-safe base64 encoding with/without paddings are accepted.
                  case ScalarType.BYTES:
                      if (json === null || json === "")
                          return new Uint8Array(0);
                      if (typeof json !== 'string')
                          break;
                      return base64decode(json);
              }
          }
          catch (error) {
              e = error.message;
          }
          this.assert(false, fieldName + (e ? " - " + e : ""), json);
      }
  }

  /**
   * Writes proto3 messages in canonical JSON format using reflection
   * information.
   *
   * https://developers.google.com/protocol-buffers/docs/proto3#json
   */
  class ReflectionJsonWriter {
      constructor(info) {
          var _a;
          this.fields = (_a = info.fields) !== null && _a !== void 0 ? _a : [];
      }
      /**
       * Converts the message to a JSON object, based on the field descriptors.
       */
      write(message, options) {
          const json = {}, source = message;
          for (const field of this.fields) {
              // field is not part of a oneof, simply write as is
              if (!field.oneof) {
                  let jsonValue = this.field(field, source[field.localName], options);
                  if (jsonValue !== undefined)
                      json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
                  continue;
              }
              // field is part of a oneof
              const group = source[field.oneof];
              if (group.oneofKind !== field.localName)
                  continue; // not selected, skip
              const opt = field.kind == 'scalar' || field.kind == 'enum'
                  ? Object.assign(Object.assign({}, options), { emitDefaultValues: true }) : options;
              let jsonValue = this.field(field, group[field.localName], opt);
              assert(jsonValue !== undefined);
              json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
          }
          return json;
      }
      field(field, value, options) {
          let jsonValue = undefined;
          if (field.kind == 'map') {
              assert(typeof value == "object" && value !== null);
              const jsonObj = {};
              switch (field.V.kind) {
                  case "scalar":
                      for (const [entryKey, entryValue] of Object.entries(value)) {
                          const val = this.scalar(field.V.T, entryValue, field.name, false, true);
                          assert(val !== undefined);
                          jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key
                      }
                      break;
                  case "message":
                      const messageType = field.V.T();
                      for (const [entryKey, entryValue] of Object.entries(value)) {
                          const val = this.message(messageType, entryValue, field.name, options);
                          assert(val !== undefined);
                          jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key
                      }
                      break;
                  case "enum":
                      const enumInfo = field.V.T();
                      for (const [entryKey, entryValue] of Object.entries(value)) {
                          assert(entryValue === undefined || typeof entryValue == 'number');
                          const val = this.enum(enumInfo, entryValue, field.name, false, true, options.enumAsInteger);
                          assert(val !== undefined);
                          jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key
                      }
                      break;
              }
              if (options.emitDefaultValues || Object.keys(jsonObj).length > 0)
                  jsonValue = jsonObj;
          }
          else if (field.repeat) {
              assert(Array.isArray(value));
              const jsonArr = [];
              switch (field.kind) {
                  case "scalar":
                      for (let i = 0; i < value.length; i++) {
                          const val = this.scalar(field.T, value[i], field.name, field.opt, true);
                          assert(val !== undefined);
                          jsonArr.push(val);
                      }
                      break;
                  case "enum":
                      const enumInfo = field.T();
                      for (let i = 0; i < value.length; i++) {
                          assert(value[i] === undefined || typeof value[i] == 'number');
                          const val = this.enum(enumInfo, value[i], field.name, field.opt, true, options.enumAsInteger);
                          assert(val !== undefined);
                          jsonArr.push(val);
                      }
                      break;
                  case "message":
                      const messageType = field.T();
                      for (let i = 0; i < value.length; i++) {
                          const val = this.message(messageType, value[i], field.name, options);
                          assert(val !== undefined);
                          jsonArr.push(val);
                      }
                      break;
              }
              // add converted array to json output
              if (options.emitDefaultValues || jsonArr.length > 0 || options.emitDefaultValues)
                  jsonValue = jsonArr;
          }
          else {
              switch (field.kind) {
                  case "scalar":
                      jsonValue = this.scalar(field.T, value, field.name, field.opt, options.emitDefaultValues);
                      break;
                  case "enum":
                      jsonValue = this.enum(field.T(), value, field.name, field.opt, options.emitDefaultValues, options.enumAsInteger);
                      break;
                  case "message":
                      jsonValue = this.message(field.T(), value, field.name, options);
                      break;
              }
          }
          return jsonValue;
      }
      /**
       * Returns `null` for google.protobuf.NullValue.
       */
      enum(type, value, fieldName, optional, emitDefaultValues, enumAsInteger) {
          if (type[0] == 'google.protobuf.NullValue')
              return null;
          if (value === undefined) {
              assert(optional);
              return undefined;
          }
          if (value === 0 && !emitDefaultValues && !optional)
              // we require 0 to be default value for all enums
              return undefined;
          assert(typeof value == 'number');
          assert(Number.isInteger(value));
          if (enumAsInteger || !type[1].hasOwnProperty(value))
              // if we don't now the enum value, just return the number
              return value;
          if (type[2])
              // restore the dropped prefix
              return type[2] + type[1][value];
          return type[1][value];
      }
      message(type, value, fieldName, options) {
          if (value === undefined)
              return options.emitDefaultValues ? null : undefined;
          return type.internalJsonWrite(value, options);
      }
      scalar(type, value, fieldName, optional, emitDefaultValues) {
          if (value === undefined) {
              assert(optional);
              return undefined;
          }
          const ed = emitDefaultValues || optional;
          // noinspection FallThroughInSwitchStatementJS
          switch (type) {
              // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
              case ScalarType.INT32:
              case ScalarType.SFIXED32:
              case ScalarType.SINT32:
                  if (value === 0)
                      return ed ? 0 : undefined;
                  assertInt32(value);
                  return value;
              case ScalarType.FIXED32:
              case ScalarType.UINT32:
                  if (value === 0)
                      return ed ? 0 : undefined;
                  assertUInt32(value);
                  return value;
              // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
              // Either numbers or strings are accepted. Exponent notation is also accepted.
              case ScalarType.FLOAT:
                  assertFloat32(value);
              case ScalarType.DOUBLE:
                  if (value === 0)
                      return ed ? 0 : undefined;
                  assert(typeof value == 'number');
                  if (Number.isNaN(value))
                      return 'NaN';
                  if (value === Number.POSITIVE_INFINITY)
                      return 'Infinity';
                  if (value === Number.NEGATIVE_INFINITY)
                      return '-Infinity';
                  return value;
              // string:
              case ScalarType.STRING:
                  if (value === "")
                      return ed ? '' : undefined;
                  assert(typeof value == 'string');
                  return value;
              // bool:
              case ScalarType.BOOL:
                  if (value === false)
                      return ed ? false : undefined;
                  assert(typeof value == 'boolean');
                  return value;
              // JSON value will be a decimal string. Either numbers or strings are accepted.
              case ScalarType.UINT64:
              case ScalarType.FIXED64:
                  assert(typeof value == 'number' || typeof value == 'string' || typeof value == 'bigint');
                  let ulong = PbULong.from(value);
                  if (ulong.isZero() && !ed)
                      return undefined;
                  return ulong.toString();
              // JSON value will be a decimal string. Either numbers or strings are accepted.
              case ScalarType.INT64:
              case ScalarType.SFIXED64:
              case ScalarType.SINT64:
                  assert(typeof value == 'number' || typeof value == 'string' || typeof value == 'bigint');
                  let long = PbLong.from(value);
                  if (long.isZero() && !ed)
                      return undefined;
                  return long.toString();
              // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
              // Either standard or URL-safe base64 encoding with/without paddings are accepted.
              case ScalarType.BYTES:
                  assert(value instanceof Uint8Array);
                  if (!value.byteLength)
                      return ed ? "" : undefined;
                  return base64encode(value);
          }
      }
  }

  /**
   * Creates the default value for a scalar type.
   */
  function reflectionScalarDefault(type, longType = LongType.STRING) {
      switch (type) {
          case ScalarType.BOOL:
              return false;
          case ScalarType.UINT64:
          case ScalarType.FIXED64:
              return reflectionLongConvert(PbULong.ZERO, longType);
          case ScalarType.INT64:
          case ScalarType.SFIXED64:
          case ScalarType.SINT64:
              return reflectionLongConvert(PbLong.ZERO, longType);
          case ScalarType.DOUBLE:
          case ScalarType.FLOAT:
              return 0.0;
          case ScalarType.BYTES:
              return new Uint8Array(0);
          case ScalarType.STRING:
              return "";
          default:
              // case ScalarType.INT32:
              // case ScalarType.UINT32:
              // case ScalarType.SINT32:
              // case ScalarType.FIXED32:
              // case ScalarType.SFIXED32:
              return 0;
      }
  }

  /**
   * Reads proto3 messages in binary format using reflection information.
   *
   * https://developers.google.com/protocol-buffers/docs/encoding
   */
  class ReflectionBinaryReader {
      constructor(info) {
          this.info = info;
      }
      prepare() {
          var _a;
          if (!this.fieldNoToField) {
              const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
              this.fieldNoToField = new Map(fieldsInput.map(field => [field.no, field]));
          }
      }
      /**
       * Reads a message from binary format into the target message.
       *
       * Repeated fields are appended. Map entries are added, overwriting
       * existing keys.
       *
       * If a message field is already present, it will be merged with the
       * new data.
       */
      read(reader, message, options, length) {
          this.prepare();
          const end = length === undefined ? reader.len : reader.pos + length;
          while (reader.pos < end) {
              // read the tag and find the field
              const [fieldNo, wireType] = reader.tag(), field = this.fieldNoToField.get(fieldNo);
              if (!field) {
                  let u = options.readUnknownField;
                  if (u == "throw")
                      throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.info.typeName}`);
                  let d = reader.skip(wireType);
                  if (u !== false)
                      (u === true ? UnknownFieldHandler.onRead : u)(this.info.typeName, message, fieldNo, wireType, d);
                  continue;
              }
              // target object for the field we are reading
              let target = message, repeated = field.repeat, localName = field.localName;
              // if field is member of oneof ADT, use ADT as target
              if (field.oneof) {
                  target = target[field.oneof];
                  // if other oneof member selected, set new ADT
                  if (target.oneofKind !== localName)
                      target = message[field.oneof] = {
                          oneofKind: localName
                      };
              }
              // we have handled oneof above, we just have read the value into `target[localName]`
              switch (field.kind) {
                  case "scalar":
                  case "enum":
                      let T = field.kind == "enum" ? ScalarType.INT32 : field.T;
                      let L = field.kind == "scalar" ? field.L : undefined;
                      if (repeated) {
                          let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values
                          if (wireType == WireType.LengthDelimited && T != ScalarType.STRING && T != ScalarType.BYTES) {
                              let e = reader.uint32() + reader.pos;
                              while (reader.pos < e)
                                  arr.push(this.scalar(reader, T, L));
                          }
                          else
                              arr.push(this.scalar(reader, T, L));
                      }
                      else
                          target[localName] = this.scalar(reader, T, L);
                      break;
                  case "message":
                      if (repeated) {
                          let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values
                          let msg = field.T().internalBinaryRead(reader, reader.uint32(), options);
                          arr.push(msg);
                      }
                      else
                          target[localName] = field.T().internalBinaryRead(reader, reader.uint32(), options, target[localName]);
                      break;
                  case "map":
                      let [mapKey, mapVal] = this.mapEntry(field, reader, options);
                      // safe to assume presence of map object, oneof cannot contain repeated values
                      target[localName][mapKey] = mapVal;
                      break;
              }
          }
      }
      /**
       * Read a map field, expecting key field = 1, value field = 2
       */
      mapEntry(field, reader, options) {
          let length = reader.uint32();
          let end = reader.pos + length;
          let key = undefined; // javascript only allows number or string for object properties
          let val = undefined;
          while (reader.pos < end) {
              let [fieldNo, wireType] = reader.tag();
              switch (fieldNo) {
                  case 1:
                      if (field.K == ScalarType.BOOL)
                          key = reader.bool().toString();
                      else
                          // long types are read as string, number types are okay as number
                          key = this.scalar(reader, field.K, LongType.STRING);
                      break;
                  case 2:
                      switch (field.V.kind) {
                          case "scalar":
                              val = this.scalar(reader, field.V.T, field.V.L);
                              break;
                          case "enum":
                              val = reader.int32();
                              break;
                          case "message":
                              val = field.V.T().internalBinaryRead(reader, reader.uint32(), options);
                              break;
                      }
                      break;
                  default:
                      throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) in map entry for ${this.info.typeName}#${field.name}`);
              }
          }
          if (key === undefined) {
              let keyRaw = reflectionScalarDefault(field.K);
              key = field.K == ScalarType.BOOL ? keyRaw.toString() : keyRaw;
          }
          if (val === undefined)
              switch (field.V.kind) {
                  case "scalar":
                      val = reflectionScalarDefault(field.V.T, field.V.L);
                      break;
                  case "enum":
                      val = 0;
                      break;
                  case "message":
                      val = field.V.T().create();
                      break;
              }
          return [key, val];
      }
      scalar(reader, type, longType) {
          switch (type) {
              case ScalarType.INT32:
                  return reader.int32();
              case ScalarType.STRING:
                  return reader.string();
              case ScalarType.BOOL:
                  return reader.bool();
              case ScalarType.DOUBLE:
                  return reader.double();
              case ScalarType.FLOAT:
                  return reader.float();
              case ScalarType.INT64:
                  return reflectionLongConvert(reader.int64(), longType);
              case ScalarType.UINT64:
                  return reflectionLongConvert(reader.uint64(), longType);
              case ScalarType.FIXED64:
                  return reflectionLongConvert(reader.fixed64(), longType);
              case ScalarType.FIXED32:
                  return reader.fixed32();
              case ScalarType.BYTES:
                  return reader.bytes();
              case ScalarType.UINT32:
                  return reader.uint32();
              case ScalarType.SFIXED32:
                  return reader.sfixed32();
              case ScalarType.SFIXED64:
                  return reflectionLongConvert(reader.sfixed64(), longType);
              case ScalarType.SINT32:
                  return reader.sint32();
              case ScalarType.SINT64:
                  return reflectionLongConvert(reader.sint64(), longType);
          }
      }
  }

  /**
   * Writes proto3 messages in binary format using reflection information.
   *
   * https://developers.google.com/protocol-buffers/docs/encoding
   */
  class ReflectionBinaryWriter {
      constructor(info) {
          this.info = info;
      }
      prepare() {
          if (!this.fields) {
              const fieldsInput = this.info.fields ? this.info.fields.concat() : [];
              this.fields = fieldsInput.sort((a, b) => a.no - b.no);
          }
      }
      /**
       * Writes the message to binary format.
       */
      write(message, writer, options) {
          this.prepare();
          for (const field of this.fields) {
              let value, // this will be our field value, whether it is member of a oneof or not
              emitDefault, // whether we emit the default value (only true for oneof members)
              repeated = field.repeat, localName = field.localName;
              // handle oneof ADT
              if (field.oneof) {
                  const group = message[field.oneof];
                  if (group.oneofKind !== localName)
                      continue; // if field is not selected, skip
                  value = group[localName];
                  emitDefault = true;
              }
              else {
                  value = message[localName];
                  emitDefault = false;
              }
              // we have handled oneof above. we just have to honor `emitDefault`.
              switch (field.kind) {
                  case "scalar":
                  case "enum":
                      let T = field.kind == "enum" ? ScalarType.INT32 : field.T;
                      if (repeated) {
                          assert(Array.isArray(value));
                          if (repeated == RepeatType.PACKED)
                              this.packed(writer, T, field.no, value);
                          else
                              for (const item of value)
                                  this.scalar(writer, T, field.no, item, true);
                      }
                      else if (value === undefined)
                          assert(field.opt);
                      else
                          this.scalar(writer, T, field.no, value, emitDefault || field.opt);
                      break;
                  case "message":
                      if (repeated) {
                          assert(Array.isArray(value));
                          for (const item of value)
                              this.message(writer, options, field.T(), field.no, item);
                      }
                      else {
                          this.message(writer, options, field.T(), field.no, value);
                      }
                      break;
                  case "map":
                      assert(typeof value == 'object' && value !== null);
                      for (const [key, val] of Object.entries(value))
                          this.mapEntry(writer, options, field, key, val);
                      break;
              }
          }
          let u = options.writeUnknownFields;
          if (u !== false)
              (u === true ? UnknownFieldHandler.onWrite : u)(this.info.typeName, message, writer);
      }
      mapEntry(writer, options, field, key, value) {
          writer.tag(field.no, WireType.LengthDelimited);
          writer.fork();
          // javascript only allows number or string for object properties
          // we convert from our representation to the protobuf type
          let keyValue = key;
          switch (field.K) {
              case ScalarType.INT32:
              case ScalarType.FIXED32:
              case ScalarType.UINT32:
              case ScalarType.SFIXED32:
              case ScalarType.SINT32:
                  keyValue = Number.parseInt(key);
                  break;
              case ScalarType.BOOL:
                  assert(key == 'true' || key == 'false');
                  keyValue = key == 'true';
                  break;
          }
          // write key, expecting key field number = 1
          this.scalar(writer, field.K, 1, keyValue, true);
          // write value, expecting value field number = 2
          switch (field.V.kind) {
              case 'scalar':
                  this.scalar(writer, field.V.T, 2, value, true);
                  break;
              case 'enum':
                  this.scalar(writer, ScalarType.INT32, 2, value, true);
                  break;
              case 'message':
                  this.message(writer, options, field.V.T(), 2, value);
                  break;
          }
          writer.join();
      }
      message(writer, options, handler, fieldNo, value) {
          if (value === undefined)
              return;
          handler.internalBinaryWrite(value, writer.tag(fieldNo, WireType.LengthDelimited).fork(), options);
          writer.join();
      }
      /**
       * Write a single scalar value.
       */
      scalar(writer, type, fieldNo, value, emitDefault) {
          let [wireType, method, isDefault] = this.scalarInfo(type, value);
          if (!isDefault || emitDefault) {
              writer.tag(fieldNo, wireType);
              writer[method](value);
          }
      }
      /**
       * Write an array of scalar values in packed format.
       */
      packed(writer, type, fieldNo, value) {
          if (!value.length)
              return;
          assert(type !== ScalarType.BYTES && type !== ScalarType.STRING);
          // write tag
          writer.tag(fieldNo, WireType.LengthDelimited);
          // begin length-delimited
          writer.fork();
          // write values without tags
          let [, method,] = this.scalarInfo(type);
          for (let i = 0; i < value.length; i++)
              writer[method](value[i]);
          // end length delimited
          writer.join();
      }
      /**
       * Get information for writing a scalar value.
       *
       * Returns tuple:
       * [0]: appropriate WireType
       * [1]: name of the appropriate method of IBinaryWriter
       * [2]: whether the given value is a default value
       *
       * If argument `value` is omitted, [2] is always false.
       */
      scalarInfo(type, value) {
          let t = WireType.Varint;
          let m;
          let i = value === undefined;
          let d = value === 0;
          switch (type) {
              case ScalarType.INT32:
                  m = "int32";
                  break;
              case ScalarType.STRING:
                  d = i || !value.length;
                  t = WireType.LengthDelimited;
                  m = "string";
                  break;
              case ScalarType.BOOL:
                  d = value === false;
                  m = "bool";
                  break;
              case ScalarType.UINT32:
                  m = "uint32";
                  break;
              case ScalarType.DOUBLE:
                  t = WireType.Bit64;
                  m = "double";
                  break;
              case ScalarType.FLOAT:
                  t = WireType.Bit32;
                  m = "float";
                  break;
              case ScalarType.INT64:
                  d = i || PbLong.from(value).isZero();
                  m = "int64";
                  break;
              case ScalarType.UINT64:
                  d = i || PbULong.from(value).isZero();
                  m = "uint64";
                  break;
              case ScalarType.FIXED64:
                  d = i || PbULong.from(value).isZero();
                  t = WireType.Bit64;
                  m = "fixed64";
                  break;
              case ScalarType.BYTES:
                  d = i || !value.byteLength;
                  t = WireType.LengthDelimited;
                  m = "bytes";
                  break;
              case ScalarType.FIXED32:
                  t = WireType.Bit32;
                  m = "fixed32";
                  break;
              case ScalarType.SFIXED32:
                  t = WireType.Bit32;
                  m = "sfixed32";
                  break;
              case ScalarType.SFIXED64:
                  d = i || PbLong.from(value).isZero();
                  t = WireType.Bit64;
                  m = "sfixed64";
                  break;
              case ScalarType.SINT32:
                  m = "sint32";
                  break;
              case ScalarType.SINT64:
                  d = i || PbLong.from(value).isZero();
                  m = "sint64";
                  break;
          }
          return [t, m, i || d];
      }
  }

  /**
   * Creates an instance of the generic message, using the field
   * information.
   */
  function reflectionCreate(type) {
      const msg = {};
      Object.defineProperty(msg, MESSAGE_TYPE, { enumerable: false, value: type });
      for (let field of type.fields) {
          let name = field.localName;
          if (field.opt)
              continue;
          if (field.oneof)
              msg[field.oneof] = { oneofKind: undefined };
          else if (field.repeat)
              msg[name] = [];
          else
              switch (field.kind) {
                  case "scalar":
                      msg[name] = reflectionScalarDefault(field.T, field.L);
                      break;
                  case "enum":
                      // we require 0 to be default value for all enums
                      msg[name] = 0;
                      break;
                  case "map":
                      msg[name] = {};
                      break;
              }
      }
      return msg;
  }

  /**
   * Copy partial data into the target message.
   *
   * Replaces fields in the target with the fields from the
   * (partial) source.
   *
   * Omitted fields are not replaced.
   * Copies all values.
   * A default value in the source will replace a value in the target.
   *
   * Message fields are recursively merged (by calling `mergePartial()`
   * of the responsible message handler). Map and repeated fields
   * are simply overwritten, not appended or merged.
   */
  function reflectionMergePartial(info, target, source) {
      let fieldValue, // the field value we are working with
      input = source, output; // where we want our field value to go
      for (let field of info.fields) {
          let name = field.localName;
          if (field.oneof) {
              const group = input[field.oneof]; // this is the oneof`s group in the source
              if (group == undefined) { // the user is free to omit
                  continue; // we skip this field, and all other members too
              }
              fieldValue = group[name]; // our value comes from the the oneof group of the source
              output = target[field.oneof]; // and our output is the oneof group of the target
              output.oneofKind = group.oneofKind; // always update discriminator
              if (fieldValue == undefined) {
                  delete output[name]; // remove any existing value
                  continue; // skip further work on field
              }
          }
          else {
              fieldValue = input[name]; // we are using the source directly
              output = target; // we want our field value to go directly into the target
              if (fieldValue == undefined) {
                  continue; // skip further work on field, existing value is used as is
              }
          }
          // now we just work with `fieldValue` and `output` to merge the value
          switch (field.kind) {
              case "scalar":
              case "enum":
                  if (field.repeat)
                      output[name] = fieldValue.concat(); // elements are not reference types
                  else
                      output[name] = fieldValue; // not a reference type
                  break;
              case "message":
                  let T = field.T();
                  if (field.repeat)
                      for (let i = 0; i < fieldValue.length; i++)
                          output[name][i] = T.create(fieldValue[i]);
                  else if (output[name] === undefined)
                      output[name] = T.create(fieldValue); // nothing to merge with
                  else
                      T.mergePartial(output[name], fieldValue);
                  break;
              case "map":
                  // Map and repeated fields are simply overwritten, not appended or merged
                  switch (field.V.kind) {
                      case "scalar":
                      case "enum":
                          Object.assign(output[name], fieldValue); // elements are not reference types
                          break;
                      case "message":
                          let T = field.V.T();
                          for (let k of Object.keys(fieldValue))
                              output[name][k] = T.create(fieldValue[k]);
                          break;
                  }
                  break;
          }
      }
  }

  /**
   * Determines whether two message of the same type have the same field values.
   * Checks for deep equality, traversing repeated fields, oneof groups, maps
   * and messages recursively.
   * Will also return true if both messages are `undefined`.
   */
  function reflectionEquals(info, a, b) {
      if (a === b)
          return true;
      if (!a || !b)
          return false;
      for (let field of info.fields) {
          let localName = field.localName;
          let val_a = field.oneof ? a[field.oneof][localName] : a[localName];
          let val_b = field.oneof ? b[field.oneof][localName] : b[localName];
          switch (field.kind) {
              case "enum":
              case "scalar":
                  let t = field.kind == "enum" ? ScalarType.INT32 : field.T;
                  if (!(field.repeat
                      ? repeatedPrimitiveEq(t, val_a, val_b)
                      : primitiveEq(t, val_a, val_b)))
                      return false;
                  break;
              case "map":
                  if (!(field.V.kind == "message"
                      ? repeatedMsgEq(field.V.T(), objectValues(val_a), objectValues(val_b))
                      : repeatedPrimitiveEq(field.V.kind == "enum" ? ScalarType.INT32 : field.V.T, objectValues(val_a), objectValues(val_b))))
                      return false;
                  break;
              case "message":
                  let T = field.T();
                  if (!(field.repeat
                      ? repeatedMsgEq(T, val_a, val_b)
                      : T.equals(val_a, val_b)))
                      return false;
                  break;
          }
      }
      return true;
  }
  const objectValues = Object.values;
  function primitiveEq(type, a, b) {
      if (a === b)
          return true;
      if (type !== ScalarType.BYTES)
          return false;
      let ba = a;
      let bb = b;
      if (ba.length !== bb.length)
          return false;
      for (let i = 0; i < ba.length; i++)
          if (ba[i] != bb[i])
              return false;
      return true;
  }
  function repeatedPrimitiveEq(type, a, b) {
      if (a.length !== b.length)
          return false;
      for (let i = 0; i < a.length; i++)
          if (!primitiveEq(type, a[i], b[i]))
              return false;
      return true;
  }
  function repeatedMsgEq(type, a, b) {
      if (a.length !== b.length)
          return false;
      for (let i = 0; i < a.length; i++)
          if (!type.equals(a[i], b[i]))
              return false;
      return true;
  }

  /**
   * This standard message type provides reflection-based
   * operations to work with a message.
   */
  class MessageType {
      constructor(name, fields, options) {
          this.defaultCheckDepth = 16;
          this.typeName = name;
          this.fields = fields.map(normalizeFieldInfo);
          this.options = options !== null && options !== void 0 ? options : {};
          this.refTypeCheck = new ReflectionTypeCheck(this);
          this.refJsonReader = new ReflectionJsonReader(this);
          this.refJsonWriter = new ReflectionJsonWriter(this);
          this.refBinReader = new ReflectionBinaryReader(this);
          this.refBinWriter = new ReflectionBinaryWriter(this);
      }
      create(value) {
          let message = reflectionCreate(this);
          if (value !== undefined) {
              reflectionMergePartial(this, message, value);
          }
          return message;
      }
      /**
       * Clone the message.
       *
       * Unknown fields are discarded.
       */
      clone(message) {
          let copy = this.create();
          reflectionMergePartial(this, copy, message);
          return copy;
      }
      /**
       * Determines whether two message of the same type have the same field values.
       * Checks for deep equality, traversing repeated fields, oneof groups, maps
       * and messages recursively.
       * Will also return true if both messages are `undefined`.
       */
      equals(a, b) {
          return reflectionEquals(this, a, b);
      }
      /**
       * Is the given value assignable to our message type
       * and contains no [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
       */
      is(arg, depth = this.defaultCheckDepth) {
          return this.refTypeCheck.is(arg, depth, false);
      }
      /**
       * Is the given value assignable to our message type,
       * regardless of [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
       */
      isAssignable(arg, depth = this.defaultCheckDepth) {
          return this.refTypeCheck.is(arg, depth, true);
      }
      /**
       * Copy partial data into the target message.
       */
      mergePartial(target, source) {
          reflectionMergePartial(this, target, source);
      }
      /**
       * Create a new message from binary format.
       */
      fromBinary(data, options) {
          let opt = binaryReadOptions(options);
          return this.internalBinaryRead(opt.readerFactory(data), data.byteLength, opt);
      }
      /**
       * Read a new message from a JSON value.
       */
      fromJson(json, options) {
          return this.internalJsonRead(json, jsonReadOptions(options));
      }
      /**
       * Read a new message from a JSON string.
       * This is equivalent to `T.fromJson(JSON.parse(json))`.
       */
      fromJsonString(json, options) {
          let value = JSON.parse(json);
          return this.fromJson(value, options);
      }
      /**
       * Write the message to canonical JSON value.
       */
      toJson(message, options) {
          return this.internalJsonWrite(message, jsonWriteOptions(options));
      }
      /**
       * Convert the message to canonical JSON string.
       * This is equivalent to `JSON.stringify(T.toJson(t))`
       */
      toJsonString(message, options) {
          var _a;
          let value = this.toJson(message, options);
          return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);
      }
      /**
       * Write the message to binary format.
       */
      toBinary(message, options) {
          let opt = binaryWriteOptions(options);
          return this.internalBinaryWrite(message, opt.writerFactory(), opt).finish();
      }
      /**
       * This is an internal method. If you just want to read a message from
       * JSON, use `fromJson()` or `fromJsonString()`.
       *
       * Reads JSON value and merges the fields into the target
       * according to protobuf rules. If the target is omitted,
       * a new instance is created first.
       */
      internalJsonRead(json, options, target) {
          if (json !== null && typeof json == "object" && !Array.isArray(json)) {
              let message = target !== null && target !== void 0 ? target : this.create();
              this.refJsonReader.read(json, message, options);
              return message;
          }
          throw new Error(`Unable to parse message ${this.typeName} from JSON ${typeofJsonValue(json)}.`);
      }
      /**
       * This is an internal method. If you just want to write a message
       * to JSON, use `toJson()` or `toJsonString().
       *
       * Writes JSON value and returns it.
       */
      internalJsonWrite(message, options) {
          return this.refJsonWriter.write(message, options);
      }
      /**
       * This is an internal method. If you just want to write a message
       * in binary format, use `toBinary()`.
       *
       * Serializes the message in binary format and appends it to the given
       * writer. Returns passed writer.
       */
      internalBinaryWrite(message, writer, options) {
          this.refBinWriter.write(message, writer, options);
          return writer;
      }
      /**
       * This is an internal method. If you just want to read a message from
       * binary data, use `fromBinary()`.
       *
       * Reads data from binary format and merges the fields into
       * the target according to protobuf rules. If the target is
       * omitted, a new instance is created first.
       */
      internalBinaryRead(reader, length, options, target) {
          let message = target !== null && target !== void 0 ? target : this.create();
          this.refBinReader.read(reader, message, options, length);
          return message;
      }
  }

  var ConnectCommand$Type = /*#__PURE__*/function (_MessageType) {
    _inherits(ConnectCommand$Type, _MessageType);

    var _super = _createSuper(ConnectCommand$Type);

    function ConnectCommand$Type() {
      _classCallCheck(this, ConnectCommand$Type);

      return _super.call(this, 'pb.ConnectCommand', [{
        no: 1,
        name: 'nodeId',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 2,
        name: 'userId',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 3,
        name: 'timestamp',
        kind: 'scalar',
        T: 4
        /*ScalarType.UINT64*/
        ,
        L: 0
        /*LongType.BIGINT*/

      }, {
        no: 4,
        name: 'msgSign',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }]);
    }

    _createClass(ConnectCommand$Type, [{
      key: "create",
      value: function create(value) {
        var message = {
          nodeId: '',
          userId: '',
          timestamp: 0n,
          msgSign: ''
        };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
          enumerable: false,
          value: this
        });
        if (value !== undefined) reflectionMergePartial(this, message, value);
        return message;
      }
    }, {
      key: "internalBinaryRead",
      value: function internalBinaryRead(reader, length, options, target) {
        var message = target !== null && target !== void 0 ? target : this.create(),
            end = reader.pos + length;

        while (reader.pos < end) {
          var _reader$tag = reader.tag(),
              _reader$tag2 = _slicedToArray(_reader$tag, 2),
              fieldNo = _reader$tag2[0],
              wireType = _reader$tag2[1];

          switch (fieldNo) {
            case
            /* string nodeId */
            1:
              message.nodeId = reader.string();
              break;

            case
            /* string userId */
            2:
              message.userId = reader.string();
              break;

            case
            /* uint64 timestamp */
            3:
              message.timestamp = reader.uint64().toBigInt();
              break;

            case
            /* string msgSign */
            4:
              message.msgSign = reader.string();
              break;

            default:
              var u = options.readUnknownField;
              if (u === 'throw') throw new globalThis.Error("Unknown field ".concat(fieldNo, " (wire type ").concat(wireType, ") for ").concat(this.typeName));
              var d = reader.skip(wireType);
              if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
          }
        }

        return message;
      }
    }, {
      key: "internalBinaryWrite",
      value: function internalBinaryWrite(message, writer, options) {
        /* string nodeId = 1; */
        if (message.nodeId !== '') writer.tag(1, WireType.LengthDelimited).string(message.nodeId);
        /* string userId = 2; */

        if (message.userId !== '') writer.tag(2, WireType.LengthDelimited).string(message.userId);
        /* uint64 timestamp = 3; */

        if (message.timestamp !== 0n) writer.tag(3, WireType.Varint).uint64(message.timestamp);
        /* string msgSign = 4; */

        if (message.msgSign !== '') writer.tag(4, WireType.LengthDelimited).string(message.msgSign);
        var u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
      }
    }]);

    return ConnectCommand$Type;
  }(MessageType);
  /**
   * @generated MessageType for protobuf message pb.ConnectCommand
   */


  var ConnectCommand = new ConnectCommand$Type(); // @generated message type with reflection information, may provide speed optimized methods

  var DisconnectCommand$Type = /*#__PURE__*/function (_MessageType2) {
    _inherits(DisconnectCommand$Type, _MessageType2);

    var _super2 = _createSuper(DisconnectCommand$Type);

    function DisconnectCommand$Type() {
      _classCallCheck(this, DisconnectCommand$Type);

      return _super2.call(this, 'pb.DisconnectCommand', [{
        no: 1,
        name: 'nodeId',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 2,
        name: 'userId',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 3,
        name: 'timestamp',
        kind: 'scalar',
        T: 4
        /*ScalarType.UINT64*/
        ,
        L: 0
        /*LongType.BIGINT*/

      }, {
        no: 4,
        name: 'msgSign',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }]);
    }

    _createClass(DisconnectCommand$Type, [{
      key: "create",
      value: function create(value) {
        var message = {
          nodeId: '',
          userId: '',
          timestamp: 0n,
          msgSign: ''
        };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
          enumerable: false,
          value: this
        });
        if (value !== undefined) reflectionMergePartial(this, message, value);
        return message;
      }
    }, {
      key: "internalBinaryRead",
      value: function internalBinaryRead(reader, length, options, target) {
        var message = target !== null && target !== void 0 ? target : this.create(),
            end = reader.pos + length;

        while (reader.pos < end) {
          var _reader$tag3 = reader.tag(),
              _reader$tag4 = _slicedToArray(_reader$tag3, 2),
              fieldNo = _reader$tag4[0],
              wireType = _reader$tag4[1];

          switch (fieldNo) {
            case
            /* string nodeId */
            1:
              message.nodeId = reader.string();
              break;

            case
            /* string userId */
            2:
              message.userId = reader.string();
              break;

            case
            /* uint64 timestamp */
            3:
              message.timestamp = reader.uint64().toBigInt();
              break;

            case
            /* string msgSign */
            4:
              message.msgSign = reader.string();
              break;

            default:
              var u = options.readUnknownField;
              if (u === 'throw') throw new globalThis.Error("Unknown field ".concat(fieldNo, " (wire type ").concat(wireType, ") for ").concat(this.typeName));
              var d = reader.skip(wireType);
              if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
          }
        }

        return message;
      }
    }, {
      key: "internalBinaryWrite",
      value: function internalBinaryWrite(message, writer, options) {
        /* string nodeId = 1; */
        if (message.nodeId !== '') writer.tag(1, WireType.LengthDelimited).string(message.nodeId);
        /* string userId = 2; */

        if (message.userId !== '') writer.tag(2, WireType.LengthDelimited).string(message.userId);
        /* uint64 timestamp = 3; */

        if (message.timestamp !== 0n) writer.tag(3, WireType.Varint).uint64(message.timestamp);
        /* string msgSign = 4; */

        if (message.msgSign !== '') writer.tag(4, WireType.LengthDelimited).string(message.msgSign);
        var u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
      }
    }]);

    return DisconnectCommand$Type;
  }(MessageType);
  /**
   * @generated MessageType for protobuf message pb.DisconnectCommand
   */


  new DisconnectCommand$Type(); // @generated message type with reflection information, may provide speed optimized methods

  var UserTempConnectCommand$Type = /*#__PURE__*/function (_MessageType3) {
    _inherits(UserTempConnectCommand$Type, _MessageType3);

    var _super3 = _createSuper(UserTempConnectCommand$Type);

    function UserTempConnectCommand$Type() {
      _classCallCheck(this, UserTempConnectCommand$Type);

      return _super3.call(this, 'pb.UserTempConnectCommand', [{
        no: 1,
        name: 'NodeID',
        kind: 'scalar',
        jsonName: 'NodeID',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 2,
        name: 'DAppID',
        kind: 'scalar',
        jsonName: 'DAppID',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 3,
        name: 'TopicID',
        kind: 'scalar',
        jsonName: 'TopicID',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 4,
        name: 'SignatureTimestamp',
        kind: 'scalar',
        jsonName: 'SignatureTimestamp',
        T: 4
        /*ScalarType.UINT64*/
        ,
        L: 0
        /*LongType.BIGINT*/

      }, {
        no: 5,
        name: 'DAppSignature',
        kind: 'scalar',
        jsonName: 'DAppSignature',
        T: 9
        /*ScalarType.STRING*/

      }]);
    }

    _createClass(UserTempConnectCommand$Type, [{
      key: "create",
      value: function create(value) {
        var message = {
          nodeID: '',
          dAppID: '',
          topicID: '',
          signatureTimestamp: 0n,
          dAppSignature: ''
        };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
          enumerable: false,
          value: this
        });
        if (value !== undefined) reflectionMergePartial(this, message, value);
        return message;
      }
    }, {
      key: "internalBinaryRead",
      value: function internalBinaryRead(reader, length, options, target) {
        var message = target !== null && target !== void 0 ? target : this.create(),
            end = reader.pos + length;

        while (reader.pos < end) {
          var _reader$tag5 = reader.tag(),
              _reader$tag6 = _slicedToArray(_reader$tag5, 2),
              fieldNo = _reader$tag6[0],
              wireType = _reader$tag6[1];

          switch (fieldNo) {
            case
            /* string NodeID = 1 [json_name = "NodeID"];*/
            1:
              message.nodeID = reader.string();
              break;

            case
            /* string DAppID = 2 [json_name = "DAppID"];*/
            2:
              message.dAppID = reader.string();
              break;

            case
            /* string TopicID = 3 [json_name = "TopicID"];*/
            3:
              message.topicID = reader.string();
              break;

            case
            /* uint64 SignatureTimestamp = 4 [json_name = "SignatureTimestamp"];*/
            4:
              message.signatureTimestamp = reader.uint64().toBigInt();
              break;

            case
            /* string DAppSignature = 5 [json_name = "DAppSignature"];*/
            5:
              message.dAppSignature = reader.string();
              break;

            default:
              var u = options.readUnknownField;
              if (u === 'throw') throw new globalThis.Error("Unknown field ".concat(fieldNo, " (wire type ").concat(wireType, ") for ").concat(this.typeName));
              var d = reader.skip(wireType);
              if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
          }
        }

        return message;
      }
    }, {
      key: "internalBinaryWrite",
      value: function internalBinaryWrite(message, writer, options) {
        /* string NodeID = 1 [json_name = "NodeID"]; */
        if (message.nodeID !== '') writer.tag(1, WireType.LengthDelimited).string(message.nodeID);
        /* string DAppID = 2 [json_name = "DAppID"]; */

        if (message.dAppID !== '') writer.tag(2, WireType.LengthDelimited).string(message.dAppID);
        /* string TopicID = 3 [json_name = "TopicID"]; */

        if (message.topicID !== '') writer.tag(3, WireType.LengthDelimited).string(message.topicID);
        /* uint64 SignatureTimestamp = 4 [json_name = "SignatureTimestamp"]; */

        if (message.signatureTimestamp !== 0n) writer.tag(4, WireType.Varint).uint64(message.signatureTimestamp);
        /* string DAppSignature = 5 [json_name = "DAppSignature"]; */

        if (message.dAppSignature !== '') writer.tag(5, WireType.LengthDelimited).string(message.dAppSignature);
        var u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
      }
    }]);

    return UserTempConnectCommand$Type;
  }(MessageType);
  /**
   * @generated MessageType for protobuf message pb.UserTempConnectCommand
   */


  var UserTempConnectCommand = new UserTempConnectCommand$Type(); // @generated message type with reflection information, may provide speed optimized methods

  var UserTempConnectResp$Type = /*#__PURE__*/function (_MessageType4) {
    _inherits(UserTempConnectResp$Type, _MessageType4);

    var _super4 = _createSuper(UserTempConnectResp$Type);

    function UserTempConnectResp$Type() {
      _classCallCheck(this, UserTempConnectResp$Type);

      return _super4.call(this, 'pb.UserTempConnectResp', [{
        no: 1,
        name: 'NodeID',
        kind: 'scalar',
        jsonName: 'NodeID',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 2,
        name: 'DAppID',
        kind: 'scalar',
        jsonName: 'DAppID',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 3,
        name: 'TopicID',
        kind: 'scalar',
        jsonName: 'TopicID',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 4,
        name: 'statusCode',
        kind: 'scalar',
        T: 5
        /*ScalarType.INT32*/

      }, {
        no: 5,
        name: 'statusMsg',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 6,
        name: 'Timestamp',
        kind: 'scalar',
        jsonName: 'Timestamp',
        T: 4
        /*ScalarType.UINT64*/
        ,
        L: 0
        /*LongType.BIGINT*/

      }]);
    }

    _createClass(UserTempConnectResp$Type, [{
      key: "create",
      value: function create(value) {
        var message = {
          nodeID: '',
          dAppID: '',
          topicID: '',
          statusCode: 0,
          statusMsg: '',
          timestamp: 0n
        };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
          enumerable: false,
          value: this
        });
        if (value !== undefined) reflectionMergePartial(this, message, value);
        return message;
      }
    }, {
      key: "internalBinaryRead",
      value: function internalBinaryRead(reader, length, options, target) {
        var message = target !== null && target !== void 0 ? target : this.create(),
            end = reader.pos + length;

        while (reader.pos < end) {
          var _reader$tag7 = reader.tag(),
              _reader$tag8 = _slicedToArray(_reader$tag7, 2),
              fieldNo = _reader$tag8[0],
              wireType = _reader$tag8[1];

          switch (fieldNo) {
            case
            /* string NodeID = 1 [json_name = "NodeID"];*/
            1:
              message.nodeID = reader.string();
              break;

            case
            /* string DAppID = 2 [json_name = "DAppID"];*/
            2:
              message.dAppID = reader.string();
              break;

            case
            /* string TopicID = 3 [json_name = "TopicID"];*/
            3:
              message.topicID = reader.string();
              break;

            case
            /* int32 statusCode */
            4:
              message.statusCode = reader.int32();
              break;

            case
            /* string statusMsg */
            5:
              message.statusMsg = reader.string();
              break;

            case
            /* uint64 Timestamp = 6 [json_name = "Timestamp"];*/
            6:
              message.timestamp = reader.uint64().toBigInt();
              break;

            default:
              var u = options.readUnknownField;
              if (u === 'throw') throw new globalThis.Error("Unknown field ".concat(fieldNo, " (wire type ").concat(wireType, ") for ").concat(this.typeName));
              var d = reader.skip(wireType);
              if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
          }
        }

        return message;
      }
    }, {
      key: "internalBinaryWrite",
      value: function internalBinaryWrite(message, writer, options) {
        /* string NodeID = 1 [json_name = "NodeID"]; */
        if (message.nodeID !== '') writer.tag(1, WireType.LengthDelimited).string(message.nodeID);
        /* string DAppID = 2 [json_name = "DAppID"]; */

        if (message.dAppID !== '') writer.tag(2, WireType.LengthDelimited).string(message.dAppID);
        /* string TopicID = 3 [json_name = "TopicID"]; */

        if (message.topicID !== '') writer.tag(3, WireType.LengthDelimited).string(message.topicID);
        /* int32 statusCode = 4; */

        if (message.statusCode !== 0) writer.tag(4, WireType.Varint).int32(message.statusCode);
        /* string statusMsg = 5; */

        if (message.statusMsg !== '') writer.tag(5, WireType.LengthDelimited).string(message.statusMsg);
        /* uint64 Timestamp = 6 [json_name = "Timestamp"]; */

        if (message.timestamp !== 0n) writer.tag(6, WireType.Varint).uint64(message.timestamp);
        var u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
      }
    }]);

    return UserTempConnectResp$Type;
  }(MessageType);
  /**
   * @generated MessageType for protobuf message pb.UserTempConnectResp
   */


  var UserTempConnectResp = new UserTempConnectResp$Type();

  var Web3MQRequestMessage$Type = /*#__PURE__*/function (_MessageType) {
    _inherits(Web3MQRequestMessage$Type, _MessageType);

    var _super = _createSuper(Web3MQRequestMessage$Type);

    function Web3MQRequestMessage$Type() {
      _classCallCheck(this, Web3MQRequestMessage$Type);

      return _super.call(this, 'pb.Web3MQRequestMessage', [{
        no: 1,
        name: 'payload',
        kind: 'scalar',
        T: 12
        /*ScalarType.BYTES*/

      }, {
        no: 2,
        name: 'contentTopic',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 3,
        name: 'version',
        kind: 'scalar',
        T: 13
        /*ScalarType.UINT32*/

      }, {
        no: 4,
        name: 'comeFrom',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 5,
        name: 'fromSign',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 6,
        name: 'payloadType',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 7,
        name: 'cipherSuite',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 8,
        name: 'needStore',
        kind: 'scalar',
        T: 8
        /*ScalarType.BOOL*/

      }, {
        no: 9,
        name: 'timestamp',
        kind: 'scalar',
        T: 4
        /*ScalarType.UINT64*/
        ,
        L: 0
        /*LongType.BIGINT*/

      }, {
        no: 10,
        name: 'messageId',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 11,
        name: 'messageType',
        kind: 'scalar',
        opt: true,
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 12,
        name: 'nodeId',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 13,
        name: 'validatePubKey',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 14,
        name: 'extraData',
        kind: 'map',
        K: 9
        /*ScalarType.STRING*/
        ,
        V: {
          kind: 'scalar',
          T: 9
          /*ScalarType.STRING*/

        }
      }]);
    }

    _createClass(Web3MQRequestMessage$Type, [{
      key: "create",
      value: function create(value) {
        var message = {
          payload: new Uint8Array(0),
          contentTopic: '',
          version: 0,
          comeFrom: '',
          fromSign: '',
          payloadType: '',
          cipherSuite: '',
          needStore: false,
          timestamp: 0n,
          messageId: '',
          nodeId: '',
          validatePubKey: '',
          extraData: {}
        };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
          enumerable: false,
          value: this
        });
        if (value !== undefined) reflectionMergePartial(this, message, value);
        return message;
      }
    }, {
      key: "internalBinaryRead",
      value: function internalBinaryRead(reader, length, options, target) {
        var message = target !== null && target !== void 0 ? target : this.create(),
            end = reader.pos + length;

        while (reader.pos < end) {
          var _reader$tag = reader.tag(),
              _reader$tag2 = _slicedToArray(_reader$tag, 2),
              fieldNo = _reader$tag2[0],
              wireType = _reader$tag2[1];

          switch (fieldNo) {
            case
            /* bytes payload */
            1:
              message.payload = reader.bytes();
              break;

            case
            /* string contentTopic */
            2:
              message.contentTopic = reader.string();
              break;

            case
            /* uint32 version */
            3:
              message.version = reader.uint32();
              break;

            case
            /* string comeFrom */
            4:
              message.comeFrom = reader.string();
              break;

            case
            /* string fromSign */
            5:
              message.fromSign = reader.string();
              break;

            case
            /* string payloadType */
            6:
              message.payloadType = reader.string();
              break;

            case
            /* string cipherSuite */
            7:
              message.cipherSuite = reader.string();
              break;

            case
            /* bool needStore */
            8:
              message.needStore = reader.bool();
              break;

            case
            /* uint64 timestamp */
            9:
              message.timestamp = reader.uint64().toBigInt();
              break;

            case
            /* string messageId */
            10:
              message.messageId = reader.string();
              break;

            case
            /* optional string messageType */
            11:
              message.messageType = reader.string();
              break;

            case
            /* string nodeId */
            12:
              message.nodeId = reader.string();
              break;

            case
            /* string validatePubKey */
            13:
              message.validatePubKey = reader.string();
              break;

            case
            /* map<string, string> extraData */
            14:
              this.binaryReadMap14(message.extraData, reader);
              break;

            default:
              var u = options.readUnknownField;
              if (u === 'throw') throw new globalThis.Error("Unknown field ".concat(fieldNo, " (wire type ").concat(wireType, ") for ").concat(this.typeName));
              var d = reader.skip(wireType);
              if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
          }
        }

        return message;
      }
    }, {
      key: "binaryReadMap14",
      value: function binaryReadMap14(map, reader) {
        var _key, _val;

        var len = reader.uint32(),
            end = reader.pos + len,
            key,
            val;

        while (reader.pos < end) {
          var _reader$tag3 = reader.tag(),
              _reader$tag4 = _slicedToArray(_reader$tag3, 1),
              fieldNo = _reader$tag4[0];

          switch (fieldNo) {
            case 1:
              key = reader.string();
              break;

            case 2:
              val = reader.string();
              break;

            default:
              throw new globalThis.Error('unknown map entry field for field pb.Web3MQRequestMessage.extraData');
          }
        }

        map[(_key = key) !== null && _key !== void 0 ? _key : ''] = (_val = val) !== null && _val !== void 0 ? _val : '';
      }
    }, {
      key: "internalBinaryWrite",
      value: function internalBinaryWrite(message, writer, options) {
        /* bytes payload = 1; */
        if (message.payload.length) writer.tag(1, WireType.LengthDelimited).bytes(message.payload);
        /* string contentTopic = 2; */

        if (message.contentTopic !== '') writer.tag(2, WireType.LengthDelimited).string(message.contentTopic);
        /* uint32 version = 3; */

        if (message.version !== 0) writer.tag(3, WireType.Varint).uint32(message.version);
        /* string comeFrom = 4; */

        if (message.comeFrom !== '') writer.tag(4, WireType.LengthDelimited).string(message.comeFrom);
        /* string fromSign = 5; */

        if (message.fromSign !== '') writer.tag(5, WireType.LengthDelimited).string(message.fromSign);
        /* string payloadType = 6; */

        if (message.payloadType !== '') writer.tag(6, WireType.LengthDelimited).string(message.payloadType);
        /* string cipherSuite = 7; */

        if (message.cipherSuite !== '') writer.tag(7, WireType.LengthDelimited).string(message.cipherSuite);
        /* bool needStore = 8; */

        if (message.needStore !== false) writer.tag(8, WireType.Varint).bool(message.needStore);
        /* uint64 timestamp = 9; */

        if (message.timestamp !== 0n) writer.tag(9, WireType.Varint).uint64(message.timestamp);
        /* string messageId = 10; */

        if (message.messageId !== '') writer.tag(10, WireType.LengthDelimited).string(message.messageId);
        /* optional string messageType = 11; */

        if (message.messageType !== undefined) writer.tag(11, WireType.LengthDelimited).string(message.messageType);
        /* string nodeId = 12; */

        if (message.nodeId !== '') writer.tag(12, WireType.LengthDelimited).string(message.nodeId);
        /* string validatePubKey = 13; */

        if (message.validatePubKey !== '') writer.tag(13, WireType.LengthDelimited).string(message.validatePubKey);
        /* map<string, string> extraData = 14; */

        for (var _i = 0, _Object$keys = Object.keys(message.extraData); _i < _Object$keys.length; _i++) {
          var k = _Object$keys[_i];
          writer.tag(14, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.extraData[k]).join();
        }

        var u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
      }
    }]);

    return Web3MQRequestMessage$Type;
  }(MessageType);
  /**
   * @generated MessageType for protobuf message pb.Web3MQRequestMessage
   */


  var Web3MQRequestMessage = new Web3MQRequestMessage$Type(); // @generated message type with reflection information, may provide speed optimized methods

  var Web3MQMessageStatusResp$Type = /*#__PURE__*/function (_MessageType2) {
    _inherits(Web3MQMessageStatusResp$Type, _MessageType2);

    var _super2 = _createSuper(Web3MQMessageStatusResp$Type);

    function Web3MQMessageStatusResp$Type() {
      _classCallCheck(this, Web3MQMessageStatusResp$Type);

      return _super2.call(this, 'pb.Web3MQMessageStatusResp', [{
        no: 1,
        name: 'messageId',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 2,
        name: 'contentTopic',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 3,
        name: 'messageStatus',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 4,
        name: 'version',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 5,
        name: 'comeFrom',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 6,
        name: 'fromSign',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 7,
        name: 'timestamp',
        kind: 'scalar',
        T: 4
        /*ScalarType.UINT64*/
        ,
        L: 0
        /*LongType.BIGINT*/

      }]);
    }

    _createClass(Web3MQMessageStatusResp$Type, [{
      key: "create",
      value: function create(value) {
        var message = {
          messageId: '',
          contentTopic: '',
          messageStatus: '',
          version: '',
          comeFrom: '',
          fromSign: '',
          timestamp: 0n
        };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
          enumerable: false,
          value: this
        });
        if (value !== undefined) reflectionMergePartial(this, message, value);
        return message;
      }
    }, {
      key: "internalBinaryRead",
      value: function internalBinaryRead(reader, length, options, target) {
        var message = target !== null && target !== void 0 ? target : this.create(),
            end = reader.pos + length;

        while (reader.pos < end) {
          var _reader$tag5 = reader.tag(),
              _reader$tag6 = _slicedToArray(_reader$tag5, 2),
              fieldNo = _reader$tag6[0],
              wireType = _reader$tag6[1];

          switch (fieldNo) {
            case
            /* string messageId */
            1:
              message.messageId = reader.string();
              break;

            case
            /* string contentTopic */
            2:
              message.contentTopic = reader.string();
              break;

            case
            /* string messageStatus */
            3:
              message.messageStatus = reader.string();
              break;

            case
            /* string version */
            4:
              message.version = reader.string();
              break;

            case
            /* string comeFrom */
            5:
              message.comeFrom = reader.string();
              break;

            case
            /* string fromSign */
            6:
              message.fromSign = reader.string();
              break;

            case
            /* uint64 timestamp */
            7:
              message.timestamp = reader.uint64().toBigInt();
              break;

            default:
              var u = options.readUnknownField;
              if (u === 'throw') throw new globalThis.Error("Unknown field ".concat(fieldNo, " (wire type ").concat(wireType, ") for ").concat(this.typeName));
              var d = reader.skip(wireType);
              if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
          }
        }

        return message;
      }
    }, {
      key: "internalBinaryWrite",
      value: function internalBinaryWrite(message, writer, options) {
        /* string messageId = 1; */
        if (message.messageId !== '') writer.tag(1, WireType.LengthDelimited).string(message.messageId);
        /* string contentTopic = 2; */

        if (message.contentTopic !== '') writer.tag(2, WireType.LengthDelimited).string(message.contentTopic);
        /* string messageStatus = 3; */

        if (message.messageStatus !== '') writer.tag(3, WireType.LengthDelimited).string(message.messageStatus);
        /* string version = 4; */

        if (message.version !== '') writer.tag(4, WireType.LengthDelimited).string(message.version);
        /* string comeFrom = 5; */

        if (message.comeFrom !== '') writer.tag(5, WireType.LengthDelimited).string(message.comeFrom);
        /* string fromSign = 6; */

        if (message.fromSign !== '') writer.tag(6, WireType.LengthDelimited).string(message.fromSign);
        /* uint64 timestamp = 7; */

        if (message.timestamp !== 0n) writer.tag(7, WireType.Varint).uint64(message.timestamp);
        var u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
      }
    }]);

    return Web3MQMessageStatusResp$Type;
  }(MessageType);
  /**
   * @generated MessageType for protobuf message pb.Web3MQMessageStatusResp
   */


  var Web3MQMessageStatusResp = new Web3MQMessageStatusResp$Type(); // @generated message type with reflection information, may provide speed optimized methods

  var Web3MQChangeMessageStatus$Type = /*#__PURE__*/function (_MessageType3) {
    _inherits(Web3MQChangeMessageStatus$Type, _MessageType3);

    var _super3 = _createSuper(Web3MQChangeMessageStatus$Type);

    function Web3MQChangeMessageStatus$Type() {
      _classCallCheck(this, Web3MQChangeMessageStatus$Type);

      return _super3.call(this, 'pb.Web3MQChangeMessageStatus', [{
        no: 1,
        name: 'messageId',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 2,
        name: 'contentTopic',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 3,
        name: 'messageStatus',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 4,
        name: 'version',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 5,
        name: 'comeFrom',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 6,
        name: 'fromSign',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 7,
        name: 'timestamp',
        kind: 'scalar',
        T: 4
        /*ScalarType.UINT64*/
        ,
        L: 0
        /*LongType.BIGINT*/

      }]);
    }

    _createClass(Web3MQChangeMessageStatus$Type, [{
      key: "create",
      value: function create(value) {
        var message = {
          messageId: '',
          contentTopic: '',
          messageStatus: '',
          version: '',
          comeFrom: '',
          fromSign: '',
          timestamp: 0n
        };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
          enumerable: false,
          value: this
        });
        if (value !== undefined) reflectionMergePartial(this, message, value);
        return message;
      }
    }, {
      key: "internalBinaryRead",
      value: function internalBinaryRead(reader, length, options, target) {
        var message = target !== null && target !== void 0 ? target : this.create(),
            end = reader.pos + length;

        while (reader.pos < end) {
          var _reader$tag7 = reader.tag(),
              _reader$tag8 = _slicedToArray(_reader$tag7, 2),
              fieldNo = _reader$tag8[0],
              wireType = _reader$tag8[1];

          switch (fieldNo) {
            case
            /* string messageId */
            1:
              message.messageId = reader.string();
              break;

            case
            /* string contentTopic */
            2:
              message.contentTopic = reader.string();
              break;

            case
            /* string messageStatus */
            3:
              message.messageStatus = reader.string();
              break;

            case
            /* string version */
            4:
              message.version = reader.string();
              break;

            case
            /* string comeFrom */
            5:
              message.comeFrom = reader.string();
              break;

            case
            /* string fromSign */
            6:
              message.fromSign = reader.string();
              break;

            case
            /* uint64 timestamp */
            7:
              message.timestamp = reader.uint64().toBigInt();
              break;

            default:
              var u = options.readUnknownField;
              if (u === 'throw') throw new globalThis.Error("Unknown field ".concat(fieldNo, " (wire type ").concat(wireType, ") for ").concat(this.typeName));
              var d = reader.skip(wireType);
              if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
          }
        }

        return message;
      }
    }, {
      key: "internalBinaryWrite",
      value: function internalBinaryWrite(message, writer, options) {
        /* string messageId = 1; */
        if (message.messageId !== '') writer.tag(1, WireType.LengthDelimited).string(message.messageId);
        /* string contentTopic = 2; */

        if (message.contentTopic !== '') writer.tag(2, WireType.LengthDelimited).string(message.contentTopic);
        /* string messageStatus = 3; */

        if (message.messageStatus !== '') writer.tag(3, WireType.LengthDelimited).string(message.messageStatus);
        /* string version = 4; */

        if (message.version !== '') writer.tag(4, WireType.LengthDelimited).string(message.version);
        /* string comeFrom = 5; */

        if (message.comeFrom !== '') writer.tag(5, WireType.LengthDelimited).string(message.comeFrom);
        /* string fromSign = 6; */

        if (message.fromSign !== '') writer.tag(6, WireType.LengthDelimited).string(message.fromSign);
        /* uint64 timestamp = 7; */

        if (message.timestamp !== 0n) writer.tag(7, WireType.Varint).uint64(message.timestamp);
        var u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
      }
    }]);

    return Web3MQChangeMessageStatus$Type;
  }(MessageType);
  /**
   * @generated MessageType for protobuf message pb.Web3MQChangeMessageStatus
   */


  var Web3MQChangeMessageStatus = new Web3MQChangeMessageStatus$Type(); // @generated message type with reflection information, may provide speed optimized methods

  var MessageItem$Type = /*#__PURE__*/function (_MessageType4) {
    _inherits(MessageItem$Type, _MessageType4);

    var _super4 = _createSuper(MessageItem$Type);

    function MessageItem$Type() {
      _classCallCheck(this, MessageItem$Type);

      return _super4.call(this, 'pb.MessageItem', [{
        no: 1,
        name: 'messageId',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 2,
        name: 'version',
        kind: 'scalar',
        T: 13
        /*ScalarType.UINT32*/

      }, {
        no: 3,
        name: 'payload',
        kind: 'scalar',
        T: 12
        /*ScalarType.BYTES*/

      }, {
        no: 4,
        name: 'payloadType',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 5,
        name: 'comeFrom',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 6,
        name: 'fromSign',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 7,
        name: 'contentTopic',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 8,
        name: 'cipherSuite',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 9,
        name: 'timestamp',
        kind: 'scalar',
        T: 4
        /*ScalarType.UINT64*/
        ,
        L: 0
        /*LongType.BIGINT*/

      }, {
        no: 10,
        name: 'read',
        kind: 'scalar',
        T: 8
        /*ScalarType.BOOL*/

      }, {
        no: 11,
        name: 'readTimestamp',
        kind: 'scalar',
        T: 4
        /*ScalarType.UINT64*/
        ,
        L: 0
        /*LongType.BIGINT*/

      }]);
    }

    _createClass(MessageItem$Type, [{
      key: "create",
      value: function create(value) {
        var message = {
          messageId: '',
          version: 0,
          payload: new Uint8Array(0),
          payloadType: '',
          comeFrom: '',
          fromSign: '',
          contentTopic: '',
          cipherSuite: '',
          timestamp: 0n,
          read: false,
          readTimestamp: 0n
        };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
          enumerable: false,
          value: this
        });
        if (value !== undefined) reflectionMergePartial(this, message, value);
        return message;
      }
    }, {
      key: "internalBinaryRead",
      value: function internalBinaryRead(reader, length, options, target) {
        var message = target !== null && target !== void 0 ? target : this.create(),
            end = reader.pos + length;

        while (reader.pos < end) {
          var _reader$tag9 = reader.tag(),
              _reader$tag10 = _slicedToArray(_reader$tag9, 2),
              fieldNo = _reader$tag10[0],
              wireType = _reader$tag10[1];

          switch (fieldNo) {
            case
            /* string messageId */
            1:
              message.messageId = reader.string();
              break;

            case
            /* uint32 version */
            2:
              message.version = reader.uint32();
              break;

            case
            /* bytes payload */
            3:
              message.payload = reader.bytes();
              break;

            case
            /* string payloadType */
            4:
              message.payloadType = reader.string();
              break;

            case
            /* string comeFrom */
            5:
              message.comeFrom = reader.string();
              break;

            case
            /* string fromSign */
            6:
              message.fromSign = reader.string();
              break;

            case
            /* string contentTopic */
            7:
              message.contentTopic = reader.string();
              break;

            case
            /* string cipherSuite */
            8:
              message.cipherSuite = reader.string();
              break;

            case
            /* uint64 timestamp */
            9:
              message.timestamp = reader.uint64().toBigInt();
              break;

            case
            /* bool read */
            10:
              message.read = reader.bool();
              break;

            case
            /* uint64 readTimestamp */
            11:
              message.readTimestamp = reader.uint64().toBigInt();
              break;

            default:
              var u = options.readUnknownField;
              if (u === 'throw') throw new globalThis.Error("Unknown field ".concat(fieldNo, " (wire type ").concat(wireType, ") for ").concat(this.typeName));
              var d = reader.skip(wireType);
              if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
          }
        }

        return message;
      }
    }, {
      key: "internalBinaryWrite",
      value: function internalBinaryWrite(message, writer, options) {
        /* string messageId = 1; */
        if (message.messageId !== '') writer.tag(1, WireType.LengthDelimited).string(message.messageId);
        /* uint32 version = 2; */

        if (message.version !== 0) writer.tag(2, WireType.Varint).uint32(message.version);
        /* bytes payload = 3; */

        if (message.payload.length) writer.tag(3, WireType.LengthDelimited).bytes(message.payload);
        /* string payloadType = 4; */

        if (message.payloadType !== '') writer.tag(4, WireType.LengthDelimited).string(message.payloadType);
        /* string comeFrom = 5; */

        if (message.comeFrom !== '') writer.tag(5, WireType.LengthDelimited).string(message.comeFrom);
        /* string fromSign = 6; */

        if (message.fromSign !== '') writer.tag(6, WireType.LengthDelimited).string(message.fromSign);
        /* string contentTopic = 7; */

        if (message.contentTopic !== '') writer.tag(7, WireType.LengthDelimited).string(message.contentTopic);
        /* string cipherSuite = 8; */

        if (message.cipherSuite !== '') writer.tag(8, WireType.LengthDelimited).string(message.cipherSuite);
        /* uint64 timestamp = 9; */

        if (message.timestamp !== 0n) writer.tag(9, WireType.Varint).uint64(message.timestamp);
        /* bool read = 10; */

        if (message.read !== false) writer.tag(10, WireType.Varint).bool(message.read);
        /* uint64 readTimestamp = 11; */

        if (message.readTimestamp !== 0n) writer.tag(11, WireType.Varint).uint64(message.readTimestamp);
        var u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
      }
    }]);

    return MessageItem$Type;
  }(MessageType);
  /**
   * @generated MessageType for protobuf message pb.MessageItem
   */


  var MessageItem = new MessageItem$Type(); // @generated message type with reflection information, may provide speed optimized methods

  var Web3MQMessageListResponse$Type = /*#__PURE__*/function (_MessageType5) {
    _inherits(Web3MQMessageListResponse$Type, _MessageType5);

    var _super5 = _createSuper(Web3MQMessageListResponse$Type);

    function Web3MQMessageListResponse$Type() {
      _classCallCheck(this, Web3MQMessageListResponse$Type);

      return _super5.call(this, 'pb.Web3MQMessageListResponse', [{
        no: 1,
        name: 'data',
        kind: 'message',
        repeat: 1
        /*RepeatType.PACKED*/
        ,
        T: function T() {
          return MessageItem;
        }
      }]);
    }

    _createClass(Web3MQMessageListResponse$Type, [{
      key: "create",
      value: function create(value) {
        var message = {
          data: []
        };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
          enumerable: false,
          value: this
        });
        if (value !== undefined) reflectionMergePartial(this, message, value);
        return message;
      }
    }, {
      key: "internalBinaryRead",
      value: function internalBinaryRead(reader, length, options, target) {
        var message = target !== null && target !== void 0 ? target : this.create(),
            end = reader.pos + length;

        while (reader.pos < end) {
          var _reader$tag11 = reader.tag(),
              _reader$tag12 = _slicedToArray(_reader$tag11, 2),
              fieldNo = _reader$tag12[0],
              wireType = _reader$tag12[1];

          switch (fieldNo) {
            case
            /* repeated pb.MessageItem data */
            1:
              message.data.push(MessageItem.internalBinaryRead(reader, reader.uint32(), options));
              break;

            default:
              var u = options.readUnknownField;
              if (u === 'throw') throw new globalThis.Error("Unknown field ".concat(fieldNo, " (wire type ").concat(wireType, ") for ").concat(this.typeName));
              var d = reader.skip(wireType);
              if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
          }
        }

        return message;
      }
    }, {
      key: "internalBinaryWrite",
      value: function internalBinaryWrite(message, writer, options) {
        /* repeated pb.MessageItem data = 1; */
        for (var i = 0; i < message.data.length; i++) {
          MessageItem.internalBinaryWrite(message.data[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        }

        var u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
      }
    }]);

    return Web3MQMessageListResponse$Type;
  }(MessageType);
  /**
   * @generated MessageType for protobuf message pb.Web3MQMessageListResponse
   */


  var Web3MQMessageListResponse = new Web3MQMessageListResponse$Type(); // @generated message type with reflection information, may provide speed optimized methods

  var GetHistoryMessagesRequest$Type = /*#__PURE__*/function (_MessageType6) {
    _inherits(GetHistoryMessagesRequest$Type, _MessageType6);

    var _super6 = _createSuper(GetHistoryMessagesRequest$Type);

    function GetHistoryMessagesRequest$Type() {
      _classCallCheck(this, GetHistoryMessagesRequest$Type);

      return _super6.call(this, 'pb.GetHistoryMessagesRequest', [{
        no: 1,
        name: 'comeFrom',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 2,
        name: 'fromSign',
        kind: 'scalar',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 3,
        name: 'version',
        kind: 'scalar',
        T: 13
        /*ScalarType.UINT32*/

      }, {
        no: 4,
        name: 'timestamp',
        kind: 'scalar',
        T: 4
        /*ScalarType.UINT64*/
        ,
        L: 0
        /*LongType.BIGINT*/

      }]);
    }

    _createClass(GetHistoryMessagesRequest$Type, [{
      key: "create",
      value: function create(value) {
        var message = {
          comeFrom: '',
          fromSign: '',
          version: 0,
          timestamp: 0n
        };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
          enumerable: false,
          value: this
        });
        if (value !== undefined) reflectionMergePartial(this, message, value);
        return message;
      }
    }, {
      key: "internalBinaryRead",
      value: function internalBinaryRead(reader, length, options, target) {
        var message = target !== null && target !== void 0 ? target : this.create(),
            end = reader.pos + length;

        while (reader.pos < end) {
          var _reader$tag13 = reader.tag(),
              _reader$tag14 = _slicedToArray(_reader$tag13, 2),
              fieldNo = _reader$tag14[0],
              wireType = _reader$tag14[1];

          switch (fieldNo) {
            case
            /* string comeFrom */
            1:
              message.comeFrom = reader.string();
              break;

            case
            /* string fromSign */
            2:
              message.fromSign = reader.string();
              break;

            case
            /* uint32 version */
            3:
              message.version = reader.uint32();
              break;

            case
            /* uint64 timestamp */
            4:
              message.timestamp = reader.uint64().toBigInt();
              break;

            default:
              var u = options.readUnknownField;
              if (u === 'throw') throw new globalThis.Error("Unknown field ".concat(fieldNo, " (wire type ").concat(wireType, ") for ").concat(this.typeName));
              var d = reader.skip(wireType);
              if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
          }
        }

        return message;
      }
    }, {
      key: "internalBinaryWrite",
      value: function internalBinaryWrite(message, writer, options) {
        /* string comeFrom = 1; */
        if (message.comeFrom !== '') writer.tag(1, WireType.LengthDelimited).string(message.comeFrom);
        /* string fromSign = 2; */

        if (message.fromSign !== '') writer.tag(2, WireType.LengthDelimited).string(message.fromSign);
        /* uint32 version = 3; */

        if (message.version !== 0) writer.tag(3, WireType.Varint).uint32(message.version);
        /* uint64 timestamp = 4; */

        if (message.timestamp !== 0n) writer.tag(4, WireType.Varint).uint64(message.timestamp);
        var u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
      }
    }]);

    return GetHistoryMessagesRequest$Type;
  }(MessageType);
  /**
   * @generated MessageType for protobuf message pb.GetHistoryMessagesRequest
   */


  new GetHistoryMessagesRequest$Type();

  var WebsocketPingCommand$Type = /*#__PURE__*/function (_MessageType) {
    _inherits(WebsocketPingCommand$Type, _MessageType);

    var _super = _createSuper(WebsocketPingCommand$Type);

    function WebsocketPingCommand$Type() {
      _classCallCheck(this, WebsocketPingCommand$Type);

      return _super.call(this, 'pb.WebsocketPingCommand', [{
        no: 1,
        name: 'nodeId',
        kind: 'scalar',
        opt: true,
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 2,
        name: 'userId',
        kind: 'scalar',
        opt: true,
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 3,
        name: 'timestamp',
        kind: 'scalar',
        opt: true,
        T: 4
        /*ScalarType.UINT64*/
        ,
        L: 0
        /*LongType.BIGINT*/

      }, {
        no: 4,
        name: 'msgSign',
        kind: 'scalar',
        opt: true,
        T: 9
        /*ScalarType.STRING*/

      }]);
    }

    _createClass(WebsocketPingCommand$Type, [{
      key: "create",
      value: function create(value) {
        var message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
          enumerable: false,
          value: this
        });
        if (value !== undefined) reflectionMergePartial(this, message, value);
        return message;
      }
    }, {
      key: "internalBinaryRead",
      value: function internalBinaryRead(reader, length, options, target) {
        var message = target !== null && target !== void 0 ? target : this.create(),
            end = reader.pos + length;

        while (reader.pos < end) {
          var _reader$tag = reader.tag(),
              _reader$tag2 = _slicedToArray(_reader$tag, 2),
              fieldNo = _reader$tag2[0],
              wireType = _reader$tag2[1];

          switch (fieldNo) {
            case
            /* optional string nodeId */
            1:
              message.nodeId = reader.string();
              break;

            case
            /* optional string userId */
            2:
              message.userId = reader.string();
              break;

            case
            /* optional uint64 timestamp */
            3:
              message.timestamp = reader.uint64().toBigInt();
              break;

            case
            /* optional string msgSign */
            4:
              message.msgSign = reader.string();
              break;

            default:
              var u = options.readUnknownField;
              if (u === 'throw') throw new globalThis.Error("Unknown field ".concat(fieldNo, " (wire type ").concat(wireType, ") for ").concat(this.typeName));
              var d = reader.skip(wireType);
              if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
          }
        }

        return message;
      }
    }, {
      key: "internalBinaryWrite",
      value: function internalBinaryWrite(message, writer, options) {
        /* optional string nodeId = 1; */
        if (message.nodeId !== undefined) writer.tag(1, WireType.LengthDelimited).string(message.nodeId);
        /* optional string userId = 2; */

        if (message.userId !== undefined) writer.tag(2, WireType.LengthDelimited).string(message.userId);
        /* optional uint64 timestamp = 3; */

        if (message.timestamp !== undefined) writer.tag(3, WireType.Varint).uint64(message.timestamp);
        /* optional string msgSign = 4; */

        if (message.msgSign !== undefined) writer.tag(4, WireType.LengthDelimited).string(message.msgSign);
        var u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
      }
    }]);

    return WebsocketPingCommand$Type;
  }(MessageType);
  /**
   * @generated MessageType for protobuf message pb.WebsocketPingCommand
   */


  var WebsocketPingCommand = new WebsocketPingCommand$Type(); // @generated message type with reflection information, may provide speed optimized methods

  var WebsocketPongCommand$Type = /*#__PURE__*/function (_MessageType2) {
    _inherits(WebsocketPongCommand$Type, _MessageType2);

    var _super2 = _createSuper(WebsocketPongCommand$Type);

    function WebsocketPongCommand$Type() {
      _classCallCheck(this, WebsocketPongCommand$Type);

      return _super2.call(this, 'pb.WebsocketPongCommand', [{
        no: 1,
        name: 'nodeId',
        kind: 'scalar',
        opt: true,
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 2,
        name: 'userId',
        kind: 'scalar',
        opt: true,
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 3,
        name: 'timestamp',
        kind: 'scalar',
        opt: true,
        T: 4
        /*ScalarType.UINT64*/
        ,
        L: 0
        /*LongType.BIGINT*/

      }, {
        no: 4,
        name: 'msgSign',
        kind: 'scalar',
        opt: true,
        T: 9
        /*ScalarType.STRING*/

      }]);
    }

    _createClass(WebsocketPongCommand$Type, [{
      key: "create",
      value: function create(value) {
        var message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
          enumerable: false,
          value: this
        });
        if (value !== undefined) reflectionMergePartial(this, message, value);
        return message;
      }
    }, {
      key: "internalBinaryRead",
      value: function internalBinaryRead(reader, length, options, target) {
        var message = target !== null && target !== void 0 ? target : this.create(),
            end = reader.pos + length;

        while (reader.pos < end) {
          var _reader$tag3 = reader.tag(),
              _reader$tag4 = _slicedToArray(_reader$tag3, 2),
              fieldNo = _reader$tag4[0],
              wireType = _reader$tag4[1];

          switch (fieldNo) {
            case
            /* optional string nodeId */
            1:
              message.nodeId = reader.string();
              break;

            case
            /* optional string userId */
            2:
              message.userId = reader.string();
              break;

            case
            /* optional uint64 timestamp */
            3:
              message.timestamp = reader.uint64().toBigInt();
              break;

            case
            /* optional string msgSign */
            4:
              message.msgSign = reader.string();
              break;

            default:
              var u = options.readUnknownField;
              if (u === 'throw') throw new globalThis.Error("Unknown field ".concat(fieldNo, " (wire type ").concat(wireType, ") for ").concat(this.typeName));
              var d = reader.skip(wireType);
              if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
          }
        }

        return message;
      }
    }, {
      key: "internalBinaryWrite",
      value: function internalBinaryWrite(message, writer, options) {
        /* optional string nodeId = 1; */
        if (message.nodeId !== undefined) writer.tag(1, WireType.LengthDelimited).string(message.nodeId);
        /* optional string userId = 2; */

        if (message.userId !== undefined) writer.tag(2, WireType.LengthDelimited).string(message.userId);
        /* optional uint64 timestamp = 3; */

        if (message.timestamp !== undefined) writer.tag(3, WireType.Varint).uint64(message.timestamp);
        /* optional string msgSign = 4; */

        if (message.msgSign !== undefined) writer.tag(4, WireType.LengthDelimited).string(message.msgSign);
        var u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
      }
    }]);

    return WebsocketPongCommand$Type;
  }(MessageType);
  /**
   * @generated MessageType for protobuf message pb.WebsocketPongCommand
   */


  new WebsocketPongCommand$Type();

  var Web3MQBridgeConnectCommand$Type = /*#__PURE__*/function (_MessageType) {
    _inherits(Web3MQBridgeConnectCommand$Type, _MessageType);

    var _super = _createSuper(Web3MQBridgeConnectCommand$Type);

    function Web3MQBridgeConnectCommand$Type() {
      _classCallCheck(this, Web3MQBridgeConnectCommand$Type);

      return _super.call(this, 'pb.Web3MQBridgeConnectCommand', [{
        no: 1,
        name: 'NodeID',
        kind: 'scalar',
        jsonName: 'NodeID',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 2,
        name: 'DAppID',
        kind: 'scalar',
        jsonName: 'DAppID',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 3,
        name: 'TopicID',
        kind: 'scalar',
        jsonName: 'TopicID',
        T: 9
        /*ScalarType.STRING*/

      }, {
        no: 4,
        name: 'SignatureTimestamp',
        kind: 'scalar',
        jsonName: 'SignatureTimestamp',
        opt: true,
        T: 4
        /*ScalarType.UINT64*/
        ,
        L: 0
        /*LongType.BIGINT*/

      }, {
        no: 5,
        name: 'DAppSignature',
        kind: 'scalar',
        jsonName: 'DAppSignature',
        opt: true,
        T: 9
        /*ScalarType.STRING*/

      }]);
    }

    _createClass(Web3MQBridgeConnectCommand$Type, [{
      key: "create",
      value: function create(value) {
        var message = {
          nodeID: '',
          dAppID: '',
          topicID: ''
        };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
          enumerable: false,
          value: this
        });
        if (value !== undefined) reflectionMergePartial(this, message, value);
        return message;
      }
    }, {
      key: "internalBinaryRead",
      value: function internalBinaryRead(reader, length, options, target) {
        var message = target !== null && target !== void 0 ? target : this.create(),
            end = reader.pos + length;

        while (reader.pos < end) {
          var _reader$tag = reader.tag(),
              _reader$tag2 = _slicedToArray(_reader$tag, 2),
              fieldNo = _reader$tag2[0],
              wireType = _reader$tag2[1];

          switch (fieldNo) {
            /* string NodeID = 1 [json_name = "NodeID"];*/
            case 1:
              message.nodeID = reader.string();
              break;

            /* string DAppID = 2 [json_name = "DAppID"];*/

            case 2:
              message.dAppID = reader.string();
              break;

            /* string TopicID = 3 [json_name = "TopicID"];*/

            case 3:
              message.topicID = reader.string();
              break;

            /* optional uint64 SignatureTimestamp = 4 [json_name = "SignatureTimestamp"];*/

            case 4:
              message.signatureTimestamp = reader.uint64().toBigInt();
              break;

            /* optional string DAppSignature = 5 [json_name = "DAppSignature"];*/

            case 5:
              message.dAppSignature = reader.string();
              break;

            default:
              var u = options.readUnknownField;
              if (u === 'throw') throw new globalThis.Error("Unknown field ".concat(fieldNo, " (wire type ").concat(wireType, ") for ").concat(this.typeName));
              var d = reader.skip(wireType);
              if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
          }
        }

        return message;
      }
    }, {
      key: "internalBinaryWrite",
      value: function internalBinaryWrite(message, writer, options) {
        /* string NodeID = 1 [json_name = "NodeID"]; */
        if (message.nodeID !== '') writer.tag(1, WireType.LengthDelimited).string(message.nodeID);
        /* string DAppID = 2 [json_name = "DAppID"]; */

        if (message.dAppID !== '') writer.tag(2, WireType.LengthDelimited).string(message.dAppID);
        /* string TopicID = 3 [json_name = "TopicID"]; */

        if (message.topicID !== '') writer.tag(3, WireType.LengthDelimited).string(message.topicID);
        /* optional uint64 SignatureTimestamp = 4 [json_name = "SignatureTimestamp"]; */

        if (message.signatureTimestamp !== undefined) writer.tag(4, WireType.Varint).uint64(message.signatureTimestamp);
        /* optional string DAppSignature = 5 [json_name = "DAppSignature"]; */

        if (message.dAppSignature !== undefined) writer.tag(5, WireType.LengthDelimited).string(message.dAppSignature);
        var u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
      }
    }]);

    return Web3MQBridgeConnectCommand$Type;
  }(MessageType);
  /**
   * @generated MessageType for protobuf message pb.Web3MQBridgeConnectCommand
   */


  var Web3MQBridgeConnectCommand = new Web3MQBridgeConnectCommand$Type();

  var GenerateMessageID = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(from, topic, timestamp, payload) {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", jsSha3.sha3_224.update(from).update(topic).update(timestamp.toString()).update(payload).hex());

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function GenerateMessageID(_x, _x2, _x3, _x4) {
      return _ref.apply(this, arguments);
    };
  }();

  var sendConnectCommand = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(keys) {
      var PrivateKey, userid, timestamp, nodeId, ts, prestr, signature, reqCmd, bytes, concatArray;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              PrivateKey = keys.PrivateKey, userid = keys.userid;
              timestamp = Date.now();
              nodeId = 'nodeId';
              ts = BigInt(timestamp);
              prestr = nodeId + userid + ts.toString();
              _context2.next = 7;
              return getDataSignature(PrivateKey, prestr);

            case 7:
              signature = _context2.sent;
              reqCmd = {
                nodeId: nodeId,
                userId: userid,
                timestamp: ts,
                msgSign: signature
              };
              bytes = ConnectCommand.toBinary(reqCmd);
              concatArray = GetContactBytes(PbTypeConnectReqCommand, bytes);
              return _context2.abrupt("return", concatArray);

            case 12:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function sendConnectCommand(_x5) {
      return _ref2.apply(this, arguments);
    };
  }();
  var sendTempConnectCommand = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(options) {
      var dAppID, topicID, signatureTimestamp, dAppSignature, reqCmd, bytes, concatArray;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              dAppID = options.dAppID, topicID = options.topicID, signatureTimestamp = options.signatureTimestamp, dAppSignature = options.dAppSignature;
              reqCmd = {
                nodeID: '',
                dAppID: dAppID,
                topicID: topicID.toLowerCase(),
                signatureTimestamp: BigInt(signatureTimestamp),
                dAppSignature: dAppSignature
              };
              bytes = UserTempConnectCommand.toBinary(reqCmd);
              concatArray = GetContactBytes(PbTypeUserTempConnectReqCommand, bytes);
              return _context3.abrupt("return", concatArray);

            case 5:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    return function sendTempConnectCommand(_x6) {
      return _ref3.apply(this, arguments);
    };
  }();
  var sendDappBridgeCommand = /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(options) {
      var nodeId, payload, contentTopic, comeFrom, timestamp, cipherSuite, needStore, reqCmd, bytes, concatArray;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              nodeId = options.nodeId, payload = options.payload, contentTopic = options.contentTopic, comeFrom = options.comeFrom;
              timestamp = Date.now();
              cipherSuite = 'NONE';
              needStore = true;
              reqCmd = {
                payload: payload,
                contentTopic: contentTopic,
                version: 1,
                comeFrom: comeFrom,
                fromSign: '',
                payloadType: 'application/json',
                cipherSuite: cipherSuite,
                needStore: needStore,
                timestamp: BigInt(timestamp),
                messageId: '',
                nodeId: nodeId,
                messageType: 'dapp_bridge',
                validatePubKey: '',
                extraData: {}
              };
              bytes = Web3MQRequestMessage.toBinary(reqCmd);
              concatArray = GetContactBytes(PbTypeMessage, bytes);
              return _context4.abrupt("return", concatArray);

            case 8:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    return function sendDappBridgeCommand(_x7) {
      return _ref4.apply(this, arguments);
    };
  }();
  var sendMessageCommand = /*#__PURE__*/function () {
    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(keys, topic, msg, nodeId) {
      var userid, PrivateKey, PublicKey, timestamp, cipherSuite, byteData, msgid, signContent, fromSign, needStore, msgReq, bytes, concatArray;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              userid = keys.userid, PrivateKey = keys.PrivateKey, PublicKey = keys.PublicKey;
              timestamp = Date.now();
              cipherSuite = 'NONE';
              byteData = new TextEncoder().encode(msg);
              _context5.next = 6;
              return GenerateMessageID(userid, topic, timestamp, byteData);

            case 6:
              msgid = _context5.sent;
              signContent = msgid + userid + topic + nodeId + timestamp.toString();
              _context5.next = 10;
              return getDataSignature(PrivateKey, signContent);

            case 10:
              fromSign = _context5.sent;
              needStore = true;
              msgReq = {
                payload: byteData,
                contentTopic: topic,
                version: 1,
                comeFrom: userid,
                fromSign: fromSign,
                payloadType: 'text/plain; charset=utf-8',
                cipherSuite: cipherSuite,
                needStore: needStore,
                timestamp: BigInt(timestamp),
                messageId: msgid,
                nodeId: nodeId,
                validatePubKey: PublicKey,
                extraData: {}
              };
              bytes = Web3MQRequestMessage.toBinary(msgReq);
              concatArray = GetContactBytes(PbTypeMessage, bytes);
              return _context5.abrupt("return", {
                concatArray: concatArray,
                msgid: msgid
              });

            case 16:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));

    return function sendMessageCommand(_x8, _x9, _x10, _x11) {
      return _ref5.apply(this, arguments);
    };
  }();
  var sendWeb3mqBridgeCommand = /*#__PURE__*/function () {
    var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(options) {
      var nodeID, dAppID, topicID, _options$signatureTim, signatureTimestamp, _options$dAppSignatur, dAppSignature, reqCmd, bytes, concatArray;

      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              nodeID = options.nodeID, dAppID = options.dAppID, topicID = options.topicID, _options$signatureTim = options.signatureTimestamp, signatureTimestamp = _options$signatureTim === void 0 ? 0 : _options$signatureTim, _options$dAppSignatur = options.dAppSignature, dAppSignature = _options$dAppSignatur === void 0 ? '' : _options$dAppSignatur;
              reqCmd = {
                nodeID: nodeID,
                dAppID: dAppID,
                topicID: topicID,
                signatureTimestamp: BigInt(signatureTimestamp),
                dAppSignature: dAppSignature
              };
              bytes = Web3MQBridgeConnectCommand.toBinary(reqCmd);
              concatArray = GetContactBytes(PbTypeWeb3MQBridgeConnectCommand, bytes);
              return _context6.abrupt("return", concatArray);

            case 5:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }));

    return function sendWeb3mqBridgeCommand(_x12) {
      return _ref6.apply(this, arguments);
    };
  }();
  var sendWeb3mqSignatureCommand = /*#__PURE__*/function () {
    var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(options) {
      var nodeId, payload, contentTopic, comeFrom, validatePubKey, PrivateKey, timestamp, cipherSuite, needStore, msgid, signContent, fromSign, reqCmd, bytes, concatArray;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              nodeId = options.nodeId, payload = options.payload, contentTopic = options.contentTopic, comeFrom = options.comeFrom, validatePubKey = options.validatePubKey, PrivateKey = options.PrivateKey;
              timestamp = Date.now();
              cipherSuite = 'NONE';
              needStore = true;
              _context7.next = 6;
              return GenerateMessageID(contentTopic, contentTopic, timestamp, payload);

            case 6:
              msgid = _context7.sent;
              signContent = msgid + comeFrom + contentTopic + nodeId + timestamp.toString();
              _context7.next = 10;
              return getDataSignature(PrivateKey, signContent);

            case 10:
              fromSign = _context7.sent;
              reqCmd = {
                payload: payload,
                contentTopic: contentTopic,
                version: 1,
                comeFrom: comeFrom,
                fromSign: fromSign,
                payloadType: 'application/json',
                cipherSuite: cipherSuite,
                needStore: needStore,
                timestamp: BigInt(timestamp),
                messageId: msgid,
                nodeId: nodeId,
                messageType: 'Web3MQ/bridge',
                validatePubKey: validatePubKey,
                extraData: {}
              };
              bytes = Web3MQRequestMessage.toBinary(reqCmd);
              concatArray = GetContactBytes(PbTypeMessage, bytes);
              return _context7.abrupt("return", concatArray);

            case 15:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    }));

    return function sendWeb3mqSignatureCommand(_x13) {
      return _ref7.apply(this, arguments);
    };
  }();

  var SignConnect = /*#__PURE__*/function () {
    // eslint-disable-next-line no-unused-vars
    // eslint-disable-next-line no-unused-vars
    function SignConnect(_options, callback) {
      var _this = this;

      _classCallCheck(this, SignConnect);

      _defineProperty(this, "_options", void 0);

      _defineProperty(this, "timeout", void 0);

      _defineProperty(this, "timeoutObj", void 0);

      _defineProperty(this, "ws", void 0);

      _defineProperty(this, "wsUrl", void 0);

      _defineProperty(this, "nodeId", void 0);

      _defineProperty(this, "walletUserInfo", void 0);

      _defineProperty(this, "tempKeys", void 0);

      _defineProperty(this, "tempCode", void 0);

      _defineProperty(this, "shareKey", void 0);

      _defineProperty(this, "AesKey", void 0);

      _defineProperty(this, "AesIv", void 0);

      _defineProperty(this, "callback", void 0);

      _defineProperty(this, "getWalletUserInfo", /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(params) {
          var did_type, did_value, timestamp, _yield$getUserInfoReq, data;

          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  did_type = params.did_type, did_value = params.did_value;
                  timestamp = Date.now();
                  _context.prev = 2;
                  _context.next = 5;
                  return getUserInfoRequest({
                    did_type: did_type,
                    did_value: did_value,
                    timestamp: timestamp
                  });

                case 5:
                  _yield$getUserInfoReq = _context.sent;
                  data = _yield$getUserInfoReq.data;
                  _this.walletUserInfo = data;
                  _context.next = 13;
                  break;

                case 10:
                  _context.prev = 10;
                  _context.t0 = _context["catch"](2);
                  throw new Error('get wallte user info error');

                case 13:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[2, 10]]);
        }));

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }());

      _defineProperty(this, "handleExchangeKey", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var keys, PrivateKey, targetPubkey, shareKey, AesKey, AesIv;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return GenerateEd25519KeyPair();

              case 2:
                keys = _context2.sent;
                _this.tempKeys = keys;
                PrivateKey = keys.PrivateKey;

                if (!_this.walletUserInfo) {
                  _context2.next = 17;
                  break;
                }

                targetPubkey = _this.walletUserInfo.pubkey;
                _context2.next = 9;
                return getMessageSharedSecret(PrivateKey, targetPubkey);

              case 9:
                shareKey = _context2.sent;
                _this.shareKey = shareKey;
                _context2.next = 13;
                return GetAESBase64Key(_this.shareKey);

              case 13:
                AesKey = _context2.sent;
                AesIv = AesKey.slice(0, 16);
                _this.AesKey = AesKey;
                _this.AesIv = AesIv;

              case 17:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      })));

      _defineProperty(this, "handleGetEncryptData", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        var encrytData;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return aesGCMEncrypt(_this.AesKey, _this.AesIv, new TextEncoder().encode(JSON.stringify({
                  code: _this.tempCode
                })));

              case 2:
                encrytData = _context3.sent;
                return _context3.abrupt("return", encrytData);

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      })));

      _defineProperty(this, "sendDappBridge", /*#__PURE__*/function () {
        var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(options) {
          var _this$tempKeys;

          var did_type, did_value, dAppID, encrytData, params, concatArray;
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  did_type = options.did_type, did_value = options.did_value;
                  dAppID = _this._options.dAppID;
                  _this.tempCode = GenerateRandomSixCode();
                  _context4.next = 5;
                  return _this.getWalletUserInfo({
                    did_type: did_type,
                    did_value: did_value
                  });

                case 5:
                  _context4.next = 7;
                  return _this.handleExchangeKey();

                case 7:
                  _context4.next = 9;
                  return _this.handleGetEncryptData();

                case 9:
                  encrytData = _context4.sent;

                  if (_this.walletUserInfo) {
                    _context4.next = 12;
                    break;
                  }

                  return _context4.abrupt("return");

                case 12:
                  params = {
                    nodeId: _this.nodeId,
                    payload: new TextEncoder().encode(JSON.stringify({
                      action: 'sync_key_pairs_request',
                      pubkey: (_this$tempKeys = _this.tempKeys) === null || _this$tempKeys === void 0 ? void 0 : _this$tempKeys.PublicKey,
                      content: Uint8ToBase64String(new Uint8Array(encrytData))
                    })),
                    comeFrom: "".concat(dAppID, "@").concat(did_type, ":").concat(did_value.toLowerCase()),
                    contentTopic: _this.walletUserInfo.userid
                  };
                  _context4.next = 15;
                  return sendDappBridgeCommand(params);

                case 15:
                  concatArray = _context4.sent;

                  _this.send(concatArray);

                case 17:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }));

        return function (_x2) {
          return _ref4.apply(this, arguments);
        };
      }());

      this._options = _options;
      this.timeout = 55000;
      this.timeoutObj = null;
      this.wsUrl = _options.wsUrl;
      this.callback = callback;
      this.ws = null;
      this.nodeId = '';
      this.walletUserInfo = null;
      this.tempKeys = null;
      this.tempCode = '';
      this.shareKey = '';
      this.AesKey = '';
      this.AesIv = '';
      this.init();
    }

    _createClass(SignConnect, [{
      key: "init",
      value: function init() {
        var _this2 = this;

        if (!('WebSocket' in window)) {
          throw new Error('Browser not supported WebSocket');
        }

        if (!this.wsUrl) {
          throw new Error('The url is required!');
        }

        var wsconn = new WebSocket(this.wsUrl);
        wsconn.binaryType = 'arraybuffer';
        wsconn.onopen = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
          var concatArray;
          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  console.log('connection is successful');

                  _this2.start();

                  _context5.next = 4;
                  return sendTempConnectCommand(_this2._options);

                case 4:
                  concatArray = _context5.sent;
                  wsconn.send(concatArray);

                case 6:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5);
        }));

        wsconn.onmessage = function (event) {
          _this2.reset();

          var respData = new Uint8Array(event.data);
          var PbType = respData[1];
          var bytes = respData.slice(2, respData.length);

          _this2.onMessageCallback(PbType, bytes);
        };

        this.ws = wsconn;
      }
    }, {
      key: "onMessageCallback",
      value: function () {
        var _onMessageCallback = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(PbType, bytes) {
          var resp, msgRes, _JSON$parse, content, decode_data, keys;

          return _regeneratorRuntime().wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  _context6.t0 = PbType;
                  _context6.next = _context6.t0 === PbTypeUserTempConnectResp ? 3 : _context6.t0 === PbTypePongCommand ? 7 : _context6.t0 === PbTypeMessageStatusResp ? 9 : _context6.t0 === PbTypeMessage ? 12 : 19;
                  break;

                case 3:
                  resp = UserTempConnectResp.fromBinary(bytes);
                  this.nodeId = resp.nodeID;
                  this.callback({
                    type: 'connect',
                    data: 'success'
                  });
                  return _context6.abrupt("break", 20);

                case 7:
                  WebsocketPingCommand.fromBinary(bytes);
                  return _context6.abrupt("break", 20);

                case 9:
                  Web3MQMessageStatusResp.fromBinary(bytes);
                  this.callback({
                    type: 'messageStatus',
                    data: 'success'
                  });
                  return _context6.abrupt("break", 20);

                case 12:
                  msgRes = Web3MQRequestMessage.fromBinary(bytes);
                  _JSON$parse = JSON.parse(new TextDecoder().decode(msgRes.payload) || '{content:""}'), content = _JSON$parse.content;
                  _context6.next = 16;
                  return aesGCMDecrypt(this.AesKey, this.AesIv, Base64StringToUint8(content));

                case 16:
                  decode_data = _context6.sent;

                  if (this.walletUserInfo) {
                    keys = JSON.parse(new TextDecoder().decode(new Uint8Array(decode_data)));
                    this.callback({
                      type: 'keys',
                      data: _objectSpread2(_objectSpread2({}, keys), {}, {
                        userid: this.walletUserInfo.userid
                      })
                    });
                  }

                  return _context6.abrupt("break", 20);

                case 19:
                  throw new Error('This type is not supported');

                case 20:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6, this);
        }));

        function onMessageCallback(_x3, _x4) {
          return _onMessageCallback.apply(this, arguments);
        }

        return onMessageCallback;
      }()
    }, {
      key: "send",
      value: function send(arr) {
        if (!this.ws) {
          throw new Error('websocket Initialization failed');
        }

        return this.ws.send(arr);
      }
    }, {
      key: "sendPing",
      value: function sendPing() {
        if (this.ws === null) {
          throw new Error('WebSocket is not initialized');
        }

        var timestamp = Date.now();
        var reqCommand = {
          timestamp: BigInt(timestamp)
        };
        var bytes = WebsocketPingCommand.toBinary(reqCommand);
        var concatArray = GetContactBytes(PbTypePingCommand, bytes);
        this.ws.send(concatArray);
      }
    }, {
      key: "reset",
      value: function reset() {
        if (this.timeoutObj !== null) {
          clearTimeout(this.timeoutObj);
          this.start();
        }
      }
    }, {
      key: "start",
      value: function start() {
        var _this3 = this;

        this.timeoutObj = setTimeout(function () {
          _this3.sendPing();
        }, this.timeout);
      } // eslint-disable-next-line no-unused-vars

    }, {
      key: "receive",
      value: function receive(pbType, bytes) {}
    }]);

    return SignConnect;
  }();

  var DappConnect = /*#__PURE__*/function () {
    // eslint-disable-next-line no-unused-vars
    // eslint-disable-next-line no-unused-vars
    function DappConnect(_options, callback) {
      var _this = this;

      _classCallCheck(this, DappConnect);

      _defineProperty(this, "_options", void 0);

      _defineProperty(this, "timeout", void 0);

      _defineProperty(this, "timeoutObj", void 0);

      _defineProperty(this, "ws", void 0);

      _defineProperty(this, "wsUrl", void 0);

      _defineProperty(this, "nodeId", void 0);

      _defineProperty(this, "topicID", void 0);

      _defineProperty(this, "otherTopicID", void 0);

      _defineProperty(this, "publicKeyProps", void 0);

      _defineProperty(this, "tempKeys", void 0);

      _defineProperty(this, "callback", void 0);

      _defineProperty(this, "getAesKey", /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(targetPubkey) {
          var PrivateKey, shareKey, AesKey, AesIv;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (_this.tempKeys) {
                    _context.next = 2;
                    break;
                  }

                  return _context.abrupt("return", {
                    AesKey: '',
                    AesIv: ''
                  });

                case 2:
                  PrivateKey = _this.tempKeys.PrivateKey;
                  _context.next = 5;
                  return getMessageSharedSecret(PrivateKey, targetPubkey);

                case 5:
                  shareKey = _context.sent;
                  _context.next = 8;
                  return GetAESBase64Key(shareKey);

                case 8:
                  AesKey = _context.sent;
                  AesIv = AesKey.slice(0, 16);
                  return _context.abrupt("return", {
                    AesKey: AesKey,
                    AesIv: AesIv
                  });

                case 11:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }());

      _defineProperty(this, "handleGetEncryptData", /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(options) {
          var signContent, didValue, signType, _yield$_this$getAesKe, AesKey, AesIv, encrytData;

          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  signContent = options.signContent, didValue = options.didValue, signType = options.signType;
                  _context2.next = 3;
                  return _this.getAesKey(_this.publicKeyProps);

                case 3:
                  _yield$_this$getAesKe = _context2.sent;
                  AesKey = _yield$_this$getAesKe.AesKey;
                  AesIv = _yield$_this$getAesKe.AesIv;
                  _context2.next = 8;
                  return aesGCMEncrypt(AesKey, AesIv, new TextEncoder().encode(JSON.stringify({
                    requestId: "requestId:".concat(new Date()),
                    action: 'signRequest',
                    address: didValue,
                    signRaw: signContent,
                    proposer: {
                      dAppId: _this._options.dAppID,
                      name: '',
                      description: '',
                      url: '',
                      iconUrl: '',
                      redirect: ''
                    },
                    userInfo: signType
                  })));

                case 8:
                  encrytData = _context2.sent;
                  return _context2.abrupt("return", encrytData);

                case 10:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        return function (_x2) {
          return _ref2.apply(this, arguments);
        };
      }());

      _defineProperty(this, "getConnectLink", function () {
        var _this$tempKeys;

        return "web3mq://?action=connect&topicId=".concat(_this.topicID, "&ed25519Pubkey=").concat((_this$tempKeys = _this.tempKeys) === null || _this$tempKeys === void 0 ? void 0 : _this$tempKeys.PublicKey, "&bridge=").concat(encodeURIComponent(_this.wsUrl), "&iconUrl=&website=").concat(encodeURIComponent('https://www.baidu.com'), "&redirect=");
      });

      _defineProperty(this, "sendSign", /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(options) {
          var _this$tempKeys2, _this$tempKeys3, _this$tempKeys4;

          var encrytData, params, concatArray;
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return _this.handleGetEncryptData(options);

                case 2:
                  encrytData = _context3.sent;
                  params = {
                    nodeId: _this.nodeId,
                    payload: new TextEncoder().encode(JSON.stringify({
                      publicKey: (_this$tempKeys2 = _this.tempKeys) === null || _this$tempKeys2 === void 0 ? void 0 : _this$tempKeys2.PublicKey,
                      content: Uint8ToBase64String(new Uint8Array(encrytData))
                    })),
                    comeFrom: _this.topicID,
                    contentTopic: _this.otherTopicID,
                    validatePubKey: Uint8ToBase64String(fromHexString((_this$tempKeys3 = _this.tempKeys) === null || _this$tempKeys3 === void 0 ? void 0 : _this$tempKeys3.PublicKey)),
                    PrivateKey: (_this$tempKeys4 = _this.tempKeys) === null || _this$tempKeys4 === void 0 ? void 0 : _this$tempKeys4.PrivateKey
                  };
                  _context3.next = 6;
                  return sendWeb3mqSignatureCommand(params);

                case 6:
                  concatArray = _context3.sent;

                  _this.send(concatArray);

                case 8:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }));

        return function (_x3) {
          return _ref3.apply(this, arguments);
        };
      }());

      this._options = _options;
      this.timeout = 55000;
      this.timeoutObj = null;
      this.wsUrl = _options.wsUrl;
      this.callback = callback;
      this.ws = null;
      this.nodeId = '';
      this.topicID = '';
      this.otherTopicID = '';
      this.tempKeys = null;
      this.publicKeyProps = '';
      this.init();
    }

    _createClass(DappConnect, [{
      key: "init",
      value: function init() {
        var _this2 = this;

        if (!('WebSocket' in window)) {
          throw new Error('Browser not supported WebSocket');
        }

        if (!this.wsUrl) {
          throw new Error('The url is required!');
        }

        var wsconn = new WebSocket(this.wsUrl);
        wsconn.binaryType = 'arraybuffer';
        var dAppID = this._options.dAppID;
        wsconn.onopen = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
          var keys, payload, concatArray;
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  console.log('connection is successful');

                  _this2.start();

                  _context4.next = 4;
                  return GenerateEd25519KeyPair();

                case 4:
                  keys = _context4.sent;
                  _this2.tempKeys = keys;
                  _this2.topicID = "".concat(dAppID, "@").concat(jsSha3.sha3_224(keys.PublicKey));
                  payload = {
                    nodeID: '',
                    dAppID: dAppID,
                    topicID: _this2.topicID
                  };
                  _context4.next = 10;
                  return sendWeb3mqBridgeCommand(payload);

                case 10:
                  concatArray = _context4.sent;
                  wsconn.send(concatArray);

                case 12:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }));

        wsconn.onerror = function () {
          _this2.callback({
            type: 'connect',
            data: 'error'
          });
        };

        wsconn.onclose = function () {
          _this2.callback({
            type: 'connect',
            data: 'close'
          });
        };

        wsconn.onmessage = function (event) {
          _this2.reset();

          var respData = new Uint8Array(event.data);
          var PbType = respData[1];
          var bytes = respData.slice(2, respData.length);

          _this2.onMessageCallback(PbType, bytes);
        };

        this.ws = wsconn;
      }
    }, {
      key: "onMessageCallback",
      value: function () {
        var _onMessageCallback = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(PbType, bytes) {
          var resp, msgRes, _JSON$parse, content, publicKey, _yield$this$getAesKey, AesKey, AesIv, decode_data, data;

          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  _context5.t0 = PbType;
                  _context5.next = _context5.t0 === PbTypeWeb3MQBridgeConnectResp ? 3 : _context5.t0 === PbTypePongCommand ? 7 : _context5.t0 === PbTypeMessageStatusResp ? 9 : _context5.t0 === PbTypeMessage ? 12 : 27;
                  break;

                case 3:
                  resp = Web3MQBridgeConnectCommand.fromBinary(bytes);
                  this.nodeId = resp.nodeID;
                  this.callback({
                    type: 'connect',
                    data: 'success'
                  });
                  return _context5.abrupt("break", 28);

                case 7:
                  WebsocketPingCommand.fromBinary(bytes);
                  return _context5.abrupt("break", 28);

                case 9:
                  Web3MQMessageStatusResp.fromBinary(bytes);
                  this.callback({
                    type: 'messageStatus',
                    data: 'success'
                  });
                  return _context5.abrupt("break", 28);

                case 12:
                  msgRes = Web3MQRequestMessage.fromBinary(bytes);
                  this.otherTopicID = msgRes.comeFrom;
                  _JSON$parse = JSON.parse(new TextDecoder().decode(msgRes.payload) || '{content:""}'), content = _JSON$parse.content, publicKey = _JSON$parse.publicKey;
                  this.publicKeyProps = publicKey;
                  _context5.next = 18;
                  return this.getAesKey(publicKey);

                case 18:
                  _yield$this$getAesKey = _context5.sent;
                  AesKey = _yield$this$getAesKey.AesKey;
                  AesIv = _yield$this$getAesKey.AesIv;
                  _context5.next = 23;
                  return aesGCMDecrypt(AesKey, AesIv, Base64StringToUint8(content));

                case 23:
                  decode_data = _context5.sent;
                  data = JSON.parse(new TextDecoder().decode(new Uint8Array(decode_data)));
                  this.callback({
                    type: 'dapp-connect',
                    data: data
                  });
                  return _context5.abrupt("break", 28);

                case 27:
                  throw new Error('This type is not supported');

                case 28:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5, this);
        }));

        function onMessageCallback(_x4, _x5) {
          return _onMessageCallback.apply(this, arguments);
        }

        return onMessageCallback;
      }()
    }, {
      key: "send",
      value: function send(arr) {
        if (!this.ws) {
          throw new Error('websocket Initialization failed');
        }

        return this.ws.send(arr);
      }
    }, {
      key: "sendPing",
      value: function sendPing() {
        if (this.ws === null) {
          throw new Error('WebSocket is not initialized');
        }

        var timestamp = Date.now();
        var reqCommand = {
          timestamp: BigInt(timestamp)
        };
        var bytes = WebsocketPingCommand.toBinary(reqCommand);
        var concatArray = GetContactBytes(PbTypePingCommand, bytes);
        this.ws.send(concatArray);
      }
    }, {
      key: "reset",
      value: function reset() {
        if (this.timeoutObj !== null) {
          clearTimeout(this.timeoutObj);
          this.start();
        }
      }
    }, {
      key: "start",
      value: function start() {
        var _this3 = this;

        this.timeoutObj = setTimeout(function () {
          _this3.sendPing();
        }, this.timeout);
      } // eslint-disable-next-line no-unused-vars

    }, {
      key: "receive",
      value: function receive(pbType, bytes) {}
    }]);

    return DappConnect;
  }();

  var Connect = /*#__PURE__*/function () {
    function Connect(client) {
      _classCallCheck(this, Connect);

      _defineProperty(this, "_client", void 0);

      _defineProperty(this, "timeout", void 0);

      _defineProperty(this, "timeoutObj", void 0);

      _defineProperty(this, "ws", void 0);

      _defineProperty(this, "nodeId", void 0);

      this._client = client;
      this.ws = null;
      this.nodeId = '';
      this.timeout = 40000;
      this.timeoutObj = null;
      this.init();
    }

    _createClass(Connect, [{
      key: "init",
      value: function init() {
        var _this = this;

        if (!('WebSocket' in window)) {
          throw new Error('Browser not supported WebSocket');
        }

        if (!Client.wsUrl) {
          throw new Error('The url is required!');
        }

        var wsconn = new WebSocket(Client.wsUrl);
        wsconn.binaryType = 'arraybuffer';

        if (this._client.listeners.events['connect.changeReadyStatus']) {
          this._client.emit('connect.changeReadyStatus', {
            type: 'connect.changeReadyStatus'
          });
        }

        wsconn.onopen = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          var concatArray;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  console.log('connection is successful');

                  _this.start();

                  _context.next = 4;
                  return sendConnectCommand(_this._client.keys);

                case 4:
                  concatArray = _context.sent;
                  wsconn.send(concatArray);

                  if (_this._client.listeners.events['connect.changeReadyStatus']) {
                    _this._client.emit('connect.changeReadyStatus', {
                      type: 'connect.changeReadyStatus'
                    });
                  }

                case 7:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        wsconn.onmessage = function (event) {
          _this.reset();

          var respData = new Uint8Array(event.data);
          var PbType = respData[1];
          var bytes = respData.slice(2, respData.length);

          _this.onMessageCallback(PbType, bytes);
        };

        wsconn.onclose = function () {
          if (_this._client.listeners.events['connect.changeReadyStatus']) {
            _this._client.emit('connect.changeReadyStatus', {
              type: 'connect.changeReadyStatus'
            });
          }
        };

        this.ws = wsconn;
      }
    }, {
      key: "onMessageCallback",
      value: function onMessageCallback(PbType, bytes) {
        switch (PbType) {
          case PbTypeConnectRespCommand:
            var _ConnectCommand$fromB = ConnectCommand.fromBinary(bytes),
                nodeId = _ConnectCommand$fromB.nodeId;

            this.nodeId = nodeId;
            break;

          case PbTypePongCommand:
            return WebsocketPingCommand.fromBinary(bytes);

          case PbTypeNotificationListResp:
            this.receiveNotify(PbType, bytes);
            break;

          default:
            this.receive(PbType, bytes);
            break;
        }
      }
    }, {
      key: "sendPing",
      value: function sendPing() {
        var userid = this._client.keys.userid;

        if (this.ws === null) {
          throw new Error('WebSocket is not initialized');
        }

        if (userid == null) {
          throw new Error('GenreateAndSaveKeyPair first');
        }

        var timestamp = Date.now();
        var reqCommand = {
          timestamp: BigInt(timestamp)
        };
        var bytes = WebsocketPingCommand.toBinary(reqCommand);
        var concatArray = GetContactBytes(PbTypePingCommand, bytes);
        this.ws.send(concatArray);
      }
    }, {
      key: "reset",
      value: function reset() {
        if (this.timeoutObj !== null) {
          clearTimeout(this.timeoutObj);
          this.start();
        }
      }
    }, {
      key: "start",
      value: function start() {
        var _this2 = this;

        this.timeoutObj = setTimeout(function () {
          _this2.sendPing();
        }, this.timeout);
      }
    }, {
      key: "send",
      value: function send(arr) {
        if (!this.ws) {
          throw new Error('websocket Initialization failed');
        }

        return this.ws.send(arr);
      } // eslint-disable-next-line no-unused-vars

    }, {
      key: "receive",
      value: function receive(pbType, bytes) {} // eslint-disable-next-line no-unused-vars

    }, {
      key: "receiveNotify",
      value: function receiveNotify(pbType, bytes) {}
    }]);

    return Connect;
  }();

  var Message = /*#__PURE__*/function () {
    function Message(client) {
      var _this = this;

      _classCallCheck(this, Message);

      _defineProperty(this, "_client", void 0);

      _defineProperty(this, "_keys", void 0);

      _defineProperty(this, "msg_text", void 0);

      _defineProperty(this, "messageList", void 0);

      _defineProperty(this, "receive", /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(pbType, bytes) {
          var _this$_client$channel, resp, msg, _resp, _msg, msgList, _resp2;

          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!(pbType === PbTypeMessage)) {
                    _context.next = 9;
                    break;
                  }

                  resp = Web3MQRequestMessage.fromBinary(bytes);

                  if (!(resp.messageType === 'dapp_bridge')) {
                    _context.next = 4;
                    break;
                  }

                  return _context.abrupt("return");

                case 4:
                  saveMessageUpdateDate();
                  msg = renderMessage(pbType, resp, _this._client); // if current channel is active, update msg list

                  if (getGroupId(resp, _this._client) === ((_this$_client$channel = _this._client.channel.activeChannel) === null || _this$_client$channel === void 0 ? void 0 : _this$_client$channel.chatid)) {
                    if (_this.messageList) {
                      _this.messageList = [].concat(_toConsumableArray(_this.messageList), [msg]);
                    } // channel.handleLastMessage(resp.comeFrom, msg);


                    _this._client.emit('message.getList', {
                      type: 'message.getList',
                      data: resp
                    });
                  } // unread


                  _context.next = 9;
                  return _this._client.channel.handleUnread(resp, msg);

                case 9:
                  if (pbType === PbTypeMessageStatusResp) {
                    _resp = Web3MQMessageStatusResp.fromBinary(bytes);
                    saveMessageUpdateDate();
                    _msg = renderMessage(pbType, _resp, _this._client);

                    _this._client.channel.handleUnread(_resp, _msg);

                    if (_this.messageList) {
                      msgList = updateMessageLoadStatus(_this.messageList, _msg);
                      _this.messageList = _toConsumableArray(msgList);
                    }

                    _this._client.emit('message.delivered', {
                      type: 'message.delivered',
                      data: _resp
                    });
                  }

                  if (pbType === PbTypeMessageChangeStatus) {
                    _resp2 = Web3MQChangeMessageStatus.fromBinary(bytes);
                    console.log('changeMsgStatus:', _resp2);
                  }

                case 11:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        return function (_x, _x2) {
          return _ref.apply(this, arguments);
        };
      }());

      this._client = client;
      this._keys = client.keys;
      this.msg_text = '';
      client.connect.receive = this.receive;
      this.messageList = null;
    }

    _createClass(Message, [{
      key: "getMessageList",
      value: function () {
        var _getMessageList = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(option, userId) {
          var _this$_client$channel2;

          var topic, _data$reverse, _this$_keys, userid, PrivateKey, timestamp, msg, web3mq_signature, _yield$getMessageList, _yield$getMessageList2, result, data, list;

          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  topic = userId || ((_this$_client$channel2 = this._client.channel.activeChannel) === null || _this$_client$channel2 === void 0 ? void 0 : _this$_client$channel2.chatid);

                  if (!topic) {
                    _context2.next = 19;
                    break;
                  }

                  _this$_keys = this._keys, userid = _this$_keys.userid, PrivateKey = _this$_keys.PrivateKey;
                  timestamp = Date.now();
                  msg = userid + topic + timestamp;
                  _context2.next = 7;
                  return getDataSignature(PrivateKey, msg);

                case 7:
                  web3mq_signature = _context2.sent;
                  _context2.next = 10;
                  return getMessageListRequest(_objectSpread2({
                    userid: userid,
                    timestamp: timestamp,
                    web3mq_signature: web3mq_signature,
                    topic: topic
                  }, option));

                case 10:
                  _yield$getMessageList = _context2.sent;
                  _yield$getMessageList2 = _yield$getMessageList.data.result;
                  result = _yield$getMessageList2 === void 0 ? [] : _yield$getMessageList2;
                  _context2.next = 15;
                  return renderMessagesList(result);

                case 15:
                  data = _context2.sent;
                  list = (_data$reverse = data.reverse()) !== null && _data$reverse !== void 0 ? _data$reverse : [];

                  if (this.messageList && option.page !== 1) {
                    this.messageList = [].concat(_toConsumableArray(this.messageList), _toConsumableArray(list));
                  } else {
                    this.messageList = list;
                  }

                  this._client.emit('message.getList', {
                    type: 'message.getList'
                  }); // return data;


                case 19:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function getMessageList(_x3, _x4) {
          return _getMessageList.apply(this, arguments);
        }

        return getMessageList;
      }()
      /**
       * if message from group chat: topic = group id
       * if message from one chat: topic = userid
       */

    }, {
      key: "changeMessageStatus",
      value: function () {
        var _changeMessageStatus = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(messages) {
          var _this$_client$channel3;

          var status,
              topic,
              _this$_keys2,
              userid,
              PrivateKey,
              timestamp,
              signContent,
              web3mq_signature,
              data,
              _args3 = arguments;

          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  status = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : 'delivered';
                  topic = (_this$_client$channel3 = this._client.channel.activeChannel) === null || _this$_client$channel3 === void 0 ? void 0 : _this$_client$channel3.chatid;

                  if (!topic) {
                    _context3.next = 13;
                    break;
                  }

                  _this$_keys2 = this._keys, userid = _this$_keys2.userid, PrivateKey = _this$_keys2.PrivateKey;
                  timestamp = Date.now();
                  signContent = userid + status + timestamp;
                  _context3.next = 8;
                  return getDataSignature(PrivateKey, signContent);

                case 8:
                  web3mq_signature = _context3.sent;
                  _context3.next = 11;
                  return changeMessageStatusRequest({
                    topic: topic,
                    web3mq_signature: web3mq_signature,
                    timestamp: timestamp,
                    userid: userid,
                    messages: messages,
                    status: status
                  });

                case 11:
                  data = _context3.sent;
                  return _context3.abrupt("return", data);

                case 13:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function changeMessageStatus(_x5) {
          return _changeMessageStatus.apply(this, arguments);
        }

        return changeMessageStatus;
      }()
    }, {
      key: "sendMessage",
      value: function () {
        var _sendMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(msg, userId) {
          var _channel$activeChanne;

          var _this$_client, keys, connect, channel, topicId, _yield$sendMessageCom, concatArray, msgid, tempMessageData, tempMessage;

          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _this$_client = this._client, keys = _this$_client.keys, connect = _this$_client.connect, channel = _this$_client.channel;

                  if (!userId) {
                    _context4.next = 7;
                    break;
                  }

                  _context4.next = 4;
                  return transformAddress(userId);

                case 4:
                  _context4.t0 = _context4.sent;
                  _context4.next = 8;
                  break;

                case 7:
                  _context4.t0 = (_channel$activeChanne = channel.activeChannel) === null || _channel$activeChanne === void 0 ? void 0 : _channel$activeChanne.chatid;

                case 8:
                  topicId = _context4.t0;

                  if (!topicId) {
                    _context4.next = 21;
                    break;
                  }

                  this.msg_text = msg;
                  _context4.next = 13;
                  return sendMessageCommand(keys, topicId, msg, connect.nodeId);

                case 13:
                  _yield$sendMessageCom = _context4.sent;
                  concatArray = _yield$sendMessageCom.concatArray;
                  msgid = _yield$sendMessageCom.msgid;
                  tempMessageData = {
                    messageId: msgid,
                    timestamp: BigInt(Math.round(Date.now() / 1000))
                  };
                  tempMessage = renderMessage(PbTypeMessageStatusResp, tempMessageData, this._client);

                  if (this.messageList) {
                    this.messageList = [].concat(_toConsumableArray(this.messageList), [_objectSpread2({}, tempMessage)]);
                  }

                  if (this._client.listeners.events['message.send']) {
                    this._client.emit('message.send', {
                      type: 'message.send'
                    });
                  }

                  connect.send(concatArray);

                case 21:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));

        function sendMessage(_x6, _x7) {
          return _sendMessage.apply(this, arguments);
        }

        return sendMessage;
      }()
    }]);

    return Message;
  }();

  var User = /*#__PURE__*/function () {
    function User(client) {
      _classCallCheck(this, User);

      _defineProperty(this, "_client", void 0);

      _defineProperty(this, "_keys", void 0);

      _defineProperty(this, "userInfo", void 0);

      this._client = client;
      this._keys = client.keys;
      this.userInfo = null;
    }

    _createClass(User, [{
      key: "searchUsers",
      value: function () {
        var _searchUsers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(walletAddress) {
          var _this$_keys, userid, PrivateKey, timestamp, signContent, web3mq_signature, _yield$searchUsersReq, data;

          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _this$_keys = this._keys, userid = _this$_keys.userid, PrivateKey = _this$_keys.PrivateKey;
                  timestamp = Date.now();
                  signContent = userid + walletAddress + timestamp;
                  _context.next = 5;
                  return getDataSignature(PrivateKey, signContent);

                case 5:
                  web3mq_signature = _context.sent;
                  _context.next = 8;
                  return searchUsersRequest({
                    web3mq_signature: web3mq_signature,
                    userid: userid,
                    timestamp: timestamp,
                    keyword: walletAddress
                  });

                case 8:
                  _yield$searchUsersReq = _context.sent;
                  data = _yield$searchUsersReq.data;
                  this.userInfo = data;
                  return _context.abrupt("return", data);

                case 12:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function searchUsers(_x) {
          return _searchUsers.apply(this, arguments);
        }

        return searchUsers;
      }()
    }, {
      key: "getMyProfile",
      value: function () {
        var _getMyProfile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
          var _this$_keys2, userid, PrivateKey, timestamp, signContent, web3mq_signature, _yield$getMyProfileRe, data;

          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _this$_keys2 = this._keys, userid = _this$_keys2.userid, PrivateKey = _this$_keys2.PrivateKey;
                  timestamp = Date.now();
                  signContent = userid + timestamp;
                  _context2.next = 5;
                  return getDataSignature(PrivateKey, signContent);

                case 5:
                  web3mq_signature = _context2.sent;
                  _context2.next = 8;
                  return getMyProfileRequest({
                    web3mq_signature: web3mq_signature,
                    userid: userid,
                    timestamp: timestamp
                  });

                case 8:
                  _yield$getMyProfileRe = _context2.sent;
                  data = _yield$getMyProfileRe.data;
                  return _context2.abrupt("return", data);

                case 11:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function getMyProfile() {
          return _getMyProfile.apply(this, arguments);
        }

        return getMyProfile;
      }()
    }, {
      key: "updateMyProfile",
      value: function () {
        var _updateMyProfile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(nickname, avatar_url) {
          var _this$_keys3, userid, PrivateKey, timestamp, signContent, web3mq_signature, data;

          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _this$_keys3 = this._keys, userid = _this$_keys3.userid, PrivateKey = _this$_keys3.PrivateKey;
                  timestamp = Date.now();
                  signContent = userid + timestamp;
                  _context3.next = 5;
                  return getDataSignature(PrivateKey, signContent);

                case 5:
                  web3mq_signature = _context3.sent;
                  _context3.next = 8;
                  return updateMyProfileRequest({
                    web3mq_signature: web3mq_signature,
                    userid: userid,
                    timestamp: timestamp,
                    nickname: nickname,
                    avatar_url: avatar_url
                  });

                case 8:
                  data = _context3.sent;
                  return _context3.abrupt("return", data);

                case 10:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function updateMyProfile(_x2, _x3) {
          return _updateMyProfile.apply(this, arguments);
        }

        return updateMyProfile;
      }()
    }, {
      key: "getUserBindDids",
      value: function () {
        var _getUserBindDids = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
          var _this$_keys4, userid, PrivateKey, timestamp, signContent, web3mq_signature, _yield$getUserBindDid, data;

          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _this$_keys4 = this._keys, userid = _this$_keys4.userid, PrivateKey = _this$_keys4.PrivateKey;
                  timestamp = Date.now();
                  signContent = userid + timestamp;
                  _context4.next = 5;
                  return getDataSignature(PrivateKey, signContent);

                case 5:
                  web3mq_signature = _context4.sent;
                  _context4.next = 8;
                  return getUserBindDidsRequest({
                    web3mq_signature: web3mq_signature,
                    userid: userid,
                    timestamp: timestamp
                  });

                case 8:
                  _yield$getUserBindDid = _context4.sent;
                  data = _yield$getUserBindDid.data;
                  return _context4.abrupt("return", data);

                case 11:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));

        function getUserBindDids() {
          return _getUserBindDids.apply(this, arguments);
        }

        return getUserBindDids;
      }()
    }, {
      key: "userBindDid",
      value: function () {
        var _userBindDid = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(params) {
          var did_type, did_value, _this$_keys5, userid, PrivateKey, timestamp, signContent, web3mq_signature, data;

          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  did_type = params.did_type, did_value = params.did_value;
                  _this$_keys5 = this._keys, userid = _this$_keys5.userid, PrivateKey = _this$_keys5.PrivateKey;
                  timestamp = Date.now();
                  signContent = userid + did_type + did_value + timestamp;
                  _context5.next = 6;
                  return getDataSignature(PrivateKey, signContent);

                case 6:
                  web3mq_signature = _context5.sent;
                  _context5.next = 9;
                  return userBindDidRequest(_objectSpread2({
                    web3mq_signature: web3mq_signature,
                    userid: userid,
                    timestamp: timestamp
                  }, params));

                case 9:
                  data = _context5.sent;
                  return _context5.abrupt("return", data);

                case 11:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5, this);
        }));

        function userBindDid(_x4) {
          return _userBindDid.apply(this, arguments);
        }

        return userBindDid;
      }()
    }, {
      key: "getUserPermissions",
      value: function () {
        var _getUserPermissions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
          var _this$_keys6, userid, PrivateKey, timestamp, signContent, web3mq_user_signature, _yield$getUserPermiss, data;

          return _regeneratorRuntime().wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  _this$_keys6 = this._keys, userid = _this$_keys6.userid, PrivateKey = _this$_keys6.PrivateKey;
                  timestamp = Date.now();
                  signContent = userid + timestamp;
                  _context6.next = 5;
                  return getDataSignature(PrivateKey, signContent);

                case 5:
                  web3mq_user_signature = _context6.sent;
                  _context6.next = 8;
                  return getUserPermissionsRequest({
                    web3mq_user_signature: web3mq_user_signature,
                    userid: userid,
                    timestamp: timestamp
                  });

                case 8:
                  _yield$getUserPermiss = _context6.sent;
                  data = _yield$getUserPermiss.data;
                  return _context6.abrupt("return", data);

                case 11:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6, this);
        }));

        function getUserPermissions() {
          return _getUserPermissions.apply(this, arguments);
        }

        return getUserPermissions;
      }()
    }, {
      key: "getTargetUserPermissions",
      value: function () {
        var _getTargetUserPermissions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(userId) {
          var target_userid, _this$_keys7, userid, PrivateKey, timestamp, signContent, web3mq_user_signature, data;

          return _regeneratorRuntime().wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  _context7.next = 2;
                  return transformAddress(userId);

                case 2:
                  target_userid = _context7.sent;
                  _this$_keys7 = this._keys, userid = _this$_keys7.userid, PrivateKey = _this$_keys7.PrivateKey;
                  timestamp = Date.now();
                  signContent = userid + target_userid + timestamp;
                  _context7.next = 8;
                  return getDataSignature(PrivateKey, signContent);

                case 8:
                  web3mq_user_signature = _context7.sent;
                  _context7.next = 11;
                  return getTargetUserPermissionsRequest({
                    web3mq_user_signature: web3mq_user_signature,
                    userid: userid,
                    timestamp: timestamp,
                    target_userid: target_userid
                  });

                case 11:
                  data = _context7.sent;
                  return _context7.abrupt("return", data);

                case 13:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7, this);
        }));

        function getTargetUserPermissions(_x5) {
          return _getTargetUserPermissions.apply(this, arguments);
        }

        return getTargetUserPermissions;
      }()
    }, {
      key: "updateUserPermissions",
      value: function () {
        var _updateUserPermissions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(params) {
          var permissions, permissionsStr, _this$_keys8, userid, PrivateKey, timestamp, signContent, web3mq_user_signature, data;

          return _regeneratorRuntime().wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  permissions = params.permissions;
                  permissionsStr = JSON.stringify(permissions);
                  _this$_keys8 = this._keys, userid = _this$_keys8.userid, PrivateKey = _this$_keys8.PrivateKey;
                  timestamp = Date.now();
                  signContent = userid + permissionsStr + timestamp;
                  _context8.next = 7;
                  return getDataSignature(PrivateKey, signContent);

                case 7:
                  web3mq_user_signature = _context8.sent;
                  _context8.next = 10;
                  return updateUserPermissionsRequest(_objectSpread2({
                    web3mq_user_signature: web3mq_user_signature,
                    userid: userid,
                    timestamp: timestamp
                  }, params));

                case 10:
                  data = _context8.sent;
                  return _context8.abrupt("return", data);

                case 12:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee8, this);
        }));

        function updateUserPermissions(_x6) {
          return _updateUserPermissions.apply(this, arguments);
        }

        return updateUserPermissions;
      }()
    }]);

    return User;
  }();

  var Contact = /*#__PURE__*/function () {
    function Contact(client) {
      _classCallCheck(this, Contact);

      _defineProperty(this, "_client", void 0);

      _defineProperty(this, "_keys", void 0);

      _defineProperty(this, "contactList", void 0);

      _defineProperty(this, "followerList", void 0);

      _defineProperty(this, "followingList", void 0);

      _defineProperty(this, "myFriendRequestList", void 0);

      _defineProperty(this, "receiveFriendRequestList", void 0);

      this._client = client;
      this._keys = client.keys;
      this.contactList = null;
      this.followerList = null;
      this.followingList = null;
      this.myFriendRequestList = null;
      this.receiveFriendRequestList = null;
    }
    /**
     * @deprecated
     */


    _createClass(Contact, [{
      key: "searchContact",
      value: function () {
        var _searchContact = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(walletAddress) {
          var _this$_keys, userid, PrivateKey, timestamp, signContent, web3mq_signature, data;

          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _this$_keys = this._keys, userid = _this$_keys.userid, PrivateKey = _this$_keys.PrivateKey;
                  timestamp = Date.now();
                  signContent = userid + walletAddress + timestamp;
                  _context.next = 5;
                  return getDataSignature(PrivateKey, signContent);

                case 5:
                  web3mq_signature = _context.sent;
                  _context.next = 8;
                  return searchContactRequest({
                    web3mq_signature: web3mq_signature,
                    userid: userid,
                    timestamp: timestamp,
                    keyword: walletAddress
                  });

                case 8:
                  data = _context.sent;
                  return _context.abrupt("return", data);

                case 10:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function searchContact(_x) {
          return _searchContact.apply(this, arguments);
        }

        return searchContact;
      }()
    }, {
      key: "getContactList",
      value: function () {
        var _getContactList = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(option) {
          var emit, _this$_keys2, userid, PrivateKey, timestamp, signContent, web3mq_user_signature, _yield$getContactList, data, newContacts;

          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  emit = this._client.emit;
                  _this$_keys2 = this._keys, userid = _this$_keys2.userid, PrivateKey = _this$_keys2.PrivateKey;
                  timestamp = Date.now();
                  signContent = userid + timestamp;
                  _context2.next = 6;
                  return getDataSignature(PrivateKey, signContent);

                case 6:
                  web3mq_user_signature = _context2.sent;
                  _context2.next = 9;
                  return getContactListRequest(_objectSpread2({
                    userid: userid,
                    web3mq_user_signature: web3mq_user_signature,
                    timestamp: timestamp
                  }, option));

                case 9:
                  _yield$getContactList = _context2.sent;
                  data = _yield$getContactList.data;
                  newContacts = data.user_list.filter(function (item) {
                    return item.follow_status === 'follow_each';
                  });

                  if (this.contactList && option.page !== 1) {
                    this.contactList = [].concat(_toConsumableArray(this.contactList), _toConsumableArray(newContacts));
                  } else {
                    this.contactList = newContacts;
                  }

                  emit('contact.getContactList', {
                    type: 'contact.getContactList'
                  });
                  return _context2.abrupt("return", newContacts);

                case 15:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function getContactList(_x2) {
          return _getContactList.apply(this, arguments);
        }

        return getContactList;
      }()
    }, {
      key: "getFollowerList",
      value: function () {
        var _getFollowerList = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(option) {
          var _this$_keys3, userid, PrivateKey, timestamp, signContent, web3mq_user_signature, _yield$getFollowerLis, data;

          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _this$_keys3 = this._keys, userid = _this$_keys3.userid, PrivateKey = _this$_keys3.PrivateKey;
                  timestamp = Date.now();
                  signContent = userid + timestamp;
                  _context3.next = 5;
                  return getDataSignature(PrivateKey, signContent);

                case 5:
                  web3mq_user_signature = _context3.sent;
                  _context3.next = 8;
                  return getFollowerListRequest(_objectSpread2({
                    web3mq_user_signature: web3mq_user_signature,
                    userid: userid,
                    timestamp: timestamp
                  }, option));

                case 8:
                  _yield$getFollowerLis = _context3.sent;
                  data = _yield$getFollowerLis.data;

                  if (this.followerList && option.page !== 1) {
                    this.followerList = [].concat(_toConsumableArray(this.followerList), _toConsumableArray(data.user_list));
                  } else {
                    this.followerList = data.user_list;
                  }

                  if (this._client.listeners.events['contact.getFollowerList']) {
                    this._client.emit('contact.getFollowerList', {
                      type: 'contact.getFollowerList'
                    });
                  }
                  return _context3.abrupt("return", data.user_list);

                case 15:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function getFollowerList(_x3) {
          return _getFollowerList.apply(this, arguments);
        }

        return getFollowerList;
      }()
    }, {
      key: "getFollowingList",
      value: function () {
        var _getFollowingList = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(option) {
          var _this$_keys4, userid, PrivateKey, timestamp, signContent, web3mq_user_signature, _yield$getFollowingLi, data;

          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _this$_keys4 = this._keys, userid = _this$_keys4.userid, PrivateKey = _this$_keys4.PrivateKey;
                  timestamp = Date.now();
                  signContent = userid + timestamp;
                  _context4.next = 5;
                  return getDataSignature(PrivateKey, signContent);

                case 5:
                  web3mq_user_signature = _context4.sent;
                  _context4.next = 8;
                  return getFollowingListRequest(_objectSpread2({
                    web3mq_user_signature: web3mq_user_signature,
                    userid: userid,
                    timestamp: timestamp
                  }, option));

                case 8:
                  _yield$getFollowingLi = _context4.sent;
                  data = _yield$getFollowingLi.data;

                  if (this.followingList && option.page !== 1) {
                    this.followingList = [].concat(_toConsumableArray(this.followingList), _toConsumableArray(data.user_list));
                  } else {
                    this.followingList = data.user_list;
                  }

                  if (this._client.listeners.events['contact.getFollowingList']) {
                    this._client.emit('contact.getFollowingList', {
                      type: 'contact.getFollowingList'
                    });
                  }
                  return _context4.abrupt("return", data.user_list);

                case 15:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));

        function getFollowingList(_x4) {
          return _getFollowingList.apply(this, arguments);
        }

        return getFollowingList;
      }()
    }, {
      key: "sendFriend",
      value: function () {
        var _sendFriend = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(target_id) {
          var content,
              _this$_keys5,
              userid,
              PrivateKey,
              target_userid,
              timestamp,
              signContent,
              web3mq_signature,
              data,
              _args5 = arguments;

          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  content = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : '';
                  _this$_keys5 = this._keys, userid = _this$_keys5.userid, PrivateKey = _this$_keys5.PrivateKey;
                  _context5.next = 4;
                  return transformAddress(target_id);

                case 4:
                  target_userid = _context5.sent;
                  timestamp = Date.now();
                  signContent = userid + target_userid + content + timestamp;
                  _context5.next = 9;
                  return getDataSignature(PrivateKey, signContent);

                case 9:
                  web3mq_signature = _context5.sent;
                  _context5.next = 12;
                  return sendFriendRequest({
                    content: content,
                    web3mq_signature: web3mq_signature,
                    userid: userid,
                    timestamp: timestamp,
                    target_userid: target_userid
                  });

                case 12:
                  data = _context5.sent;
                  return _context5.abrupt("return", data);

                case 14:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5, this);
        }));

        function sendFriend(_x5) {
          return _sendFriend.apply(this, arguments);
        }

        return sendFriend;
      }()
    }, {
      key: "followOperation",
      value: function () {
        var _followOperation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(params) {
          var address, target_userid, action, did_type, _this$_keys6, userid, PublicKey, did_pubkey, timestamp, nonce, sign_content, _yield$Client$registe, did_signature, data;

          return _regeneratorRuntime().wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  address = params.address, target_userid = params.target_userid, action = params.action, did_type = params.did_type;
                  _this$_keys6 = this._keys, userid = _this$_keys6.userid, PublicKey = _this$_keys6.PublicKey;
                  did_pubkey = did_type === 'starknet' ? PublicKey : undefined;
                  timestamp = Date.now();
                  nonce = jsSha3.sha3_224(userid + action + target_userid + timestamp);
                  sign_content = "\n    Web3MQ wants you to sign in with your ".concat(did_type, " account:\n    ").concat(address, "\n    \n    For follow signature\n    \n    Nonce: ").concat(nonce, "\n    Issued At: ").concat(newDateFormat(timestamp, 'Y/m/d h:i'));
                  _context6.next = 8;
                  return Client.register.sign(sign_content, address, did_type);

                case 8:
                  _yield$Client$registe = _context6.sent;
                  did_signature = _yield$Client$registe.sign;
                  _context6.next = 12;
                  return followOperationRequest(_objectSpread2({
                    did_pubkey: did_pubkey,
                    did_signature: did_signature,
                    sign_content: sign_content,
                    userid: userid,
                    timestamp: timestamp
                  }, params));

                case 12:
                  data = _context6.sent;

                  if (this._client.listeners.events['contact.updateList']) {
                    this._client.emit('contact.updateList', {
                      type: 'contact.updateList'
                    });
                  }
                  return _context6.abrupt("return", data);

                case 16:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6, this);
        }));

        function followOperation(_x6) {
          return _followOperation.apply(this, arguments);
        }

        return followOperation;
      }()
    }, {
      key: "publishNotificationToFollowers",
      value: function () {
        var _publishNotificationToFollowers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(params) {
          var title, _this$_keys7, userid, PrivateKey, timestamp, signContent, web3mq_user_signature, data;

          return _regeneratorRuntime().wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  title = params.title;
                  _this$_keys7 = this._keys, userid = _this$_keys7.userid, PrivateKey = _this$_keys7.PrivateKey;
                  timestamp = Date.now();
                  signContent = userid + title + timestamp;
                  _context7.next = 6;
                  return getDataSignature(PrivateKey, signContent);

                case 6:
                  web3mq_user_signature = _context7.sent;
                  _context7.next = 9;
                  return publishNotificationToFollowersRequest(_objectSpread2({
                    web3mq_user_signature: web3mq_user_signature,
                    userid: userid,
                    timestamp: timestamp
                  }, params));

                case 9:
                  data = _context7.sent;
                  return _context7.abrupt("return", data);

                case 11:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7, this);
        }));

        function publishNotificationToFollowers(_x7) {
          return _publishNotificationToFollowers.apply(this, arguments);
        }

        return publishNotificationToFollowers;
      }()
      /**
      * @deprecated
      */

    }, {
      key: "getMyFriendRequestList",
      value: function () {
        var _getMyFriendRequestList = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(option) {
          var emit, _this$_keys8, userid, PrivateKey, timestamp, signContent, web3mq_signature, _yield$getMyFriendLis, data;

          return _regeneratorRuntime().wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  emit = this._client.emit;
                  _this$_keys8 = this._keys, userid = _this$_keys8.userid, PrivateKey = _this$_keys8.PrivateKey;
                  timestamp = Date.now();
                  signContent = userid + timestamp;
                  _context8.next = 6;
                  return getDataSignature(PrivateKey, signContent);

                case 6:
                  web3mq_signature = _context8.sent;
                  _context8.next = 9;
                  return getMyFriendListRequset(_objectSpread2({
                    web3mq_signature: web3mq_signature,
                    userid: userid,
                    timestamp: timestamp
                  }, option));

                case 9:
                  _yield$getMyFriendLis = _context8.sent;
                  data = _yield$getMyFriendLis.data;
                  this.myFriendRequestList = data.result;
                  emit('contact.friendList', {
                    type: 'contact.friendList'
                  }); // return data;

                case 13:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee8, this);
        }));

        function getMyFriendRequestList(_x8) {
          return _getMyFriendRequestList.apply(this, arguments);
        }

        return getMyFriendRequestList;
      }()
      /**
      * @deprecated
      */

    }, {
      key: "getReceiveFriendRequestList",
      value: function () {
        var _getReceiveFriendRequestList = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(option) {
          var emit, _this$_keys9, userid, PrivateKey, timestamp, signContent, web3mq_signature, _yield$getRreceiveFri, data;

          return _regeneratorRuntime().wrap(function _callee9$(_context9) {
            while (1) {
              switch (_context9.prev = _context9.next) {
                case 0:
                  emit = this._client.emit;
                  _this$_keys9 = this._keys, userid = _this$_keys9.userid, PrivateKey = _this$_keys9.PrivateKey;
                  timestamp = Date.now();
                  signContent = userid + timestamp;
                  _context9.next = 6;
                  return getDataSignature(PrivateKey, signContent);

                case 6:
                  web3mq_signature = _context9.sent;
                  _context9.next = 9;
                  return getRreceiveFriendListRequests(_objectSpread2({
                    web3mq_signature: web3mq_signature,
                    userid: userid,
                    timestamp: timestamp
                  }, option));

                case 9:
                  _yield$getRreceiveFri = _context9.sent;
                  data = _yield$getRreceiveFri.data;
                  this.receiveFriendRequestList = data.result;
                  emit('contact.reviceList', {
                    type: 'contact.reviceList'
                  }); // return data;

                case 13:
                case "end":
                  return _context9.stop();
              }
            }
          }, _callee9, this);
        }));

        function getReceiveFriendRequestList(_x9) {
          return _getReceiveFriendRequestList.apply(this, arguments);
        }

        return getReceiveFriendRequestList;
      }()
      /**
      * @deprecated
      */

    }, {
      key: "operationFriend",
      value: function () {
        var _operationFriend = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(target_userid) {
          var action,
              _this$_keys10,
              userid,
              PrivateKey,
              emit,
              timestamp,
              signContent,
              web3mq_signature,
              data,
              _args10 = arguments;

          return _regeneratorRuntime().wrap(function _callee10$(_context10) {
            while (1) {
              switch (_context10.prev = _context10.next) {
                case 0:
                  action = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : 'agree';
                  _this$_keys10 = this._keys, userid = _this$_keys10.userid, PrivateKey = _this$_keys10.PrivateKey;
                  emit = this._client.emit;
                  timestamp = Date.now();
                  signContent = userid + action + target_userid + timestamp;
                  _context10.next = 7;
                  return getDataSignature(PrivateKey, signContent);

                case 7:
                  web3mq_signature = _context10.sent;
                  _context10.next = 10;
                  return operationFriendRequest({
                    web3mq_signature: web3mq_signature,
                    userid: userid,
                    timestamp: timestamp,
                    target_userid: target_userid,
                    action: action
                  });

                case 10:
                  data = _context10.sent;
                  emit('contact.getList', {
                    type: 'contact.getList'
                  });
                  return _context10.abrupt("return", data);

                case 13:
                case "end":
                  return _context10.stop();
              }
            }
          }, _callee10, this);
        }));

        function operationFriend(_x10) {
          return _operationFriend.apply(this, arguments);
        }

        return operationFriend;
      }()
    }]);

    return Contact;
  }();

  var Notify = /*#__PURE__*/function () {
    function Notify(client) {
      var _this = this;

      _classCallCheck(this, Notify);

      _defineProperty(this, "_client", void 0);

      _defineProperty(this, "_keys", void 0);

      _defineProperty(this, "notificationList", void 0);

      _defineProperty(this, "receiveNotify", function (pbType, bytes) {
        var _Web3MQMessageListRes = Web3MQMessageListResponse.fromBinary(bytes),
            data = _Web3MQMessageListRes.data;

        var list = data.map(function (item) {
          return JSON.parse(new TextDecoder().decode(item.payload));
        });

        if (!_this.notificationList) {
          _this.notificationList = list;
        } else {
          _this.notificationList = [].concat(_toConsumableArray(list), _toConsumableArray(_this.notificationList));
        }

        if (_this._client.listeners.events['notification.getList']) {
          _this._client.emit('notification.getList', {
            type: 'notification.getList'
          });
        }
      });

      this._client = client;
      this._keys = client.keys;
      client.connect.receiveNotify = this.receiveNotify;
      this.notificationList = null;
    }

    _createClass(Notify, [{
      key: "changeNotificationStatus",
      value: function () {
        var _changeNotificationStatus = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(messages) {
          var status,
              _this$_keys,
              userid,
              PrivateKey,
              timestamp,
              signContent,
              web3mq_signature,
              data,
              _args = arguments;

          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  status = _args.length > 1 && _args[1] !== undefined ? _args[1] : 'delivered';
                  _this$_keys = this._keys, userid = _this$_keys.userid, PrivateKey = _this$_keys.PrivateKey;
                  timestamp = Date.now();
                  signContent = userid + status + timestamp;
                  _context.next = 6;
                  return getDataSignature(PrivateKey, signContent);

                case 6:
                  web3mq_signature = _context.sent;
                  _context.next = 9;
                  return changeNotificationStatusRequest({
                    web3mq_signature: web3mq_signature,
                    userid: userid,
                    timestamp: timestamp,
                    messages: messages,
                    status: status
                  });

                case 9:
                  data = _context.sent;
                  return _context.abrupt("return", data);

                case 11:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function changeNotificationStatus(_x) {
          return _changeNotificationStatus.apply(this, arguments);
        }

        return changeNotificationStatus;
      }()
    }]);

    return Notify;
  }();

  var Topic = /*#__PURE__*/function () {
    function Topic(client) {
      _classCallCheck(this, Topic);

      _defineProperty(this, "_client", void 0);

      _defineProperty(this, "_keys", void 0);

      _defineProperty(this, "myTopicList", void 0);

      _defineProperty(this, "mySubscribeList", void 0);

      this._client = client;
      this._keys = client.keys;
      this.myTopicList = null;
      this.mySubscribeList = null;
    }

    _createClass(Topic, [{
      key: "getMyCreateTopicList",
      value: function () {
        var _getMyCreateTopicList = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options) {
          var _this$_keys, userid, PrivateKey, timestamp, signContent, web3mq_signature, _yield$myCreateTopicL, _yield$myCreateTopicL2, data;

          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _this$_keys = this._keys, userid = _this$_keys.userid, PrivateKey = _this$_keys.PrivateKey;
                  timestamp = Date.now();
                  signContent = userid + timestamp;
                  _context.next = 5;
                  return getDataSignature(PrivateKey, signContent);

                case 5:
                  web3mq_signature = _context.sent;
                  _context.next = 8;
                  return myCreateTopicListRequest(_objectSpread2({
                    web3mq_signature: web3mq_signature,
                    userid: userid,
                    timestamp: timestamp
                  }, options));

                case 8:
                  _yield$myCreateTopicL = _context.sent;
                  _yield$myCreateTopicL2 = _yield$myCreateTopicL.data;
                  data = _yield$myCreateTopicL2 === void 0 ? [] : _yield$myCreateTopicL2;

                  if (this.myTopicList && options.page !== 1) {
                    this.myTopicList = [].concat(_toConsumableArray(this.myTopicList), _toConsumableArray(data));
                  } else {
                    this.myTopicList = data;
                  }

                  this._client.emit('notification.getMyTopicList', {
                    type: 'notification.getMyTopicList'
                  });

                  return _context.abrupt("return", data);

                case 14:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function getMyCreateTopicList(_x) {
          return _getMyCreateTopicList.apply(this, arguments);
        }

        return getMyCreateTopicList;
      }()
    }, {
      key: "getMySubscribeTopicList",
      value: function () {
        var _getMySubscribeTopicList = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(options) {
          var _this$_keys2, userid, PrivateKey, timestamp, signContent, web3mq_signature, _yield$mySubscribeTop, data;

          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _this$_keys2 = this._keys, userid = _this$_keys2.userid, PrivateKey = _this$_keys2.PrivateKey;
                  timestamp = Date.now();
                  signContent = userid + timestamp;
                  _context2.next = 5;
                  return getDataSignature(PrivateKey, signContent);

                case 5:
                  web3mq_signature = _context2.sent;
                  _context2.next = 8;
                  return mySubscribeTopicListRequest(_objectSpread2({
                    web3mq_signature: web3mq_signature,
                    userid: userid,
                    timestamp: timestamp
                  }, options));

                case 8:
                  _yield$mySubscribeTop = _context2.sent;
                  data = _yield$mySubscribeTop.data;
                  this.mySubscribeList = data;

                  this._client.emit('notification.getMySubscribeList', {
                    type: 'notification.getMySubscribeList'
                  });

                  return _context2.abrupt("return", data);

                case 13:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function getMySubscribeTopicList(_x2) {
          return _getMySubscribeTopicList.apply(this, arguments);
        }

        return getMySubscribeTopicList;
      }()
    }, {
      key: "createTopic",
      value: function () {
        var _createTopic = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(topic_name) {
          var _this$_keys3, userid, PrivateKey, timestamp, signContent, web3mq_signature, _yield$createTopicReq, data;

          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _this$_keys3 = this._keys, userid = _this$_keys3.userid, PrivateKey = _this$_keys3.PrivateKey;
                  timestamp = Date.now();
                  signContent = userid + timestamp;
                  _context3.next = 5;
                  return getDataSignature(PrivateKey, signContent);

                case 5:
                  web3mq_signature = _context3.sent;
                  _context3.next = 8;
                  return createTopicRequest({
                    web3mq_signature: web3mq_signature,
                    userid: userid,
                    timestamp: timestamp,
                    topic_name: topic_name
                  });

                case 8:
                  _yield$createTopicReq = _context3.sent;
                  data = _yield$createTopicReq.data;
                  return _context3.abrupt("return", data);

                case 11:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function createTopic(_x3) {
          return _createTopic.apply(this, arguments);
        }

        return createTopic;
      }()
    }, {
      key: "subscribeTopic",
      value: function () {
        var _subscribeTopic = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(topicid) {
          var _this$_keys4, userid, PrivateKey, timestamp, signContent, web3mq_signature, data;

          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _this$_keys4 = this._keys, userid = _this$_keys4.userid, PrivateKey = _this$_keys4.PrivateKey;
                  timestamp = Date.now();
                  signContent = userid + topicid + timestamp;
                  _context4.next = 5;
                  return getDataSignature(PrivateKey, signContent);

                case 5:
                  web3mq_signature = _context4.sent;
                  _context4.next = 8;
                  return subscribeTopicRequest({
                    web3mq_signature: web3mq_signature,
                    userid: userid,
                    timestamp: timestamp,
                    topicid: topicid
                  });

                case 8:
                  data = _context4.sent;
                  return _context4.abrupt("return", data);

                case 10:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));

        function subscribeTopic(_x4) {
          return _subscribeTopic.apply(this, arguments);
        }

        return subscribeTopic;
      }()
    }, {
      key: "publishTopicMessage",
      value: function () {
        var _publishTopicMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(params) {
          var title, content, topicid, _this$_keys5, userid, PrivateKey, timestamp, signContent, web3mq_signature, data;

          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  title = params.title, content = params.content, topicid = params.topicid;
                  _this$_keys5 = this._keys, userid = _this$_keys5.userid, PrivateKey = _this$_keys5.PrivateKey;
                  timestamp = Date.now();
                  signContent = userid + topicid + timestamp;
                  _context5.next = 6;
                  return getDataSignature(PrivateKey, signContent);

                case 6:
                  web3mq_signature = _context5.sent;
                  _context5.next = 9;
                  return publishTopicMessageRequest({
                    web3mq_signature: web3mq_signature,
                    userid: userid,
                    timestamp: timestamp,
                    title: title,
                    content: content,
                    topicid: topicid
                  });

                case 9:
                  data = _context5.sent;
                  console.log(data);

                case 11:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5, this);
        }));

        function publishTopicMessage(_x5) {
          return _publishTopicMessage.apply(this, arguments);
        }

        return publishTopicMessage;
      }()
    }]);

    return Topic;
  }();

  const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);

  let idbProxyableTypes;
  let cursorAdvanceMethods;
  // This is a function to prevent it throwing up in node environments.
  function getIdbProxyableTypes() {
      return (idbProxyableTypes ||
          (idbProxyableTypes = [
              IDBDatabase,
              IDBObjectStore,
              IDBIndex,
              IDBCursor,
              IDBTransaction,
          ]));
  }
  // This is a function to prevent it throwing up in node environments.
  function getCursorAdvanceMethods() {
      return (cursorAdvanceMethods ||
          (cursorAdvanceMethods = [
              IDBCursor.prototype.advance,
              IDBCursor.prototype.continue,
              IDBCursor.prototype.continuePrimaryKey,
          ]));
  }
  const cursorRequestMap = new WeakMap();
  const transactionDoneMap = new WeakMap();
  const transactionStoreNamesMap = new WeakMap();
  const transformCache = new WeakMap();
  const reverseTransformCache = new WeakMap();
  function promisifyRequest(request) {
      const promise = new Promise((resolve, reject) => {
          const unlisten = () => {
              request.removeEventListener('success', success);
              request.removeEventListener('error', error);
          };
          const success = () => {
              resolve(wrap(request.result));
              unlisten();
          };
          const error = () => {
              reject(request.error);
              unlisten();
          };
          request.addEventListener('success', success);
          request.addEventListener('error', error);
      });
      promise
          .then((value) => {
          // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval
          // (see wrapFunction).
          if (value instanceof IDBCursor) {
              cursorRequestMap.set(value, request);
          }
          // Catching to avoid "Uncaught Promise exceptions"
      })
          .catch(() => { });
      // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This
      // is because we create many promises from a single IDBRequest.
      reverseTransformCache.set(promise, request);
      return promise;
  }
  function cacheDonePromiseForTransaction(tx) {
      // Early bail if we've already created a done promise for this transaction.
      if (transactionDoneMap.has(tx))
          return;
      const done = new Promise((resolve, reject) => {
          const unlisten = () => {
              tx.removeEventListener('complete', complete);
              tx.removeEventListener('error', error);
              tx.removeEventListener('abort', error);
          };
          const complete = () => {
              resolve();
              unlisten();
          };
          const error = () => {
              reject(tx.error || new DOMException('AbortError', 'AbortError'));
              unlisten();
          };
          tx.addEventListener('complete', complete);
          tx.addEventListener('error', error);
          tx.addEventListener('abort', error);
      });
      // Cache it for later retrieval.
      transactionDoneMap.set(tx, done);
  }
  let idbProxyTraps = {
      get(target, prop, receiver) {
          if (target instanceof IDBTransaction) {
              // Special handling for transaction.done.
              if (prop === 'done')
                  return transactionDoneMap.get(target);
              // Polyfill for objectStoreNames because of Edge.
              if (prop === 'objectStoreNames') {
                  return target.objectStoreNames || transactionStoreNamesMap.get(target);
              }
              // Make tx.store return the only store in the transaction, or undefined if there are many.
              if (prop === 'store') {
                  return receiver.objectStoreNames[1]
                      ? undefined
                      : receiver.objectStore(receiver.objectStoreNames[0]);
              }
          }
          // Else transform whatever we get back.
          return wrap(target[prop]);
      },
      set(target, prop, value) {
          target[prop] = value;
          return true;
      },
      has(target, prop) {
          if (target instanceof IDBTransaction &&
              (prop === 'done' || prop === 'store')) {
              return true;
          }
          return prop in target;
      },
  };
  function replaceTraps(callback) {
      idbProxyTraps = callback(idbProxyTraps);
  }
  function wrapFunction(func) {
      // Due to expected object equality (which is enforced by the caching in `wrap`), we
      // only create one new func per func.
      // Edge doesn't support objectStoreNames (booo), so we polyfill it here.
      if (func === IDBDatabase.prototype.transaction &&
          !('objectStoreNames' in IDBTransaction.prototype)) {
          return function (storeNames, ...args) {
              const tx = func.call(unwrap(this), storeNames, ...args);
              transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
              return wrap(tx);
          };
      }
      // Cursor methods are special, as the behaviour is a little more different to standard IDB. In
      // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the
      // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense
      // with real promises, so each advance methods returns a new promise for the cursor object, or
      // undefined if the end of the cursor has been reached.
      if (getCursorAdvanceMethods().includes(func)) {
          return function (...args) {
              // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
              // the original object.
              func.apply(unwrap(this), args);
              return wrap(cursorRequestMap.get(this));
          };
      }
      return function (...args) {
          // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
          // the original object.
          return wrap(func.apply(unwrap(this), args));
      };
  }
  function transformCachableValue(value) {
      if (typeof value === 'function')
          return wrapFunction(value);
      // This doesn't return, it just creates a 'done' promise for the transaction,
      // which is later returned for transaction.done (see idbObjectHandler).
      if (value instanceof IDBTransaction)
          cacheDonePromiseForTransaction(value);
      if (instanceOfAny(value, getIdbProxyableTypes()))
          return new Proxy(value, idbProxyTraps);
      // Return the same value back if we're not going to transform it.
      return value;
  }
  function wrap(value) {
      // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because
      // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.
      if (value instanceof IDBRequest)
          return promisifyRequest(value);
      // If we've already transformed this value before, reuse the transformed value.
      // This is faster, but it also provides object equality.
      if (transformCache.has(value))
          return transformCache.get(value);
      const newValue = transformCachableValue(value);
      // Not all types are transformed.
      // These may be primitive types, so they can't be WeakMap keys.
      if (newValue !== value) {
          transformCache.set(value, newValue);
          reverseTransformCache.set(newValue, value);
      }
      return newValue;
  }
  const unwrap = (value) => reverseTransformCache.get(value);

  /**
   * Open a database.
   *
   * @param name Name of the database.
   * @param version Schema version.
   * @param callbacks Additional callbacks.
   */
  function openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {
      const request = indexedDB.open(name, version);
      const openPromise = wrap(request);
      if (upgrade) {
          request.addEventListener('upgradeneeded', (event) => {
              upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
          });
      }
      if (blocked) {
          request.addEventListener('blocked', (event) => blocked(
          // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
          event.oldVersion, event.newVersion, event));
      }
      openPromise
          .then((db) => {
          if (terminated)
              db.addEventListener('close', () => terminated());
          if (blocking) {
              db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));
          }
      })
          .catch(() => { });
      return openPromise;
  }

  const readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];
  const writeMethods = ['put', 'add', 'delete', 'clear'];
  const cachedMethods = new Map();
  function getMethod(target, prop) {
      if (!(target instanceof IDBDatabase &&
          !(prop in target) &&
          typeof prop === 'string')) {
          return;
      }
      if (cachedMethods.get(prop))
          return cachedMethods.get(prop);
      const targetFuncName = prop.replace(/FromIndex$/, '');
      const useIndex = prop !== targetFuncName;
      const isWrite = writeMethods.includes(targetFuncName);
      if (
      // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
      !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||
          !(isWrite || readMethods.includes(targetFuncName))) {
          return;
      }
      const method = async function (storeName, ...args) {
          // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(
          const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');
          let target = tx.store;
          if (useIndex)
              target = target.index(args.shift());
          // Must reject if op rejects.
          // If it's a write operation, must reject if tx.done rejects.
          // Must reject with op rejection first.
          // Must resolve with op value.
          // Must handle both promises (no unhandled rejections)
          return (await Promise.all([
              target[targetFuncName](...args),
              isWrite && tx.done,
          ]))[0];
      };
      cachedMethods.set(prop, method);
      return method;
  }
  replaceTraps((oldTraps) => ({
      ...oldTraps,
      get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
      has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),
  }));

  var Storage = /*#__PURE__*/function () {
    function Storage(client) {
      _classCallCheck(this, Storage);

      _defineProperty(this, "_client", void 0);

      _defineProperty(this, "_keys", void 0);

      _defineProperty(this, "dbName", void 0);

      _defineProperty(this, "db", void 0);

      this._client = client;
      this._keys = client.keys;
      this.db = null;
      this.dbName = 'Web3MQ_table';
      this.createDB();
    }

    _createClass(Storage, [{
      key: "createDB",
      value: function () {
        var _createDB = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          var db;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return openDB(this._keys.userid, 1, {
                    upgrade: function upgrade(db) {
                      var store = db.createObjectStore('chat_history');
                      store.createIndex('roomId', 'from');
                    }
                  });

                case 2:
                  db = _context.sent;
                  this.db = db;
                  console.log('indexDB init success');

                case 5:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function createDB() {
          return _createDB.apply(this, arguments);
        }

        return createDB;
      }()
    }, {
      key: "setData",
      value: function () {
        var _setData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(key, data) {
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  if (this.db) {
                    _context2.next = 2;
                    break;
                  }

                  throw new Error('indexDB is not initialized');

                case 2:
                  _context2.next = 4;
                  return this.db.put('chat_history', data, key);

                case 4:
                  return _context2.abrupt("return", _context2.sent);

                case 5:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function setData(_x, _x2) {
          return _setData.apply(this, arguments);
        }

        return setData;
      }()
    }, {
      key: "getData",
      value: function () {
        var _getData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(key) {
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  if (this.db) {
                    _context3.next = 2;
                    break;
                  }

                  throw new Error('indexDB is not initialized');

                case 2:
                  _context3.next = 4;
                  return this.db.get('chat_history', key);

                case 4:
                  return _context3.abrupt("return", _context3.sent);

                case 5:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function getData(_x3) {
          return _getData.apply(this, arguments);
        }

        return getData;
      }()
    }, {
      key: "getDataFromIndex",
      value: function () {
        var _getDataFromIndex = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(indexKey) {
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  if (this.db) {
                    _context4.next = 2;
                    break;
                  }

                  throw new Error('indexDB is not initialized');

                case 2:
                  _context4.next = 4;
                  return this.db.getFromIndex('chat_history', 'roomId', indexKey);

                case 4:
                  return _context4.abrupt("return", _context4.sent);

                case 5:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));

        function getDataFromIndex(_x4) {
          return _getDataFromIndex.apply(this, arguments);
        }

        return getDataFromIndex;
      }()
    }, {
      key: "delData",
      value: function () {
        var _delData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(key) {
          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  if (this.db) {
                    _context5.next = 2;
                    break;
                  }

                  throw new Error('indexDB is not initialized');

                case 2:
                  _context5.next = 4;
                  return this.db["delete"]('chat_history', key);

                case 4:
                  return _context5.abrupt("return", _context5.sent);

                case 5:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5, this);
        }));

        function delData(_x5) {
          return _delData.apply(this, arguments);
        }

        return delData;
      }()
    }, {
      key: "clearData",
      value: function () {
        var _clearData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
          return _regeneratorRuntime().wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  if (this.db) {
                    _context6.next = 2;
                    break;
                  }

                  throw new Error('indexDB is not initialized');

                case 2:
                  _context6.next = 4;
                  return this.db.clear('chat_history');

                case 4:
                  return _context6.abrupt("return", _context6.sent);

                case 5:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6, this);
        }));

        function clearData() {
          return _clearData.apply(this, arguments);
        }

        return clearData;
      }()
    }, {
      key: "getAllData",
      value: function () {
        var _getAllData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
          return _regeneratorRuntime().wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  if (this.db) {
                    _context7.next = 2;
                    break;
                  }

                  throw new Error('indexDB is not initialized');

                case 2:
                  _context7.next = 4;
                  return this.db.getAll('chat_history');

                case 4:
                  return _context7.abrupt("return", _context7.sent);

                case 5:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7, this);
        }));

        function getAllData() {
          return _getAllData.apply(this, arguments);
        }

        return getAllData;
      }()
    }, {
      key: "getAllKeys",
      value: function () {
        var _getAllKeys = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
          return _regeneratorRuntime().wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  if (this.db) {
                    _context8.next = 2;
                    break;
                  }

                  throw new Error('indexDB is not initialized');

                case 2:
                  _context8.next = 4;
                  return this.db.getAllKeys('chat_history');

                case 4:
                  return _context8.abrupt("return", _context8.sent);

                case 5:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee8, this);
        }));

        function getAllKeys() {
          return _getAllKeys.apply(this, arguments);
        }

        return getAllKeys;
      }()
    }]);

    return Storage;
  }();

  var EVENT_MAP = {
    'channel.created': true,
    // channel list
    'channel.getList': true,
    // active channel
    'channel.activeChange': true,
    // channel
    'channel.updated': true,
    // contact
    'contact.activeChange': true,
    // contactlist
    'contact.getList': true,
    // contactlist
    'contact.getContactList': true,
    // followerList
    'contact.getFollowerList': true,
    // followingList
    'contact.getFollowingList': true,
    // 
    'contact.friendList': true,
    // 
    'contact.reviceList': true,
    //contactlist
    'contact.updateList': true,
    //contactlist
    'contact.updateContactList': true,
    //followerList
    'contact.updateFollowerList': true,
    //followingList
    'contact.updateFollowingList': true,
    // connect
    'connect.changeReadyStatus': true,
    // 
    'message.send': true,
    // 
    'message.delivered': true,
    // 
    'message.read': true,
    // 
    'message.updated': true,
    // message list
    'message.getList': true,
    // message thread list
    'message.getThreadList': true,
    // rommthread
    'message.openAllThread': true,
    // 
    'notification.messageNew': true,
    // notification List
    'notification.getList': true,
    'notification.getMyTopicList': true,
    'notification.getMySubscribeList': true
  };

  var IS_VALID_EVENT_MAP_TYPE = _objectSpread2(_objectSpread2({}, EVENT_MAP), {}, {
    all: true
  });

  var isValidEventType = function isValidEventType(eventType) {
    return IS_VALID_EVENT_MAP_TYPE[eventType] || false;
  };

  var EventEmitter = /*#__PURE__*/function () {
    function EventEmitter() {
      _classCallCheck(this, EventEmitter);

      _defineProperty(this, "events", void 0);

      this.events = {};
    } // 


    _createClass(EventEmitter, [{
      key: "on",
      value: function on(eventName, callback) {
        var valid = isValidEventType(eventName);

        if (!valid) {
          throw Error("Invalid event type ".concat(eventName));
        }

        if (typeof callback == 'function') {
          var callbacks = this.events[eventName] || [];
          callbacks.push(callback);
          this.events[eventName] = callbacks;
        } else {
          throw new Error("You need to add a callback method to the ".concat(eventName, " event"));
        }
      } // 

    }, {
      key: "emit",
      value: function emit(eventName) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        var callbacks = this.events[eventName] || [];

        if (callbacks.length === 0) {
          throw new Error("The ".concat(eventName, " event was not registered"));
        }

        callbacks.forEach(function (cb) {
          return cb.apply(void 0, args);
        });
      } // 

    }, {
      key: "off",
      value: function off(eventName, callback) {
        if (callback === undefined) {
          this.events[eventName] = []; // throw new Error('The callback function is required');
        }

        var callbacks = this.events[eventName] || [];
        var newCallbacks = callbacks.filter(function (fn) {
          return fn != callback && fn.initialCallback != callback;
        });
        this.events[eventName] = newCallbacks;
      }
    }, {
      key: "once",
      value: function once(eventName, callback) {
        var _this = this;

        if (callback === undefined) {
          throw new Error('The callback function is required');
        }

        var one = function one() {
          callback.apply(void 0, arguments);

          _this.off(eventName, one);
        };

        one.initialCallback = callback;
        this.on(eventName, one);
      }
    }]);

    return EventEmitter;
  }();

  var Client = /*#__PURE__*/_createClass(function Client(keys) {
    var _this = this;

    _classCallCheck(this, Client);

    _defineProperty(this, "keys", void 0);

    _defineProperty(this, "channel", void 0);

    _defineProperty(this, "listeners", void 0);

    _defineProperty(this, "connect", void 0);

    _defineProperty(this, "message", void 0);

    _defineProperty(this, "user", void 0);

    _defineProperty(this, "contact", void 0);

    _defineProperty(this, "notify", void 0);

    _defineProperty(this, "topic", void 0);

    _defineProperty(this, "storage", void 0);

    _defineProperty(this, "on", function (eventName, callback) {
      return _this.listeners.on(eventName, callback);
    });

    _defineProperty(this, "emit", function (eventName, data) {
      return _this.listeners.emit(eventName, data);
    });

    _defineProperty(this, "off", function (eventName, callback) {
      return _this.listeners.off(eventName, callback);
    });

    _defineProperty(this, "once", function (eventName, callback) {
      return _this.listeners.once(eventName, callback);
    });

    this.keys = keys;
    this.listeners = new EventEmitter();
    this.channel = new Channel(this);
    this.connect = new Connect(this);
    this.message = new Message(this);
    this.user = new User(this);
    this.contact = new Contact(this);
    this.notify = new Notify(this);
    this.topic = new Topic(this);
    this.storage = new Storage(this);
  });

  _defineProperty(Client, "_instance", void 0);

  _defineProperty(Client, "wsUrl", void 0);

  _defineProperty(Client, "register", void 0);

  _defineProperty(Client, "signClient", void 0);

  _defineProperty(Client, "dappConnectClient", void 0);

  _defineProperty(Client, "init", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var initOptions,
        connectUrl,
        app_key,
        env,
        tempPubkey,
        didKey,
        fastUrl,
        _args = arguments;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            initOptions = _args.length > 0 && _args[0] !== undefined ? _args[0] : {
              connectUrl: null
            };
            connectUrl = initOptions.connectUrl, app_key = initOptions.app_key, env = initOptions.env, tempPubkey = initOptions.tempPubkey, didKey = initOptions.didKey;
            _context.t0 = connectUrl;

            if (_context.t0) {
              _context.next = 7;
              break;
            }

            _context.next = 6;
            return getFastestUrl(env);

          case 6:
            _context.t0 = _context.sent;

          case 7:
            fastUrl = _context.t0;
            Client.wsUrl = selectUrl(fastUrl, 'ws');
            new Request(selectUrl(fastUrl), tempPubkey, didKey);
            Client.register = new Register(app_key);
            return _context.abrupt("return", fastUrl);

          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  })));

  _defineProperty(Client, "getInstance", function (keys) {
    if (!keys) {
      throw new Error('The PrivateKey and PublicKey is required!');
    }

    if (!Client._instance) {
      Client._instance = new Client(keys);
    }

    return Client._instance;
  });

  _defineProperty(Client, "getSignClient", function (options, // eslint-disable-next-line no-unused-vars
  callback) {
    if (!options) {
      throw new Error('The options is required!');
    }

    Client.signClient = new SignConnect(_objectSpread2({
      wsUrl: Client.wsUrl
    }, options), callback);
  });

  _defineProperty(Client, "initDappConnectClient", function (options, // eslint-disable-next-line no-unused-vars
  callback) {
    if (!options) {
      throw new Error('The options is required!');
    }

    Client.dappConnectClient = new DappConnect(_objectSpread2({
      wsUrl: Client.wsUrl
    }, options), callback);
  });

  exports.Base64StringToUint8 = Base64StringToUint8;
  exports.ByteArrayToHexString = ByteArrayToHexString$1;
  exports.Client = Client;
  exports.Connect = Connect;
  exports.DappConnect = DappConnect;
  exports.DownloadKeyPair = DownloadKeyPair;
  exports.GenerateEd25519KeyPair = GenerateEd25519KeyPair;
  exports.GenerateRandomSixCode = GenerateRandomSixCode;
  exports.GetAESBase64Key = GetAESBase64Key;
  exports.GetContactBytes = GetContactBytes;
  exports.SendMsgLoadingMap = SendMsgLoadingMap;
  exports.SignConnect = SignConnect;
  exports.Uint8ToBase64String = Uint8ToBase64String;
  exports.WalletNameMap = WalletNameMap;
  exports.aesGCMDecrypt = aesGCMDecrypt;
  exports.aesGCMEncrypt = aesGCMEncrypt;
  exports.fromHexString = fromHexString;
  exports.getAllDomainList = getAllDomainList;
  exports.getCurrentDate = getCurrentDate;
  exports.getDataSignature = getDataSignature;
  exports.getFastestUrl = getFastestUrl;
  exports.getGroupId = getGroupId;
  exports.getMessageSharedSecret = getMessageSharedSecret;
  exports.getMessageUpdateDate = getMessageUpdateDate;
  exports.getPublicFollowerListRequest = getPublicFollowerListRequest;
  exports.getPublicFollowingListRequest = getPublicFollowingListRequest;
  exports.getUserInfoRequest = getUserInfoRequest;
  exports.getUserPublicProfileRequest = getUserPublicProfileRequest;
  exports.newDateFormat = newDateFormat;
  exports.renderMessage = renderMessage;
  exports.renderMessagesList = renderMessagesList;
  exports.saveMessageUpdateDate = saveMessageUpdateDate;
  exports.selectUrl = selectUrl;
  exports.sha256 = sha256;
  exports.transformAddress = transformAddress;
  exports.updateMessageLoadStatus = updateMessageLoadStatus;
  exports.userLoginRequest = userLoginRequest;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
